<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Golang on Gavin&#39;s Blog</title>
    <link>https://wushaoqiang.github.io/categories/Golang/</link>
    <description>Recent content in Golang on Gavin&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 28 Apr 2019 16:25:41 +0800</lastBuildDate>
    
	<atom:link href="https://wushaoqiang.github.io/categories/Golang/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>TenToSeventeen</title>
      <link>https://wushaoqiang.github.io/posts/tenToSeventeen/</link>
      <pubDate>Sun, 28 Apr 2019 16:25:41 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/tenToSeventeen/</guid>
      <description>代码 func findHighBit(num int) (tmp, b int) { tmp = 1 b = 0 for { if tmp*16 &amp;gt; num { return tmp, b } tmp = tmp * 16 b++ } } func tenToSeventeen(num int) []int { tmp, b := findHighBit(num) result := make([]int, 0) for i := b; i &amp;gt;= 0; i-- { j := 0 for { if tmp*j &amp;lt;= num { j++ } else { break } } result = append(result, j-1) num = num - tmp*(j-1) tmp = tmp / 16 } return result } func intToString(result []int) []string { strs := make([]string, 0) for _, num := range result { switch { case num &amp;lt; 10: strs = append(strs, strconv.</description>
    </item>
    
    <item>
      <title>Golang GC</title>
      <link>https://wushaoqiang.github.io/posts/golang-GC/</link>
      <pubDate>Sat, 27 Apr 2019 12:48:58 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/golang-GC/</guid>
      <description>用了Golang有一段时间了，知道Golang能够自动回收内存也有一段时间了，对于我这种不搞明白原理不甘心系列，今天就来搞明白什么是GC
参考  legendtkl
 Golang UK Conference 2017 | Will Sewell &amp;amp; Jim Fisher - Golang&amp;rsquo;s Realtime GC in Theory and Practice
  算法模型 三色标记算法(Mark-and-sweep)
三色分别为(黑色，灰色，白色)，其中黑色不能够有指针指向白色的数据
 这个算法实现广度优先(BF)
 重复选取一个灰色，将它的所指向的所有对象都变成灰色，自己变成黑色
 这个重复选取直到没有灰色的对象为止
  在上面三个步骤能体会到各个颜色代表的意思(运行阶段)
 黑色：已经遍历过这个对象的所有对象
 灰色：这个对象所指向的对象还没有被遍历过
 白色：它被指向的节点是灰色、或者它根本没有被指向(这就是垃圾)
  结束阶段里，按算法所解释的，是不会再有灰色了，只有
 黑色：有用的数据
 白色：已经不可能到达的数据(垃圾，会被清理)
  回收时主要的流程  从root开始找到所有可达的对象，标记灰色
 执行我们前面所说的模型里的循环
 在处理完循环后，清理所有白色标记的对象
  小结 其实GC还有很多很多的细节，笔者只是在这里先建立一个概念，等后面到达一定阶段再去看看具体的实现</description>
    </item>
    
    <item>
      <title>Golang 依赖注入</title>
      <link>https://wushaoqiang.github.io/posts/golang-dependency-injection/</link>
      <pubDate>Fri, 26 Apr 2019 21:05:43 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/golang-dependency-injection/</guid>
      <description>面试时遇到一道题，问依赖注入带来了什么好处。。。？？？我连啥是依赖注入都不知道，真是打扰了，赶紧补回来
没有DI 把所有创建变量放在New函数里面
type Person struct{ name string age int } type Student struct{ person *Person } func NewPerson() *Person{ return &amp;amp;Person{} } func NewStudent() *Student{ return &amp;amp;Student{ person:&amp;amp;Person{}, } } func main(){ s := NewStudent() }  我们不能按照自己的意愿传入想要的参数,这样main函数比较简单
有DI type Person struct{ name string age int } type Student struct{ person *Person } func NewPerson(name string,age int) *Person{ return &amp;amp;Person{ name:name, age:age, } } func NewStudent(person *Person) *Student{ return &amp;amp;Student{ person:person, } } func main(){ p := NewPerson(&amp;quot;abc&amp;quot;,12) s := NewStudent(p) }  这里我们就是有依赖注入，能够按照我们的需要传入参数，但是main的代码会随着结构体的传递变得很长</description>
    </item>
    
    <item>
      <title>Golang 泛型</title>
      <link>https://wushaoqiang.github.io/posts/golang-generic/</link>
      <pubDate>Fri, 26 Apr 2019 19:55:21 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/golang-generic/</guid>
      <description>笔者今天参加了一个面试，笔试第一题泛型，因为Go里没有泛型，因此对此毫无概念，开这篇文章解决这个问题
泛型是什么 类型的参数化，在静态语言里，类型尤为重要，虽然Go里interface{}接口可以传入任何类型，但这不利于错误检查(程序不会在编译的时候检查到错误，而是在运行时出错，这就很不爽了)
比如我们需要一个int双向链表，这个时候我们就要写一个结构体大概是
type LinkListNode struct { Value int Next *LinkListNode Prev *LinkListNode } type LinkList struct { len int head *LinkListNode tail *LinkListNode }  如果我们还要写一个字符串的链表，这个时候将Value的类型改成string就行了，其它不用变，如果我们还要..balabala，可能就要定义上百个结构体了，到时候代码全是结构体
有些同学说，用接口不就可以了吗？用接口不就无法实现类型的判断了吗，万一程序哪个地方本应该收到int，却收了一个string，然后程序boom
关于网上很多网友使用interface来达到所谓的泛型，我是越看越像多态呀，并且还是达不到泛型所能提供的类型保护啊，虽然算法确实可以复用了(有些)
泛型的目的是减少代码的重复性，也就是增加重用性，还能够确定数据类型，比如Java中的一个例子
class Factory&amp;lt;T&amp;gt;{ private T value; public T getValue() { return value; } public void setValue(T v) { this.value = v; } }  T我可以是字符串，也可以是整数等，或者是自己定义的结构体。但是一旦定下来，创建了的变量类型就不能变了
所以我说了那么多。。怎么实现啊
实现 Go2草稿中有提到这个话题Go 2 Draft Designs
目前只是一个草稿，并且是由Gopher们共同推进的一个话题，所以说现在Go内置里面还未实现泛型
笔者也去看了一些关于泛型的讨论，到最后都还是建议不要在现阶段写泛型程序，因为Go有一个很本质的特点，就是简单写、简单读，如果通过一些自己的&amp;rdquo;创造&amp;rdquo;而造成别人阅读代码困难，那是得不偿失
所以真香，还是用回多态吧，有机会再详细阅读一下草稿
对此Go2还对错误处理进行了强烈的讨论，笔者也希望以后写Go不用一大堆错误处理了。。真的看到眼花
这里是Go2官方对这些修改的想法视频</description>
    </item>
    
    <item>
      <title>Effective Go</title>
      <link>https://wushaoqiang.github.io/posts/effective-go/</link>
      <pubDate>Thu, 25 Apr 2019 23:46:13 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/effective-go/</guid>
      <description>参考Effective Go中英双语版
 It&amp;rsquo;s also important to know the established conventions for programming in Go, such as naming, formatting, program construction, and so on, so that programs you write will be easy for other Go programmers to understand.
 Go的一个好处就是，大家的代码风格基本一致，看别人代码就不会显得很痛苦了(前提是开发者遵守)
所以我们今天来谈谈代码规范吧，这里只记录了我自己有时候会忽略的点，有一些规范我以及掌握并且时刻用在编写Golang程序上了，因此不记录，想看完整的请阅读上面的开源书本
格式化 Go的gofmt为我们做好了，所以安装这个程序，在保存的时候就可以自动帮你调整代码布局
注释 行注释更为常用，而块注释则主要用作包的注释
每个包都应包含一段包注释，即放置在包子句前的一个块注释。对于包含多个文件的包， 包注释只需出现在其中的任一文件中即可。包注释应在整体上对该包进行介绍，并提供包的相关信息。 它将出现在 godoc 页面中的最上面，并为紧随其后的内容建立详细的文档。
每个可导出（首字母大写）的名称都应该有文档注释。
命名 我记得有一个叫go-lint会检查这个
Go 中约定使用驼峰记法 MixedCaps 或 mixedCaps 而非下划线的方式来对多单词名称进行命名。
只包含一个方法的接口应当以该方法的名称加上 - er 后缀来命名，如 Reader
若你有个名为 owner （小写，未导出）的字段，其获取器应当名为 Owner（大写，可导出）而非 GetOwner。大写字母即为可导出的这种规定为区分方法和字段提供了便利。 若要提供设置器方法，SetOwner 是个不错的选择</description>
    </item>
    
    <item>
      <title>Interview2</title>
      <link>https://wushaoqiang.github.io/posts/interview2/</link>
      <pubDate>Thu, 25 Apr 2019 22:05:12 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/interview2/</guid>
      <description>最大连续子数组和  线程之间共享数据的方式  Go encourages the use of channels to pass references to data between goroutines
 这里应该用channel来达到通信
在Go里面，推荐使用数据交换来达到共享的效果，可能和别的编程语言有很大的不同
进程和线程的区别 进程：操作系统对一个正在运行的程序的一种抽象，一个系统上可以运行多个进程，这些进程在单核的处理器下一样可以显得好像的并发的一样，这是通过处理器在进程之间的切换实现的，这种交错执行的机制称为上下文切换
线程：一个进程可以由多个线程的执行单元组成，每个线程都运行在进程的上下文中
区别：
 进程在系统上运行，线程在进程上运行，因此进程是独立的地址空间、线程共享进程的地址空间
 线程比进程的开销要小
 线程一般来说比进程更高效
 线程之间的数据共享比进程的简单
 线程必须依赖在进程上执行
  临界区是啥 临界区从通俗层面来讲就是我们锁-解锁之间的代码，通常会写在程序(或者说资源)无法同时被使用的地方
这个区域只能允许一个线程或进程进入，其它后来的需要等待解锁
死锁是啥。死锁产生的条件是什么 在我理解里，线程A占用了资源C，这个时候线程A还要申请资源D(占用且申请)，但线程B这时占用着资源D，而且线程A无法将资源抢过来，所以现在线程A就在等待线程B释放资源D。线程B在这个时候也需要使用资源C，并且不得到就不离开(一直等待)，所以现在局面就是A在等B释放D，B在等A释放C(循环等待)，并且都不肯让资源(不可抢占)，并且资源CD都是只能有一个线程占有的(互斥)
若干进程竞争有限资源，但顺序或者决策不当，使得大家都在无限循环等待，就形成了死锁
 互斥条件
 不可抢占条件
 占有且申请条件(这个的意思是在占有资源的情况下还要去申请别的资源)
 循环等待条件
  只要上述条件有一个不满足，就可以避免死锁
给出很多串信息 包含ip url info 等信息 info包含error等状态码 用Linux命令统计出每个url对应的error概率 占时还不太清除这个
Linux命令 如何杀死占用指定端口的进程 这个可能可以分解为两个问题，如果从端口找到进程pid，如何杀死指定pid的进程
所以查找pid有lsof -i:port和netstat -p |grep port</description>
    </item>
    
    <item>
      <title>Golang Context</title>
      <link>https://wushaoqiang.github.io/posts/golang-context/</link>
      <pubDate>Wed, 24 Apr 2019 19:07:52 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/golang-context/</guid>
      <description>Context又名上下文，在一开始接触这个词的时候就有点迷惑了，开一篇文章把这个困扰了我有一阵子的迷惑解开吧
参考博客理解Go Context机制
Golang的执行单元是goroutine，main也是一个goroutine
上下文，上下则是存在上下层的传递，我们在编写Web后端的时候，接收到一个请求可能会执行一些列的goroutine(数据库，业务层处理)来达到并发效果
这个时候，如果客户端那边取消了呢？如果我们在服务器端检测不到这个信号，那么我们服务器还是会继续服务，直到完成所有服务的时候，发现客户端已经不见了(资源就被浪费了)
所以我们需要在每一个由Request产生的goroutine里面装一个监控，这个监控会告诉程序客户端是否还在等待返回，如果客户端离开，那么程序立即停止对客户端的服务
Context接口 type Context interface { Deadline() (deadline time.Time, ok bool) Done() &amp;lt;-chan struct{} Err() error Value(key interface{}) interface{} }   Deadline会返回一个超时时间，Goroutine获得了超时时间后，例如可以对某些io操作设定超时时间。
 Done方法返回一个信道（channel），当Context被撤销或过期时，该信道是关闭的，即它是一个表示Context是否已关闭的信号。
 当Done信道关闭后，Err方法表明Context被撤的原因。
 Value可以让Goroutine共享一些数据，当然获得数据是协程安全的。但使用这些数据的时候要注意同步，比如返回了一个map，而这个map的读写则要加锁。
  每当我们处理一个Request的时候，都应该从Request里拿一个Context
req,err := http.NewRequest(http.MethodGet,&amp;quot;http://127.0.0.1:8080&amp;quot;,nil) if err != nil { log.Fatalln(err) } ctx := req.Context()   the context is canceled when the client&amp;rsquo;s connection closes
 如果Request的context是nil，那么它会返回一个context.Background()
var ( background = new(emptyCtx) todo = new(emptyCtx) )  方法 我们前面说了，Context是要上下传递的，我们需要达到一种效果： 上面的Context收到了中断信号，下面的也要进行中断</description>
    </item>
    
    <item>
      <title>Interview</title>
      <link>https://wushaoqiang.github.io/posts/interview/</link>
      <pubDate>Wed, 24 Apr 2019 15:32:21 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/interview/</guid>
      <description>本文是笔者自己收集他人面经，顺便检查一下自己的知识状况，找目标进一步提升
go的调度 这里应该指的是goroutine的调度模式
读过Go Web编程那本书的人可能知道，go的并发是由线程、处理器、调度器和一个个的goroutine
简单说一下运行的一些规则
 每一个线程里面有一个的协程，从微观角度来看是顺序执行的，但是从宏观角度来看，因为执行速度快，线程里的协程不断切换，因此可以看作是并行
 处理器主要就是用来执行goroutine的，它也维护了一个goroutine的队列，里面有在等待的goroutine
 只有线程和处理器结合起来才能构造一个goroutine执行环境
 调度器，当协程阻塞的时候，会保存上下文，直到下次可以恢复运行
  这是一些比较浅显运行的规则，如果要深入goroutine的源码分析，推荐一篇文章
go struct能不能比较 如果是值类型，是可以比较的，比如
p1 := Person{Name: &amp;quot;SQ&amp;quot;, Age: 1} p2 := Person{Name: &amp;quot;SQ&amp;quot;, Age: 1} if p1 == p2 { fmt.Println(&amp;quot;same&amp;quot;) }  这样是有输出的
那如果是嵌套呢？也是一样的，只要是具有可比性的，如string,int这些类型，都能直接比较。如果结构体含有引用类型，因为是地址，所以肯定不一样，给个例子
type Person struct { Name string Age int } type Student struct { *Person ID int }  由于Student里面的Person是一个引用类型，所以比较是比较了地址，因此是不同的
go defer defer这个要注意的点有两个
 执行顺序，先进后出
 参数还是闭包
  参数传递会根据传递参数时的值进行执行</description>
    </item>
    
    <item>
      <title>Golang Pipeline</title>
      <link>https://wushaoqiang.github.io/posts/golang-pipeline/</link>
      <pubDate>Sun, 21 Apr 2019 10:59:13 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/golang-pipeline/</guid>
      <description>根据官网博客学习Pipeline
什么是Pipeline 管道其实就是一系列的Channel连接起来
 通过channel(可能不止一个)来接收数据
 处理数据
 用Channel向下传递数据(也可能不止一个)
  代码演示 package main import ( &amp;quot;fmt&amp;quot; &amp;quot;sync&amp;quot; ) func main() { // Set up a done channel that&#39;s shared by the whole pipeline, // and close that channel when this pipeline exits, as a signal // for all the goroutines we started to exit. done := make(chan struct{}) defer close(done) in := gen(done, 2, 3) // Distribute the sq work across two goroutines that both read from in.</description>
    </item>
    
    <item>
      <title>Golang make vs new</title>
      <link>https://wushaoqiang.github.io/posts/golang-makevsnew/</link>
      <pubDate>Sun, 21 Apr 2019 00:30:06 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/golang-makevsnew/</guid>
      <description>make和new的对象  make只能对slice、map、channel作用，比如不能make(int)
 new可以对任何类型作用
  make和new的返回值  make返回主体
 new也是返回指针，比如new(int)，返回一个int的指针，这个指针的内容是0
  初始化 两者都会初始化为“0”值
总结 所以我觉得它们最大的区别还是返回值的区别，以及作用对象</description>
    </item>
    
    <item>
      <title>Golang Map</title>
      <link>https://wushaoqiang.github.io/posts/golang-map/</link>
      <pubDate>Sat, 20 Apr 2019 20:03:42 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/golang-map/</guid>
      <description>Construct: m:=map[key]value{}
 Insert: m[k] = v
 Lookup: v = m[k]
 Delete: delete(m,k)
 lterate: for k,v := range m
 Size: len(m)
  Key不能为 maps,slices,funcs. 因为它们不可比较
Map底层 map header
len lg(#buckets) bucket array hash seed  流程  接收到一个key
 对key进行hash
 通过hash找到是哪一个bucket
 取hash前8bit作为extra(作为快速检查)
 找到bucket的内存(对不同的类型，大小会有不同)
  扩容  新创建一个两倍的空间
 复制entries到新的bucket，但是这里的复制是递增式的，因为如果一次性将很大的数据复制到一块内存，它会很耗费时间，但是这种方法就代表着，在扩容的时候，查找会变得慢了，因为要查找两块内存空间。这也决定了我们不能直接用指针指向map的某一个value，因为这个value可能扩容后就不在那了
 用新的bucket
  和其它Map比较  Go map不能用指针指向单个value
 迭代的时候，go map是可以修改的</description>
    </item>
    
    <item>
      <title>Golang Channel</title>
      <link>https://wushaoqiang.github.io/posts/golang-channel/</link>
      <pubDate>Sat, 20 Apr 2019 17:19:20 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/golang-channel/</guid>
      <description>这里就不再赘述重要性了
Channel特性  goroutine-safe
 两个goroutine之间传递数据
 FIFO
 cause goroutine to block and unblock
  What is the inside of channel  mutex
 send-index and recieve index
 buf
  Create a channel ch := make(chan int,3) //buffered chan ch := make(chan int) //sync chan  ch is a pointer
How it work Send  When it is going to send data to the channel, it will acquire the lock because it is going to modify.</description>
    </item>
    
    <item>
      <title>Golang Interface</title>
      <link>https://wushaoqiang.github.io/posts/golang-interface/</link>
      <pubDate>Sat, 20 Apr 2019 13:36:59 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/golang-interface/</guid>
      <description>在说接口之前，我们先说一下类型，类型在Go语言里面可以大致分为
 concrete type(具体类型,int,string&amp;hellip;)
 abstract type(抽象类型 io.Writer,io.Reader&amp;hellip;)
  具体类型我们知道它到底长什么样子，比如说int64，我们知道它在底层有8个字节
抽象类型我们不知道或者说我们不关注它长什么样，但我们知道它的用处，比如io.Writer是用来写的
具体化谈Interface 举个非常简单的例子，我们在读文件的时候，可能会这样做
func main() { f, err := os.Open(&amp;quot;abc.txt&amp;quot;) if err != nil { fmt.Println(err) } byte, _ := ioutil.ReadAll(f) fmt.Println(string(byte)) }  看一下ioutil.ReadAll()
func ReadAll(r io.Reader) ([]byte, error) { return readAll(r, bytes.MinRead) }  这里需要传入的是一个io.Reader接口，为什么*File类型传入一样可以呢
这里io.Reader是一个接口，接口里面只要一个函数
type Reader interface { Read(p []byte) (n int, err error) }  而*File里面也实现了这个接口的函数
func (f *File) Read(b []byte) (n int, err error) { if err := f.</description>
    </item>
    
    <item>
      <title>Golang Tips</title>
      <link>https://wushaoqiang.github.io/posts/golang-tips/</link>
      <pubDate>Thu, 18 Apr 2019 22:56:20 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/golang-tips/</guid>
      <description>关于select case runtime.GOMAXPROCS(1) int_chan := make(chan int, 1) string_chan := make(chan string, 1) int_chan &amp;lt;- 1 string_chan &amp;lt;- &amp;quot;hello&amp;quot; select { case value := &amp;lt;-string_chan: fmt.Println(value) case value := &amp;lt;-int_chan: panic(value) }  上面代码两个case都满足，会伪随机的执行一个
关于defer func DeferCalc() { a := 1 b := 2 defer calc(&amp;quot;1&amp;quot;, a, calc(&amp;quot;10&amp;quot;, a, b)) a = 0 defer calc(&amp;quot;2&amp;quot;, a, calc(&amp;quot;20&amp;quot;, a, b)) b = 1 time.Sleep(1 * time.Second) } func calc(index string, a, b int) int { ret := a + b fmt.</description>
    </item>
    
    <item>
      <title>Golang Gin</title>
      <link>https://wushaoqiang.github.io/posts/golang-gin/</link>
      <pubDate>Sun, 14 Apr 2019 23:12:41 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/golang-gin/</guid>
      <description> 中间件 在Gin的中间件可以这样定义，这是Gin定义的中间件的接口
func JWT() gin.HandlerFunc { return func(c *gin.Context){ //这个就和我们平时编写的路由函数一样了 } }  然后利用Use()函数注册进去
gin函数 //这三步和gin.Default()返回的Engine一样,之说gin.Default()会有一个输出消息 debugPrintWARNINGDefault() r := gin.New() r.Use(gin.Logger()) r.Use(gin.Recovery()) gin.SetMode(setting.RunMode)  分组 apiv1 := r.Group(&amp;quot;/api/v1&amp;quot;)  gin.HandlerFunc func GetTags(c *gin.Context){ }  Context方法 </description>
    </item>
    
    <item>
      <title>Golang Validation</title>
      <link>https://wushaoqiang.github.io/posts/golang-validation/</link>
      <pubDate>Sun, 14 Apr 2019 14:43:43 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/golang-validation/</guid>
      <description>Validation项目地址
创建 valid := validation.Validation{}  Validation方法 valid是创建过的对象
 valid.Required(name,&amp;quot;name&amp;quot;)：检验变量不能为空，字符串不能为&amp;quot;&amp;quot;,后面的&amp;quot;name&amp;quot;是用来标识而已
 valid.MaxSize(name,100,&amp;quot;name&amp;quot;)：最大长度
 valid.Range(state,0,1,&amp;quot;state&amp;quot;)：范围
 valid.HasErrors()：这个会返回布尔值，是否有不符合限定的内容
 valid.Errors：这个是一个Error数组，其中Error是这个包自带的，并不是标准库的error
 valid.Min(id,1,&amp;quot;id&amp;quot;)：id最小为1
  以上这些都返回*Result
Result方法 我们拿上面一个返回*Result对象做例子
 valid.Required(name,&amp;quot;name&amp;quot;).Message(&amp;quot;name不能为空&amp;quot;)  当加了Message后，发生错误返回*Error对象，Error.key就是name Error.Message就是上面的信息</description>
    </item>
    
    <item>
      <title>Golang Build blog with gin</title>
      <link>https://wushaoqiang.github.io/posts/golang-blog/</link>
      <pubDate>Sun, 14 Apr 2019 13:47:15 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/golang-blog/</guid>
      <description> Package  ini &amp;mdash;配置文件的读取
 com &amp;mdash;功能性
 validation &amp;mdash;做验证
 jwt-go &amp;mdash;Token
 endless &amp;mdash;服务器热启动
 swag &amp;mdash;API文档
  </description>
    </item>
    
    <item>
      <title>Golang标准库--os</title>
      <link>https://wushaoqiang.github.io/posts/golangstd-os/</link>
      <pubDate>Fri, 12 Apr 2019 20:24:48 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/golangstd-os/</guid>
      <description>Open与OpenFile的区别 笔者在某天遇到一个情况，用Open打开文件并且想写入发生了错误
bad file descriptor  检查过后发现Open在底层是调用了OpenFile，并且默认是只读的形式
// Open opens the named file for reading. If successful, methods on // the returned file can be used for reading; the associated file // descriptor has mode O_RDONLY. // If there is an error, it will be of type *PathError. func Open(name string) (*File, error) { return OpenFile(name, O_RDONLY, 0) }  所以要是想要自己定义打开的文件限制的话，就用OpenFile吧
// Flags to OpenFile wrapping those of the underlying system.</description>
    </item>
    
    <item>
      <title>Golang Path Problem</title>
      <link>https://wushaoqiang.github.io/posts/golang-path-problem/</link>
      <pubDate>Fri, 12 Apr 2019 17:28:21 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/golang-path-problem/</guid>
      <description>笔者在学习的路上遇到了一些关于路径的奇怪问题，想着这个问题都埋了这么久了，赶紧出来总结一下，以防下次再出现这类型错误
直接用相对路径 在os.Open()直接输入相对路径，这个相对路径决定于你的工作目录，如果工作目录发生改变，就不行了
filepath.Abs() filepath.Abs()是根据当前工作目录返回的绝对路径，这个和上面的不同在于，这个可以打开工作目录之前的文件，而上面的只能打开后面的文件
所谓前后是值文件夹的前后
所以写在程序里面，你在这个目录执行成功了，你退一个目录就不行了，因为这个时候工作路径改变了
笔者感觉这种方法不安全，或者我们写应用的时候指定要在某某目录执行，我有见过类似的项目
同一目录下，package都为main，不能调用 如果我们有两个文件，package都为main，比如是这样的
-main.go | -file.go  main.go想调用file.go的函数，会返回未定义的错误
有两种解决方法
 go install Or go build 转换为二进制文件执行
 go run *.go Or go run main.go file.go 这个表达意思一样的，把包含的文件都包含进去
  解决相对路径的最稳的方法 来自外国友人icza</description>
    </item>
    
    <item>
      <title>Golang Log</title>
      <link>https://wushaoqiang.github.io/posts/golang-log/</link>
      <pubDate>Fri, 12 Apr 2019 01:34:09 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/golang-log/</guid>
      <description>笔者上面总结了一下网上关于错误处理和异常处理的资料，发现不知道什么时候要记录一个信息，什么时候不应该，再去找找别人的经验，总结到这篇博客。当然，笔者对标准库的log的接口表示有点少，而且输出的信息看起来有点累(虽然很多人喜欢标准库的log，但这里不讨论这个)，我将尝试着用用第三方库
我们做后台开发，无论有什么语言，都有相应的一套日志记录系统，并且日志记录的信息可能是一些小小的问题，也可能是一些大问题，这个时候就要分级处理了，很多人(包括我之前)都对分级这个界限划分的认识模糊，不知道什么时候该用什么级别的信息
在很多时候，log给我们提供的级别种类非常多，例如info、warning、debug、error等等，其实我对这些有些难以区分
在一些论坛上，大家也为这些发表意见，都有各自的道理，我把我觉得有道理的记录下来，以后我就会按照这样的一套标准(并非所有人的标准)来实现我的日志记录
先讲标准，在来简单分析一下第三方库的使用
warning  Nobody needs a warning log level
 警告是什么意思？出错了吗，还是没出错，不知道，有点模棱两可的感觉
所以要么是正常的信息输出(INFO)，要么就是错误
其实笔者后来觉得，warning可以在下面情况使用
 对，是出错了，但是经过我们的错误处理，在合适的尝试次数中成功了，这样我们可以给出警告，告诉开发者，这里曾经出过错  fatal 首先，在Go里面，Fatal是会调用os.Exit(1)的
这代表着什么样的结果(灾难)呢
 在其它线程的defer没有得到调用(比如一个文件的关闭在defer里，这样这个文件就未关闭，程序就挂了)
 缓冲区没有刷新(flush)，我们都知道，缓冲区要刷新，数据才能真正流入到我们想它到达的地方
 临时文件或者文件夹不会被移除(程序可能会生成临时文件，这是我们在结果中不想要的东西)
   It is commonly accepted that libraries should not use panic, but if calling log.Fatal has the same effect, surely this should also be outlawed.
 网上看到别人这样说，称panic,fatal应该属于违规操作
stackoverflow上赞同较多的答案说
 You should assume that a panic will be immediately fatal, for the entire program, or at the very least for the current goroutine.</description>
    </item>
    
    <item>
      <title>Golang Errandpanic</title>
      <link>https://wushaoqiang.github.io/posts/golang-errandpanic/</link>
      <pubDate>Thu, 11 Apr 2019 21:28:42 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/golang-errandpanic/</guid>
      <description>笔者在自己做一个小项目的时候，从0开始写呀写呀写，忽然发现代码里充满了错误处理，异常处理，乱七八糟，心情非常不好，所以是时候学习一下这方面的知识了，于是在网上搜索别的博主的总结
本文参考了张伯雨的博客 飞雪无情的博客 外国友人的博客
直观理解 虽然我一开始也知道错误和异常是两码事，但我处理起来就把它们当成一码事了，这是不对的，我们先从直观上去判断什么是错误，什么是异常
错误是我们意料之中的，比如我们在做一个Get请求，我们知道这个操作是有可能发生错误的(比如超时等)，意料之中的事情
异常是我们意料之外的事情，比如空指针、数组越界等，程序在编译阶段是无法辨认出数组越界，或者空指针的
 but unable to check mistakes like an out-of-bounds array, access or nil pointer deference which require checks at run time
 defer 说到异常就要提一下defer，它是一个关键字，用于延迟函数的执行，我们常见的是
... defer file1.Close() defer file2.Close() ...  当一个函数触发panic，或者正常的return，总之它所在的函数执行完毕了，这个时候就轮到defer的函数了
并且它是按照一个栈的形式来执行，也就是先进后出，在上面的例子中，file2会比file1先执行Close()
如果是panic，那么这个panic将会一直被传递上去，直到最后一个defer执行完毕
同样的功能，不同的设计 比如说，许多标准库里的函数，会有两种设计
 一般设计，如果输入有误，则返回错误
 异常设计，如果输入有误，直接抛出异常
  怎么看都觉得第二种好恐怖啊，动不动就抛出异常
其实不然，我们在编写程序的时候，有些时候是硬编码的，也就是说这个部分是很大概率不会出错的，比如说我们在调用template标准库时，我们写好的网页(H5)，一般来说到上线的时候都是固定死了的,所以在读取模板的时候基本不会出错，这个时候就不用再写错误处理了
凡事要有规则 异常处理的作用域
 空指针引用
 下标越界
 除数为0
 不应该出现的分支，比如我们在switch的时候，没有一个符合，就会到default分支
 输入不应该引起函数错误
  错误处理正确姿势 1.失败原因只有一个时，不用error 比如只是一些简单的判断，这个时候输出bool会更好</description>
    </item>
    
    <item>
      <title>Golang Crawler</title>
      <link>https://wushaoqiang.github.io/posts/golang-crawler/</link>
      <pubDate>Thu, 11 Apr 2019 17:35:02 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/golang-crawler/</guid>
      <description>笔者最近用了几天时间用Golang写一个爬虫并且做数据分析，先记录一下用了哪些包，方便后面总结
goquery --处理HTML标签 viper --读取配置文件 go-echarts --图表显示 gorm --Mysql数据库 golang-proxy --代理IP pkg/errors --更好追踪错误 logrus --美化log lfhook --为了生成log本地文件，与logrus配合使用  过程中遇到的错误(不分顺序)
 first path segment in URL cannot contain colon 这里把IP地址当做协议了，但是程序一样能运行，只要在IP地址前面加上//即可，就像//127.0.0.1:1080
 invalid memory address or nil pointer dereference 在我把IP替换成代理后，出现了这个情况，初步估计是resp.Body搞的鬼，在后面我多尝试几次后，也成功过。我在这里的做法是将函数重新调用(递归)，设置好递归的最大次数，如果超过这个次数就终止，或者使用下面的错误处理
  defer func () { if resp != nil { resp.Body.Close() } }()  单元测试 func TestCrawler(t *testing.T) { // keywords := []string{&amp;quot;golang&amp;quot;, &amp;quot;java&amp;quot;} keywords := &amp;quot;golang,java&amp;quot; refresh := &amp;quot;on&amp;quot; value := url.</description>
    </item>
    
    <item>
      <title>Golang Handle</title>
      <link>https://wushaoqiang.github.io/posts/golang-handle/</link>
      <pubDate>Thu, 11 Apr 2019 11:14:34 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/golang-handle/</guid>
      <description>本文主要解释Golang中http-handler几个容易混淆的概念
HandleFunc 源代码
在源码文件(net/http/server.go)中定义了一个默认的路由管理器(Mux)，我们如果直接调用
http.HandleFunc(...)  其实就用了默认的路由管理器，然后通过这个默认的路由器来调用路由管理器的方法
当然我们也可以自己定义一个路由管理器，然后通过这个对象来调用这些方法,和调用默认Mux不同的是
myMux.HandleFunc(...)  来看一下源码的这两个函数，验证上面所说的。
// HandleFunc registers the handler function for the given pattern // in the DefaultServeMux. // The documentation for ServeMux explains how patterns are matched. func HandleFunc(pattern string, handler func(ResponseWriter, *Request)) { DefaultServeMux.HandleFunc(pattern, handler) }  利用DefaultServeMux来调用HandleFunc()方法
// HandleFunc registers the handler function for the given pattern. func (mux *ServeMux) HandleFunc(pattern string, handler func(ResponseWriter, *Request)) { if handler == nil { panic(&amp;quot;http: nil handler&amp;quot;) } mux.</description>
    </item>
    
    <item>
      <title>Golang goquery</title>
      <link>https://wushaoqiang.github.io/posts/golang-goquery/</link>
      <pubDate>Mon, 08 Apr 2019 23:10:14 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/golang-goquery/</guid>
      <description>goquery是一个开源的库，针对解析HTML
今天在做爬虫的时候用到了一些功能，记录下来方便查阅
创建Document对象 doc, err := goquery.NewDocumentFromReader(resp.Body) if err != nil { log.Fatalf(&amp;quot;go query Error %s\n&amp;quot;, err) }  doc对象就包含了我们要解析的HTML主体
一般我们这样用，Find()里面的字符串就是我们要填写的规则
doc.Find(&amp;quot;div&amp;quot;).Each(func(i int, s *goquery.Selection) { fmt.Println(i,s.Text()) })  规则 我们可以根据HTML的源码分析对应的属性id，class等等
 div#id #id是某个div的id属性，筛选出此id的div标签
 div.class .class 同理，是class属性
 div[class],div[lang] 这个也是属性的筛选
 div&amp;gt;p div嵌套的p标签，这里规定只有一级标签，一级以后的p标签不会被筛选出来
 div p div嵌套的p标签，这里无论第几级都会被筛选出来
  属性可以和嵌套一起使用，例如div.class&amp;gt;p&amp;gt;li
Size num := doc.Find(&amp;quot;ul&amp;gt;li&amp;gt;div.job-primary&amp;quot;).Size()  取出标签内的属性 doc.Find(&amp;quot;ul&amp;gt;li&amp;gt;div.job-primary&amp;gt;div&amp;gt;h3&amp;gt;a&amp;quot;).Each(func(i int, s *goquery.Selection) { detail := s.Get(0).Attr[0].Val // fmt.Println(i, nextPage) jobs[i].Detail = detail })  我在这里踩过一个坑</description>
    </item>
    
    <item>
      <title>Golangstd Request</title>
      <link>https://wushaoqiang.github.io/posts/golangstd-request/</link>
      <pubDate>Mon, 08 Apr 2019 11:37:38 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/golangstd-request/</guid>
      <description>最近笔者看了一些源代码，也找了一些Web示例跟着学习，这次是Go源代码的request.go的学习总结
我们知道，在处理Web后端的时候，都会有两个参数http.ResponseWriter和*http.Request
所以Request是我们处理用户请求的接口，学习这个对Web开发也相当重要
Request结构体 type Request struct { Method string URL *url.URL Proto string // &amp;quot;HTTP/1.0&amp;quot; ProtoMajor int // 1 ProtoMinor int // 0 Header Header Body io.ReadCloser GetBody func() (io.ReadCloser, error) ContentLength int64 TransferEncoding []string Close bool Host string Form url.Values PostForm url.Values MultipartForm *multipart.Form Trailer Header RemoteAddr string RequestURI string TLS *tls.ConnectionState Cancel &amp;lt;-chan struct{} Response *Response ctx context.Context }  下面详细介绍每个字段的意义
Method 这就是一个请求的方法(如GET、POST)
但是Go的HTTP客户端不支持发送方法为CONNECT的请求
URL  // URL specifies either the URI being requested (for server // requests) or the URL to access (for client requests).</description>
    </item>
    
    <item>
      <title>Golang Gorm</title>
      <link>https://wushaoqiang.github.io/posts/golang-gorm/</link>
      <pubDate>Fri, 05 Apr 2019 20:37:11 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/golang-gorm/</guid>
      <description>连接数据库 Mysql db, err := gorm.Open(&amp;quot;mysql&amp;quot;, &amp;quot;root:123456@tcp/test?charset=utf8&amp;amp;parseTime=True&amp;quot;) if err != nil { panic(&amp;quot;连接数据库失败&amp;quot;) } defer db.Close() db.SingularTable(true)  选定好数据库后一般会配上
db.SingularTable(true)  如果不调用这个函数，当在数据库加入某个表单的时候，名字会自动加一个s
比如db.CreateTable(&amp;amp;Product{})，在数据库表单里面会得到一个名字为products
所以一般都会加上这个函数
创建Table db.CreateTable(&amp;amp;Product{})  创建多个table
db.CreateTable(&amp;amp;Product{},&amp;amp;User{})  删除Table 关于删除，有两个
db.DropTableIfExist(interface{}) db.DropTable(interface{})  这里可以传入字符串，也可以传入一个结构体
接着上面的例子
db.DropTableIfExist(&amp;quot;product&amp;quot;) db.DropTableIfExist(&amp;amp;Product{})  删除Column 删除Column是要指定Table，所以不能这样
db.DropColumn(&amp;quot;created_at&amp;quot;)  要定位Table，则需要
db.Model(&amp;amp;Product).DropColumn(&amp;quot;created_at&amp;quot;)  创建数据 db.Create(&amp;amp;Product{Code: &amp;quot;L1213&amp;quot;, Price: 1002})  查询数据 // 最后一个符合条件，默认id最后的那个 // Get last record, order by primary key db.Last(&amp;amp;user) //// SELECT * FROM users ORDER BY id DESC LIMIT 1; // 将所有符合条件的返回，这里要传一个结构体数组 // Get all records db.</description>
    </item>
    
    <item>
      <title>Golang Viper</title>
      <link>https://wushaoqiang.github.io/posts/golang-viper/</link>
      <pubDate>Fri, 05 Apr 2019 17:41:18 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/golang-viper/</guid>
      <description>Github
 Viper is a complete configuration solution for Go applications
 这是一个帮组我们读取配置文件的包，总结一些方法，方便以后使用
Reading Config Files  a single Viper instance only supports a single configuration file
 一个Viper对象只能对应一个配置文件，是一个一一对应的映射关系
但是我们在搜索配置文件的时候，可以设置多个路径，如果没有设置路径，则当前程序的目录上寻找，所以我们要设置好路径
这是Github上的一个例子
viper.SetConfigName(&amp;quot;config&amp;quot;) // name of config file (without extension) viper.AddConfigPath(&amp;quot;/etc/appname/&amp;quot;) // path to look for the config file in viper.AddConfigPath(&amp;quot;$HOME/.appname&amp;quot;) // call multiple times to add many search paths viper.AddConfigPath(&amp;quot;.&amp;quot;) // optionally look for config in the working directory err := viper.</description>
    </item>
    
    <item>
      <title>Golang Mega</title>
      <link>https://wushaoqiang.github.io/posts/golang-mega/</link>
      <pubDate>Mon, 01 Apr 2019 15:12:46 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/golang-mega/</guid>
      <description>不积跬步无以至千里，不积小流无以成江海
 本文是博主在学习基础记录的笔记
2019-04-01到2019-04-04，后面会自己DIY一些内容上去(想做成一个小小的技术论坛)
先来总体看一下整个项目的目录吧
. ├── cmd │ └── db_init │ └── main.go ├── config │ └── g.go ├── config.yml ├── controller │ ├── g.go │ ├── home.go │ ├── middle.go │ └── utils.go ├── main.go ├── model │ ├── g.go │ ├── post.go │ ├── user.go │ └── utils.go ├── templates │ ├── 404.html │ ├── _base.html │ ├── content │ │ ├── explore.html │ │ ├── index.</description>
    </item>
    
    <item>
      <title>Golang标准库--http</title>
      <link>https://wushaoqiang.github.io/posts/golangstd-net-http/</link>
      <pubDate>Tue, 19 Mar 2019 20:52:05 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/golangstd-net-http/</guid>
      <description>这篇文章是为了探索Golang中net/http包的实现，笔者暂时只会把主要脉络摸清，具体某些实现逻辑暂不考究，是一篇比较基础的源码阅读文章。
Package http doc.go 先来看看官方对这个包的一个解释
这里说到，这个包是为HTTP提供客户端和服务器端的实现的。
这里还举了一些方法的例子
// Copyright 2011 The Go Authors. All rights reserved. // Use of this source code is governed by a BSD-style // license that can be found in the LICENSE file. /* Package http provides HTTP client and server implementations. Get, Head, Post, and PostForm make HTTP (or HTTPS) requests: resp, err := http.Get(&amp;quot;http://example.com/&amp;quot;) ... resp, err := http.Post(&amp;quot;http://example.com/upload&amp;quot;, &amp;quot;image/jpeg&amp;quot;, &amp;amp;buf) ... resp, err := http.</description>
    </item>
    
    <item>
      <title>Golang Exercism</title>
      <link>https://wushaoqiang.github.io/posts/golang-exercism/</link>
      <pubDate>Sun, 17 Mar 2019 02:15:05 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/golang-exercism/</guid>
      <description>Exercism &amp;ndash; Bob 我的方法：(总之非常愚蠢就是了)
func Hey(remark string) string { // Write some code here to pass the test suite. // Then remove all the stock comments. // They&#39;re here to help you get started but they only clutter a finished solution. // If you leave them in, reviewers may protest! if strings.EqualFold(remark, &amp;quot;&amp;quot;) { return &amp;quot;Fine. Be that way!&amp;quot; } whitespace := true for _, item := range []byte(remark) { if !</description>
    </item>
    
    <item>
      <title>Go圣经读书笔记</title>
      <link>https://wushaoqiang.github.io/posts/golang-bible/</link>
      <pubDate>Sun, 17 Mar 2019 02:13:08 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/golang-bible/</guid>
      <description>第一章 入门 命令行参数 os.Args变量是一个字符串的切片，并且它的第一个元素是命令本身的名字
func main() { var s, sep string for i := 0; i &amp;lt; len(os.Args); i++ { s += sep + os.Args[i] sep = &amp;quot; &amp;quot; } fmt.Println(s) }  运行go run main.go 123
输出/tmp/go-build115927302/b001/exe/main 123
查找重复的行  input := bufio.NewScanner(os.stdin) ~ func NewScanner(r io.Reader) *Scanner  返回一个从r读取的Scanner
 func (s *Scanner) Scan() bool  逐行扫描，当scan停止的时候，或者是到了读取的终点，又或者是发生了错误，这里都会返回false
 func (s *Scanner) Text() string  返回scanner所在行的文本
counts := make(map[string]int) input := bufio.</description>
    </item>
    
    <item>
      <title>Go语言实战</title>
      <link>https://wushaoqiang.github.io/posts/golang-inaction/</link>
      <pubDate>Sun, 17 Mar 2019 02:11:56 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/golang-inaction/</guid>
      <description>Go语言优点：
 Go语言可以说是夹在C/C++和Python这两类语言之间，即提供了较高的性能，又使得开发更加迅速了。
 Go语言内置并发机制，对并发有着更好的性能
 Go语言自带垃圾回收器
 goroutine使用的内存比线程要少，所以常常能够成千上万个goroutine并发
  第六章 并发 概念  进程：当运行一个应用程序时，操作系统会为这个应用程序启动一个进程，可以将这个进程看作一个包含了应用程序在运行中需要用到和维护的各种资源 线程：一个线程是一个空间，这个空间会被操作系统调度来运行函数中所写的代码，线程会被调度到CPU上运行。 每个逻辑处理器绑定在一个线程上 逻辑处理器可以调度goroutine 并发：某一个事情的停止，另一个事情就开始(单线程) 并行：同时开始做(多线程)  goroutine 一个创建goroutine的示例 package main import ( &amp;quot;fmt&amp;quot; &amp;quot;runtime&amp;quot; &amp;quot;sync&amp;quot; ) // main is the entry point for all Go programs. func main() { // Allocate 1 logical processor for the scheduler to use. runtime.GOMAXPROCS(1) // wg is used to wait for the program to finish. // Add a count of two, one for each goroutine.</description>
    </item>
    
    <item>
      <title>Go语言高级编程</title>
      <link>https://wushaoqiang.github.io/posts/golang-highlevel/</link>
      <pubDate>Sun, 17 Mar 2019 02:09:45 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/golang-highlevel/</guid>
      <description>感谢 在文章开头感谢两位作者:柴树杉和曹春晖
这篇文章是开源的，欢迎大家去阅读
本篇博客是笔者对这篇文章的理解，引用的图片也是来自原文，如有侵权请告知！
第一章 基础 1.3 数组、字符串和切片  Go语言的数组是一种值类型，虽然数组的元素可以被修改，但是数组本身的赋值和函数传参都是以整体复制的方式处理的
 Go语言字符串底层数据也是对应的字节数组，但是字符串的只读属性禁止了在程序中对底层字节数组的元素的修改字符串赋值只是复制了数据地址和对应的长度，而不会导致底层数据的复制
 切片头含有底层数据的指针，所以它的赋值也不会导致底层数据的复制
  字符串  字符串的元素不可修改，是一个只读的字节数组
 字符串虽然不是切片，但是支持切片操作
type StringHeader struct { Data uintptr Len int }  字符串结构由两个信息组成：第一个是字符串指向的底层字节数组，第二个是字符串的字节的长度。
  切片 type SliceHeader struct { Data uintptr Len int Cap int }  a = append(a, 0) // 切片扩展1个空间 copy(a[i+1:], a[i:]) // a[i:]向后移动1个位置 a[i] = x // 设置新添加的元素  copy将a[i:]直接搬到了a[i+1:]这个时候就可以在a[i]插入
这种做法可以减少中间创建的临时切片
copy append可以完成切片的添加 删除 插入操作</description>
    </item>
    
    <item>
      <title>Golang--Leetcode</title>
      <link>https://wushaoqiang.github.io/posts/golang-leetcode/</link>
      <pubDate>Sun, 17 Mar 2019 02:07:37 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/golang-leetcode/</guid>
      <description>此文章为做题时发现的不足
 Go语言中的结构体直接赋值是==值传递==，如果要用引用传递，需要这样struct1 := &amp;amp;struct2，也就是要使用取地址符号。但是如果本来struct2就是一个指针，那么就可以直接赋值了。 go func addTwoNumbers(l1 *ListNode, l2 *ListNode) *ListNode { Head := ListNode{} curr := &amp;amp;Head  &amp;mdash;-  给定一个字符串，找出其中不含有重复字符的最长子串的长度方法 - 穷举法：
func lengthOfLongestSubstring(s string) int { var max = 0 for i := 0; i &amp;lt; len(s); i++ { m := make(map[string]bool) for j := i; j &amp;lt; len(s); j++ { if _, ok := m[s[j:j+1]]; !ok { m[s[j:j+1]] = true if j == len(s)-1 { if max &amp;lt; j-i+1 { max = j - i + 1 } } } else { if max &amp;lt; j-i { max = j - i } break } } } return max }   另一个方法： ```go func lengthOfLongestSubstring(s string) int { var max = 0 i := 0 m := make(map[string]int) for j := 0; j &amp;lt; len(s); j++ {  	if _, ok := m[s[j:j+1]]; ok {</description>
    </item>
    
    <item>
      <title>Golang标准库--Unicode</title>
      <link>https://wushaoqiang.github.io/posts/golangstd-unicode/</link>
      <pubDate>Sun, 17 Mar 2019 02:06:01 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/golangstd-unicode/</guid>
      <description>unicode package utf8 utf8.go 这里就不详细分析源码了，只说函数的作用
&amp;mdash; FullRune(p []byte) bool  FullRune报告p中的字节是否以一个rune的完整UTF-8编码开始。
 无效的编码被认为是完整的rune，因为它将转换为宽度为1的错误符文rune。
&amp;mdash; FullRuneInString(s string) bool 和FullRune一样，只是传入了字符串
&amp;mdash; DecodeRune(p []byte) (r rune, size int) 这个函数将切片p中第一个rune返回，并且返回这个rune的大小。
如果p是空的，那么会返回RuneError,0
如果切片中的编码是无效的，那么会返回RuneError,1,对应上一个函数，当编码无效时依然返回true
&amp;mdash; DecodeRuneInString(s string) (r rune, size int) 同上，只是参数变成了字符串
&amp;mdash; func DecodeLastRune(p []byte) (r rune, size int) 只是从后面开始了，功能一样。
&amp;mdash; DecodeLastRuneInString(s string) (r rune, size int) 如上，参数换了字符串
&amp;mdash; RuneLen(r rune) int 返回一个rune的长度，也就是其大小
&amp;mdash; EncodeRune(p []byte, r rune) int 这个就是将rune写入到byte切片上
&amp;mdash; RuneCount(p []byte) int 返回整个切片里面rune的个数</description>
    </item>
    
    <item>
      <title>Golang标准库--String</title>
      <link>https://wushaoqiang.github.io/posts/golangstd-string/</link>
      <pubDate>Sun, 17 Mar 2019 02:04:07 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/golangstd-string/</guid>
      <description>目录 strings builder.go Builder 结构体 noescape(p unsafe.Pointer) unsafe.Pointer &amp;amp; copyCheck() (b *Builder) String() string &amp;amp; (b *Builder) Len() int &amp;amp; (b *Builder) Reset() (b *Builder) Grow(n int) 关于Write的方法 reader.go Reader 结构体 (r *Reader) Len() int &amp;amp; (r *Reader) Size() int64 关于读的方法 (r *Reader) UnreadRune() error (r *Reader) Seek(offset int64, whence int) (int64, error) strings.go  strings builder.go Builder 相当于bytes里面的buffer，并且方法也差不多。但是buffer更加全面
&amp;mdash; 结构体 // A Builder is used to efficiently build a string using Write methods.</description>
    </item>
    
    <item>
      <title>Golang标准库--Bytes</title>
      <link>https://wushaoqiang.github.io/posts/golangstd-bytes/</link>
      <pubDate>Sun, 17 Mar 2019 02:03:03 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/golangstd-bytes/</guid>
      <description>目录 bytes buffer.go Buffer 结构体 const of readOp (b *Buffer) Bytes() []byte (b *Buffer) String() string (b *Buffer) empty() bool (b *Buffer) Len() int (b *Buffer) Cap() int (b *Buffer) Truncate(n int) (b *Buffer) Reset() (b *Buffer) tryGrowByReslice(n int) (int, bool) (b *Buffer) grow(n int) int (b *Buffer) Grow(n int) (b *Buffer) Write(p []byte) (n int, err error) (b *Buffer) WriteString(s string) (n int, err error) makeSlice(n int) []byte (b *Buffer) WriteTo(w io.</description>
    </item>
    
    <item>
      <title>Golang标准库--Bufio</title>
      <link>https://wushaoqiang.github.io/posts/golangstd-bufio/</link>
      <pubDate>Sun, 17 Mar 2019 01:59:52 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/golangstd-bufio/</guid>
      <description>目录 bufio bufio.go 常量 Reader 结构体 常量 NewReaderSize(rd io.Reader, size int) *Reader NewReader(rd io.Reader) *Reader (r *Reader) Size() int (b *Reader) Reset(r io.Reader) &amp;amp; (b *Reader) reset(buf []byte, r io.Reader) (b *Reader) fill() (b *Reader) Peek(n int) ([]byte, error) (b *Reader) Discard(n int) (discarded int, err error) (b *Reader) Read(p []byte) (n int, err error) (b *Reader) ReadByte() (byte, error) (b *Reader) UnreadByte() (b *Reader) ReadRune() (r rune, size int, err error) (b *Reader) UnreadRune() error (b *Reader) Buffered() int (b *Reader) ReadSlice(delim byte) (line []byte, err error) (b *Reader) ReadLine() (line []byte, isPrefix bool, err error) (b *Reader) ReadBytes(delim byte) ([]byte, error) (b *Reader) ReadString(delim byte) (string, error) (b *Reader) WriteTo(w io.</description>
    </item>
    
    <item>
      <title>Web框架</title>
      <link>https://wushaoqiang.github.io/posts/web-strcuture/</link>
      <pubDate>Sun, 17 Mar 2019 01:53:57 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/web-strcuture/</guid>
      <description>这篇文章是参考人世间博主写的一篇文章，这里哪里作为自己了解Gin框架的例子，笔者想在这做初步了解后再去深入了解源码，到时候再写一篇博客来说说Gin源码。
Gin 路由常用方法 func (group *RouterGroup) POST(relativePath string, handlers ...HandlerFunc) IRoutes func (group *RouterGroup) GET(relativePath string, handlers ...HandlerFunc) IRoutes type HandlerFunc func(*Context)  可以看出路由需要的参数是
 相对路径
 处理函数
  这里面是Gin自己定义的一个HandlerFunc，和标准库里面的有所不同，这里的gin.*Context包含了标准库里的ResponseWriter和*http.Request还有一些其它
介绍一些函数 // Query()	是匹配url上的参数，匹配不到就返回空字符串 // DefaultQuery() 也是匹配，如果匹配不到就用默认值 // 127.0.0.1:8000/post?id=111&amp;amp;page=222 // 如果用curl，则需要在&amp;amp;前面加\ id := c.Query(&amp;quot;id&amp;quot;) page := c.DefaultQuery(&amp;quot;page&amp;quot;, &amp;quot;0&amp;quot;) //这个是在表单上获取信息，通过POST方法发送过来的数据 name := c.PostForm(&amp;quot;name&amp;quot;) message := c.PostForm(&amp;quot;message&amp;quot;)  一个完整的路由 router.GET(&amp;quot;/welcome&amp;quot;, func(c *gin.Context) { firstname := c.DefaultQuery(&amp;quot;firstname&amp;quot;, &amp;quot;Guest&amp;quot;) lastname := c.Query(&amp;quot;lastname&amp;quot;) c.</description>
    </item>
    
    <item>
      <title>Go琐碎笔记</title>
      <link>https://wushaoqiang.github.io/posts/learningGo/</link>
      <pubDate>Thu, 14 Mar 2019 16:10:59 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/learningGo/</guid>
      <description>在test文件要是以_test.go结尾，或者是在文件开头加上// +build (tag) 其中tag是自己定的，然后测试的时候在Terminal输入
2019.2.16 go test -tags tagname
构造数组可以先 make([]int,0)
然后 再使用函数：func append(slice []Type, elems ...Type) []Type
unicode.IsLetter(r rune) bool是判断是否为字母，而不是ASCII
res, ok := map[...] 中的ok变量可以用来判断key是否存在
[]rune可以直接转换为字符串string([]rune)
2019.2.17 谨记！ ： 切片和Map在函数传递都是指针传递(引用)
func normalize(cleartext string) string { var b strings.Builder for _, r := range cleartext { if unicode.IsLetter(r) || unicode.IsDigit(r) { b.WriteRune(unicode.ToLower(r)) } } return b.String() }  b.WriteRune(unicode.ToLower(r)) :可以用这种方式代替append()
norm = fmt.Sprintf(&amp;quot;%-[1]*s&amp;quot;, c*r, norm): 其实就是将出c*r代入到[1]*形成的在右侧填充空格
|类型 |默认值 | |int | 0 | |string|“” | | bool | false |  定义一个常量：const name type = value value是必须要有的 枚举：Go没有枚举，用const构造，有两种方法(参考这里的)</description>
    </item>
    
  </channel>
</rss>