<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Golang on Gavin&#39;s Blog</title>
    <link>https://wushaoqiang.github.io/categories/Golang/</link>
    <description>Recent content in Golang on Gavin&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Fri, 12 Apr 2019 01:34:09 +0800</lastBuildDate>
    
	<atom:link href="https://wushaoqiang.github.io/categories/Golang/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Golang Log</title>
      <link>https://wushaoqiang.github.io/posts/golang-log/</link>
      <pubDate>Fri, 12 Apr 2019 01:34:09 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/golang-log/</guid>
      <description>笔者对标准库的log的接口表示有点少，而且输出的信息看起来有点累(虽然很多人喜欢标准库的log，但这里不讨论这个)，我将尝试着用用第三方库</description>
    </item>
    
    <item>
      <title>Golang Errandpanic</title>
      <link>https://wushaoqiang.github.io/posts/golang-errandpanic/</link>
      <pubDate>Thu, 11 Apr 2019 21:28:42 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/golang-errandpanic/</guid>
      <description>笔者在自己做一个小项目的时候，从0开始写呀写呀写，忽然发现代码里充满了错误处理，异常处理，乱七八糟，心情非常不好，所以是时候学习一下这方面的知识了，于是在网上搜索别的博主的总结
本文参考了张伯雨的博客 飞雪无情的博客 外国友人的博客
直观理解 虽然我一开始也知道错误和异常是两码事，但我处理起来就把它们当成一码事了，这是不对的，我们先从直观上去判断什么是错误，什么是异常
错误是我们意料之中的，比如我们在做一个Get请求，我们知道这个操作是有可能发生错误的(比如超时等)，意料之中的事情
异常是我们意料之外的事情，比如空指针、数组越界等
defer 说到异常就要提一下defer，它是一个关键字，用于延迟函数的执行，我们常见的是
... defer file1.Close() defer file2.Close() ...  当一个函数触发panic，或者正常的return，总之它所在的函数执行完毕了，这个时候就轮到defer的函数了
并且它是按照一个栈的形式来执行，也就是先进后出，在上面的例子中，file2会比file1先执行Close()
如果是panic，那么这个panic将会一直被传递上去，直到最后一个defer执行完毕
同样的功能，不同的设计 比如说，许多标准库里的函数，会有两种设计
 一般设计，如果输入有误，则返回错误
 异常设计，如果输入有误，直接抛出异常
  怎么看都觉得第二种好恐怖啊，动不动就抛出异常
其实不然，我们在编写程序的时候，有些时候是硬编码的，也就是说这个部分是很大概率不会出错的，比如说我们在调用template标准库时，我们写好的网页(H5)，一般来说到上线的时候都是固定死了的,所以在读取模板的时候基本不会出错，这个时候就不用再写错误处理了
凡事要有规则 异常处理的作用域
 空指针引用
 下标越界
 除数为0
 不应该出现的分支，比如我们在switch的时候，没有一个符合，就会到default分支
 输入不应该引起函数错误
  错误处理正确姿势 1.失败原因只有一个时，不用error 比如只是一些简单的判断，这个时候输出bool会更好
2.没有错误，不用error 有些时候error成为了一些人的追求了，弄不弄都要返回一个error类型
3.error应该在返回值的最后 无论返回多少个返回值，error都在最后
4.错误值应该统一，不要任性 我们在本应该是同类型的错误里，不要定义不同的错误
应该在包中增加一些常见的错误类型
5.错误逐层传递时，层层都加日志 这是为了好定位错误
6.错误处理使用defer 对于闭包的参数是值传递，对于外部变量却是引用传递，所以闭包中的外部变量err的值会是最新发生error的值
参考代码别人写的代码
func deferDemo() error { err := createResource1() if err != nil { return ERR_CREATE_RESOURCE1_FAILED } defer func() { if err !</description>
    </item>
    
    <item>
      <title>Golang Crawler</title>
      <link>https://wushaoqiang.github.io/posts/golang-crawler/</link>
      <pubDate>Thu, 11 Apr 2019 17:35:02 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/golang-crawler/</guid>
      <description>笔者最近用了几天时间用Golang写一个爬虫并且做数据分析，先记录一下用了哪些包，方便后面总结
goquery --处理HTML标签 viper --读取配置文件 go-echarts --图表显示 gorm --Mysql数据库 golang-proxy --代理IP  过程中遇到的错误(不分顺序)
 first path segment in URL cannot contain colon 这里把IP地址当做协议了，但是程序一样能运行，只要在IP地址前面加上//即可，就像//127.0.0.1:1080
 invalid memory address or nil pointer dereference 在我把IP替换成代理后，出现了这个情况，初步估计是resp.Body搞的鬼，在后面我多尝试几次后，也成功过。我在这里的做法是将函数重新调用(递归)，设置好递归的最大次数，如果超过这个次数就终止，或者使用下面的错误处理
  defer func () { if resp != nil { resp.Body.Close() } }()  </description>
    </item>
    
    <item>
      <title>Golang Handle</title>
      <link>https://wushaoqiang.github.io/posts/golang-handle/</link>
      <pubDate>Thu, 11 Apr 2019 11:14:34 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/golang-handle/</guid>
      <description>本文主要解释Golang中http-handler几个容易混淆的概念
HandleFunc 源代码
在源码文件(net/http/server.go)中定义了一个默认的路由管理器(Mux)，我们如果直接调用
http.HandleFunc(...)  其实就用了默认的路由管理器，然后通过这个默认的路由器来调用路由管理器的方法
当然我们也可以自己定义一个路由管理器，然后通过这个对象来调用这些方法,和调用默认Mux不同的是
myMux.HandleFunc(...)  来看一下源码的这两个函数，验证上面所说的。
// HandleFunc registers the handler function for the given pattern // in the DefaultServeMux. // The documentation for ServeMux explains how patterns are matched. func HandleFunc(pattern string, handler func(ResponseWriter, *Request)) { DefaultServeMux.HandleFunc(pattern, handler) }  利用DefaultServeMux来调用HandleFunc()方法
// HandleFunc registers the handler function for the given pattern. func (mux *ServeMux) HandleFunc(pattern string, handler func(ResponseWriter, *Request)) { if handler == nil { panic(&amp;quot;http: nil handler&amp;quot;) } mux.</description>
    </item>
    
    <item>
      <title>Golang goquery</title>
      <link>https://wushaoqiang.github.io/posts/golang-goquery/</link>
      <pubDate>Mon, 08 Apr 2019 23:10:14 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/golang-goquery/</guid>
      <description>goquery是一个开源的库，针对解析HTML
今天在做爬虫的时候用到了一些功能，记录下来方便查阅
创建Document对象 doc, err := goquery.NewDocumentFromReader(resp.Body) if err != nil { log.Fatalf(&amp;quot;go query Error %s\n&amp;quot;, err) }  doc对象就包含了我们要解析的HTML主体
一般我们这样用，Find()里面的字符串就是我们要填写的规则
doc.Find(&amp;quot;div&amp;quot;).Each(func(i int, s *goquery.Selection) { fmt.Println(i,s.Text()) })  规则 我们可以根据HTML的源码分析对应的属性id，class等等
 div#id #id是某个div的id属性，筛选出此id的div标签
 div.class .class 同理，是class属性
 div[class],div[lang] 这个也是属性的筛选
 div&amp;gt;p div嵌套的p标签，这里规定只有一级标签，一级以后的p标签不会被筛选出来
 div p div嵌套的p标签，这里无论第几级都会被筛选出来
  属性可以和嵌套一起使用，例如div.class&amp;gt;p&amp;gt;li
Size num := doc.Find(&amp;quot;ul&amp;gt;li&amp;gt;div.job-primary&amp;quot;).Size()  取出标签内的属性 doc.Find(&amp;quot;ul&amp;gt;li&amp;gt;div.job-primary&amp;gt;div&amp;gt;h3&amp;gt;a&amp;quot;).Each(func(i int, s *goquery.Selection) { detail := s.Get(0).Attr[0].Val // fmt.Println(i, nextPage) jobs[i].Detail = detail })  我在这里踩过一个坑</description>
    </item>
    
    <item>
      <title>Golangstd Request</title>
      <link>https://wushaoqiang.github.io/posts/golangstd-request/</link>
      <pubDate>Mon, 08 Apr 2019 11:37:38 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/golangstd-request/</guid>
      <description>最近笔者看了一些源代码，也找了一些Web示例跟着学习，这次是Go源代码的request.go的学习总结
我们知道，在处理Web后端的时候，都会有两个参数http.ResponseWriter和*http.Request
所以Request是我们处理用户请求的接口，学习这个对Web开发也相当重要
Request结构体 type Request struct { Method string URL *url.URL Proto string // &amp;quot;HTTP/1.0&amp;quot; ProtoMajor int // 1 ProtoMinor int // 0 Header Header Body io.ReadCloser GetBody func() (io.ReadCloser, error) ContentLength int64 TransferEncoding []string Close bool Host string Form url.Values PostForm url.Values MultipartForm *multipart.Form Trailer Header RemoteAddr string RequestURI string TLS *tls.ConnectionState Cancel &amp;lt;-chan struct{} Response *Response ctx context.Context }  下面详细介绍每个字段的意义
Method 这就是一个请求的方法(如GET、POST)
但是Go的HTTP客户端不支持发送方法为CONNECT的请求
URL  // URL specifies either the URI being requested (for server // requests) or the URL to access (for client requests).</description>
    </item>
    
    <item>
      <title>Golang Gorm</title>
      <link>https://wushaoqiang.github.io/posts/golang-gorm/</link>
      <pubDate>Fri, 05 Apr 2019 20:37:11 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/golang-gorm/</guid>
      <description>连接数据库 Mysql db, err := gorm.Open(&amp;quot;mysql&amp;quot;, &amp;quot;root:123456@tcp/test?charset=utf8&amp;amp;parseTime=True&amp;quot;) if err != nil { panic(&amp;quot;连接数据库失败&amp;quot;) } defer db.Close() db.SingularTable(true)  选定好数据库后一般会配上
db.SingularTable(true)  如果不调用这个函数，当在数据库加入某个表单的时候，名字会自动加一个s
比如db.CreateTable(&amp;amp;Product{})，在数据库表单里面会得到一个名字为products
所以一般都会加上这个函数
创建Table db.CreateTable(&amp;amp;Product{})  创建多个table
db.CreateTable(&amp;amp;Product{},&amp;amp;User{})  删除Table 关于删除，有两个
db.DropTableIfExist(interface{}) db.DropTable(interface{})  这里可以传入字符串，也可以传入一个结构体
接着上面的例子
db.DropTableIfExist(&amp;quot;product&amp;quot;) db.DropTableIfExist(&amp;amp;Product{})  删除Column 删除Column是要指定Table，所以不能这样
db.DropColumn(&amp;quot;created_at&amp;quot;)  要定位Table，则需要
db.Model(&amp;amp;Product).DropColumn(&amp;quot;created_at&amp;quot;)  创建数据 db.Create(&amp;amp;Product{Code: &amp;quot;L1213&amp;quot;, Price: 1002})  查询数据 // 最后一个符合条件，默认id最后的那个 // Get last record, order by primary key db.Last(&amp;amp;user) //// SELECT * FROM users ORDER BY id DESC LIMIT 1; // 将所有符合条件的返回，这里要传一个结构体数组 // Get all records db.</description>
    </item>
    
    <item>
      <title>Golang Viper</title>
      <link>https://wushaoqiang.github.io/posts/golang-viper/</link>
      <pubDate>Fri, 05 Apr 2019 17:41:18 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/golang-viper/</guid>
      <description>Github
 Viper is a complete configuration solution for Go applications
 这是一个帮组我们读取配置文件的包，总结一些方法，方便以后使用
Reading Config Files  a single Viper instance only supports a single configuration file
 一个Viper对象只能对应一个配置文件，是一个一一对应的映射关系
但是我们在搜索配置文件的时候，可以设置多个路径，如果没有设置路径，则当前程序的目录上寻找，所以我们要设置好路径
这是Github上的一个例子
viper.SetConfigName(&amp;quot;config&amp;quot;) // name of config file (without extension) viper.AddConfigPath(&amp;quot;/etc/appname/&amp;quot;) // path to look for the config file in viper.AddConfigPath(&amp;quot;$HOME/.appname&amp;quot;) // call multiple times to add many search paths viper.AddConfigPath(&amp;quot;.&amp;quot;) // optionally look for config in the working directory err := viper.</description>
    </item>
    
    <item>
      <title>Golang Mega</title>
      <link>https://wushaoqiang.github.io/posts/golang-mega/</link>
      <pubDate>Mon, 01 Apr 2019 15:12:46 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/golang-mega/</guid>
      <description>不积跬步无以至千里，不积小流无以成江海
 本文是博主在学习基础记录的笔记
2019-04-01到2019-04-04，后面会自己DIY一些内容上去(想做成一个小小的技术论坛)
先来总体看一下整个项目的目录吧
. ├── cmd │ └── db_init │ └── main.go ├── config │ └── g.go ├── config.yml ├── controller │ ├── g.go │ ├── home.go │ ├── middle.go │ └── utils.go ├── main.go ├── model │ ├── g.go │ ├── post.go │ ├── user.go │ └── utils.go ├── templates │ ├── 404.html │ ├── _base.html │ ├── content │ │ ├── explore.html │ │ ├── index.</description>
    </item>
    
    <item>
      <title>Golang标准库--http</title>
      <link>https://wushaoqiang.github.io/posts/golangstd-net-http/</link>
      <pubDate>Tue, 19 Mar 2019 20:52:05 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/golangstd-net-http/</guid>
      <description>这篇文章是为了探索Golang中net/http包的实现，笔者暂时只会把主要脉络摸清，具体某些实现逻辑暂不考究，是一篇比较基础的源码阅读文章。
Package http doc.go 先来看看官方对这个包的一个解释
这里说到，这个包是为HTTP提供客户端和服务器端的实现的。
这里还举了一些方法的例子
// Copyright 2011 The Go Authors. All rights reserved. // Use of this source code is governed by a BSD-style // license that can be found in the LICENSE file. /* Package http provides HTTP client and server implementations. Get, Head, Post, and PostForm make HTTP (or HTTPS) requests: resp, err := http.Get(&amp;quot;http://example.com/&amp;quot;) ... resp, err := http.Post(&amp;quot;http://example.com/upload&amp;quot;, &amp;quot;image/jpeg&amp;quot;, &amp;amp;buf) ... resp, err := http.</description>
    </item>
    
    <item>
      <title>Golang Exercism</title>
      <link>https://wushaoqiang.github.io/posts/golang-exercism/</link>
      <pubDate>Sun, 17 Mar 2019 02:15:05 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/golang-exercism/</guid>
      <description>Exercism &amp;ndash; Bob 我的方法：(总之非常愚蠢就是了)
func Hey(remark string) string { // Write some code here to pass the test suite. // Then remove all the stock comments. // They&#39;re here to help you get started but they only clutter a finished solution. // If you leave them in, reviewers may protest! if strings.EqualFold(remark, &amp;quot;&amp;quot;) { return &amp;quot;Fine. Be that way!&amp;quot; } whitespace := true for _, item := range []byte(remark) { if !</description>
    </item>
    
    <item>
      <title>Go圣经读书笔记</title>
      <link>https://wushaoqiang.github.io/posts/golang-bible/</link>
      <pubDate>Sun, 17 Mar 2019 02:13:08 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/golang-bible/</guid>
      <description>第一章 入门 命令行参数 os.Args变量是一个字符串的切片，并且它的第一个元素是命令本身的名字
func main() { var s, sep string for i := 0; i &amp;lt; len(os.Args); i++ { s += sep + os.Args[i] sep = &amp;quot; &amp;quot; } fmt.Println(s) }  运行go run main.go 123
输出/tmp/go-build115927302/b001/exe/main 123
查找重复的行  input := bufio.NewScanner(os.stdin) ~ func NewScanner(r io.Reader) *Scanner  返回一个从r读取的Scanner
 func (s *Scanner) Scan() bool  逐行扫描，当scan停止的时候，或者是到了读取的终点，又或者是发生了错误，这里都会返回false
 func (s *Scanner) Text() string  返回scanner所在行的文本
counts := make(map[string]int) input := bufio.</description>
    </item>
    
    <item>
      <title>Go语言实战</title>
      <link>https://wushaoqiang.github.io/posts/golang-inaction/</link>
      <pubDate>Sun, 17 Mar 2019 02:11:56 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/golang-inaction/</guid>
      <description>Go语言优点：
 Go语言可以说是夹在C/C++和Python这两类语言之间，即提供了较高的性能，又使得开发更加迅速了。
 Go语言内置并发机制，对并发有着更好的性能
 Go语言自带垃圾回收器
 goroutine使用的内存比线程要少，所以常常能够成千上万个goroutine并发
  第六章 并发 概念  进程：当运行一个应用程序时，操作系统会为这个应用程序启动一个进程，可以将这个进程看作一个包含了应用程序在运行中需要用到和维护的各种资源 线程：一个线程是一个空间，这个空间会被操作系统调度来运行函数中所写的代码，线程会被调度到CPU上运行。 每个逻辑处理器绑定在一个线程上 逻辑处理器可以调度goroutine 并发：某一个事情的停止，另一个事情就开始(单线程) 并行：同时开始做(多线程)  goroutine 一个创建goroutine的示例 package main import ( &amp;quot;fmt&amp;quot; &amp;quot;runtime&amp;quot; &amp;quot;sync&amp;quot; ) // main is the entry point for all Go programs. func main() { // Allocate 1 logical processor for the scheduler to use. runtime.GOMAXPROCS(1) // wg is used to wait for the program to finish. // Add a count of two, one for each goroutine.</description>
    </item>
    
    <item>
      <title>Go语言高级编程</title>
      <link>https://wushaoqiang.github.io/posts/golang-highlevel/</link>
      <pubDate>Sun, 17 Mar 2019 02:09:45 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/golang-highlevel/</guid>
      <description>感谢 在文章开头感谢两位作者:柴树杉和曹春晖
这篇文章是开源的，欢迎大家去阅读
本篇博客是笔者对这篇文章的理解，引用的图片也是来自原文，如有侵权请告知！
第一章 基础 1.3 数组、字符串和切片  Go语言的数组是一种值类型，虽然数组的元素可以被修改，但是数组本身的赋值和函数传参都是以整体复制的方式处理的
 Go语言字符串底层数据也是对应的字节数组，但是字符串的只读属性禁止了在程序中对底层字节数组的元素的修改字符串赋值只是复制了数据地址和对应的长度，而不会导致底层数据的复制
 切片头含有底层数据的指针，所以它的赋值也不会导致底层数据的复制
  字符串  字符串的元素不可修改，是一个只读的字节数组
 字符串虽然不是切片，但是支持切片操作
type StringHeader struct { Data uintptr Len int }  字符串结构由两个信息组成：第一个是字符串指向的底层字节数组，第二个是字符串的字节的长度。
  切片 type SliceHeader struct { Data uintptr Len int Cap int }  a = append(a, 0) // 切片扩展1个空间 copy(a[i+1:], a[i:]) // a[i:]向后移动1个位置 a[i] = x // 设置新添加的元素  copy将a[i:]直接搬到了a[i+1:]这个时候就可以在a[i]插入
这种做法可以减少中间创建的临时切片
copy append可以完成切片的添加 删除 插入操作</description>
    </item>
    
    <item>
      <title>Golang--Leetcode</title>
      <link>https://wushaoqiang.github.io/posts/golang-leetcode/</link>
      <pubDate>Sun, 17 Mar 2019 02:07:37 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/golang-leetcode/</guid>
      <description>此文章为做题时发现的不足
 Go语言中的结构体直接赋值是==值传递==，如果要用引用传递，需要这样struct1 := &amp;amp;struct2，也就是要使用取地址符号。但是如果本来struct2就是一个指针，那么就可以直接赋值了。 go func addTwoNumbers(l1 *ListNode, l2 *ListNode) *ListNode { Head := ListNode{} curr := &amp;amp;Head  &amp;mdash;-  给定一个字符串，找出其中不含有重复字符的最长子串的长度方法 - 穷举法：
func lengthOfLongestSubstring(s string) int { var max = 0 for i := 0; i &amp;lt; len(s); i++ { m := make(map[string]bool) for j := i; j &amp;lt; len(s); j++ { if _, ok := m[s[j:j+1]]; !ok { m[s[j:j+1]] = true if j == len(s)-1 { if max &amp;lt; j-i+1 { max = j - i + 1 } } } else { if max &amp;lt; j-i { max = j - i } break } } } return max }   另一个方法： ```go func lengthOfLongestSubstring(s string) int { var max = 0 i := 0 m := make(map[string]int) for j := 0; j &amp;lt; len(s); j++ {  	if _, ok := m[s[j:j+1]]; ok {</description>
    </item>
    
    <item>
      <title>Golang标准库--Unicode</title>
      <link>https://wushaoqiang.github.io/posts/golangstd-unicode/</link>
      <pubDate>Sun, 17 Mar 2019 02:06:01 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/golangstd-unicode/</guid>
      <description>unicode package utf8 utf8.go 这里就不详细分析源码了，只说函数的作用
&amp;mdash; FullRune(p []byte) bool  FullRune报告p中的字节是否以一个rune的完整UTF-8编码开始。
 无效的编码被认为是完整的rune，因为它将转换为宽度为1的错误符文rune。
&amp;mdash; FullRuneInString(s string) bool 和FullRune一样，只是传入了字符串
&amp;mdash; DecodeRune(p []byte) (r rune, size int) 这个函数将切片p中第一个rune返回，并且返回这个rune的大小。
如果p是空的，那么会返回RuneError,0
如果切片中的编码是无效的，那么会返回RuneError,1,对应上一个函数，当编码无效时依然返回true
&amp;mdash; DecodeRuneInString(s string) (r rune, size int) 同上，只是参数变成了字符串
&amp;mdash; func DecodeLastRune(p []byte) (r rune, size int) 只是从后面开始了，功能一样。
&amp;mdash; DecodeLastRuneInString(s string) (r rune, size int) 如上，参数换了字符串
&amp;mdash; RuneLen(r rune) int 返回一个rune的长度，也就是其大小
&amp;mdash; EncodeRune(p []byte, r rune) int 这个就是将rune写入到byte切片上
&amp;mdash; RuneCount(p []byte) int 返回整个切片里面rune的个数</description>
    </item>
    
    <item>
      <title>Golang标准库--String</title>
      <link>https://wushaoqiang.github.io/posts/golangstd-string/</link>
      <pubDate>Sun, 17 Mar 2019 02:04:07 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/golangstd-string/</guid>
      <description>目录 strings builder.go Builder 结构体 noescape(p unsafe.Pointer) unsafe.Pointer &amp;amp; copyCheck() (b *Builder) String() string &amp;amp; (b *Builder) Len() int &amp;amp; (b *Builder) Reset() (b *Builder) Grow(n int) 关于Write的方法 reader.go Reader 结构体 (r *Reader) Len() int &amp;amp; (r *Reader) Size() int64 关于读的方法 (r *Reader) UnreadRune() error (r *Reader) Seek(offset int64, whence int) (int64, error) strings.go  strings builder.go Builder 相当于bytes里面的buffer，并且方法也差不多。但是buffer更加全面
&amp;mdash; 结构体 // A Builder is used to efficiently build a string using Write methods.</description>
    </item>
    
    <item>
      <title>Golang标准库--Bytes</title>
      <link>https://wushaoqiang.github.io/posts/golangstd-bytes/</link>
      <pubDate>Sun, 17 Mar 2019 02:03:03 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/golangstd-bytes/</guid>
      <description>目录 bytes buffer.go Buffer 结构体 const of readOp (b *Buffer) Bytes() []byte (b *Buffer) String() string (b *Buffer) empty() bool (b *Buffer) Len() int (b *Buffer) Cap() int (b *Buffer) Truncate(n int) (b *Buffer) Reset() (b *Buffer) tryGrowByReslice(n int) (int, bool) (b *Buffer) grow(n int) int (b *Buffer) Grow(n int) (b *Buffer) Write(p []byte) (n int, err error) (b *Buffer) WriteString(s string) (n int, err error) makeSlice(n int) []byte (b *Buffer) WriteTo(w io.</description>
    </item>
    
    <item>
      <title>Golang标准库--Bufio</title>
      <link>https://wushaoqiang.github.io/posts/golangstd-bufio/</link>
      <pubDate>Sun, 17 Mar 2019 01:59:52 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/golangstd-bufio/</guid>
      <description>目录 bufio bufio.go 常量 Reader 结构体 常量 NewReaderSize(rd io.Reader, size int) *Reader NewReader(rd io.Reader) *Reader (r *Reader) Size() int (b *Reader) Reset(r io.Reader) &amp;amp; (b *Reader) reset(buf []byte, r io.Reader) (b *Reader) fill() (b *Reader) Peek(n int) ([]byte, error) (b *Reader) Discard(n int) (discarded int, err error) (b *Reader) Read(p []byte) (n int, err error) (b *Reader) ReadByte() (byte, error) (b *Reader) UnreadByte() (b *Reader) ReadRune() (r rune, size int, err error) (b *Reader) UnreadRune() error (b *Reader) Buffered() int (b *Reader) ReadSlice(delim byte) (line []byte, err error) (b *Reader) ReadLine() (line []byte, isPrefix bool, err error) (b *Reader) ReadBytes(delim byte) ([]byte, error) (b *Reader) ReadString(delim byte) (string, error) (b *Reader) WriteTo(w io.</description>
    </item>
    
    <item>
      <title>Web框架</title>
      <link>https://wushaoqiang.github.io/posts/web-strcuture/</link>
      <pubDate>Sun, 17 Mar 2019 01:53:57 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/web-strcuture/</guid>
      <description>这篇文章是参考人世间博主写的一篇文章，这里哪里作为自己了解Gin框架的例子，笔者想在这做初步了解后再去深入了解源码，到时候再写一篇博客来说说Gin源码。
Gin 路由常用方法 func (group *RouterGroup) POST(relativePath string, handlers ...HandlerFunc) IRoutes func (group *RouterGroup) GET(relativePath string, handlers ...HandlerFunc) IRoutes type HandlerFunc func(*Context)  可以看出路由需要的参数是
 相对路径
 处理函数
  这里面是Gin自己定义的一个HandlerFunc，和标准库里面的有所不同，这里的gin.*Context包含了标准库里的ResponseWriter和*http.Request还有一些其它
介绍一些函数 // Query()	是匹配url上的参数，匹配不到就返回空字符串 // DefaultQuery() 也是匹配，如果匹配不到就用默认值 // 127.0.0.1:8000/post?id=111&amp;amp;page=222 // 如果用curl，则需要在&amp;amp;前面加\ id := c.Query(&amp;quot;id&amp;quot;) page := c.DefaultQuery(&amp;quot;page&amp;quot;, &amp;quot;0&amp;quot;) //这个是在表单上获取信息，通过POST方法发送过来的数据 name := c.PostForm(&amp;quot;name&amp;quot;) message := c.PostForm(&amp;quot;message&amp;quot;)  一个完整的路由 router.GET(&amp;quot;/welcome&amp;quot;, func(c *gin.Context) { firstname := c.DefaultQuery(&amp;quot;firstname&amp;quot;, &amp;quot;Guest&amp;quot;) lastname := c.Query(&amp;quot;lastname&amp;quot;) c.</description>
    </item>
    
    <item>
      <title>Go琐碎笔记</title>
      <link>https://wushaoqiang.github.io/posts/learningGo/</link>
      <pubDate>Thu, 14 Mar 2019 16:10:59 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/learningGo/</guid>
      <description>在test文件要是以_test.go结尾，或者是在文件开头加上// +build (tag) 其中tag是自己定的，然后测试的时候在Terminal输入
2019.2.16 go test -tags tagname
构造数组可以先 make([]int,0)
然后 再使用函数：func append(slice []Type, elems ...Type) []Type
unicode.IsLetter(r rune) bool是判断是否为字母，而不是ASCII
res, ok := map[...] 中的ok变量可以用来判断key是否存在
[]rune可以直接转换为字符串string([]rune)
2019.2.17 谨记！ ： 切片和Map在函数传递都是指针传递(引用)
func normalize(cleartext string) string { var b strings.Builder for _, r := range cleartext { if unicode.IsLetter(r) || unicode.IsDigit(r) { b.WriteRune(unicode.ToLower(r)) } } return b.String() }  b.WriteRune(unicode.ToLower(r)) :可以用这种方式代替append()
norm = fmt.Sprintf(&amp;quot;%-[1]*s&amp;quot;, c*r, norm): 其实就是将出c*r代入到[1]*形成的在右侧填充空格
|类型 |默认值 | |int | 0 | |string|“” | | bool | false |  定义一个常量：const name type = value value是必须要有的 枚举：Go没有枚举，用const构造，有两种方法(参考这里的)</description>
    </item>
    
  </channel>
</rss>