<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Golang on Gavin&#39;s Blog</title>
    <link>https://wushaoqiang.github.io/categories/Golang/</link>
    <description>Recent content in Golang on Gavin&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 08 Apr 2019 23:10:14 +0800</lastBuildDate>
    
	<atom:link href="https://wushaoqiang.github.io/categories/Golang/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Golang goquery</title>
      <link>https://wushaoqiang.github.io/posts/golang-goquery/</link>
      <pubDate>Mon, 08 Apr 2019 23:10:14 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/golang-goquery/</guid>
      <description>goquery是一个开源的库，针对解析HTML
今天在做爬虫的时候用到了一些功能，记录下来方便查阅
创建Document对象 doc, err := goquery.NewDocumentFromReader(resp.Body) if err != nil { log.Fatalf(&amp;quot;go query Error %s\n&amp;quot;, err) }  doc对象就包含了我们要解析的HTML主体
一般我们这样用，Find()里面的字符串就是我们要填写的规则
doc.Find(&amp;quot;div&amp;quot;).Each(func(i int, s *goquery.Selection) { fmt.Println(i,s.Text()) })  规则 我们可以根据HTML的源码分析对应的属性id，class等等
 div#id #id是某个div的id属性，筛选出此id的div标签
 div.class .class 同理，是class属性
 div[class],div[lang] 这个也是属性的筛选
 div&amp;gt;p div嵌套的p标签，这里规定只有一级标签，一级以后的p标签不会被筛选出来
 div p div嵌套的p标签，这里无论第几级都会被筛选出来
  属性可以和嵌套一起使用，例如div.class&amp;gt;p&amp;gt;li
Size num := doc.Find(&amp;quot;ul&amp;gt;li&amp;gt;div.job-primary&amp;quot;).Size()  取出标签内的属性 doc.Find(&amp;quot;ul&amp;gt;li&amp;gt;div.job-primary&amp;gt;div&amp;gt;h3&amp;gt;a&amp;quot;).Each(func(i int, s *goquery.Selection) { detail := s.Get(0).Attr[0].Val // fmt.Println(i, nextPage) jobs[i].Detail = detail })  我在这里踩过一个坑</description>
    </item>
    
    <item>
      <title>Golangstd Request</title>
      <link>https://wushaoqiang.github.io/posts/golangstd-request/</link>
      <pubDate>Mon, 08 Apr 2019 11:37:38 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/golangstd-request/</guid>
      <description>最近笔者看了一些源代码，也找了一些Web示例跟着学习，这次是Go源代码的request.go的学习总结
我们知道，在处理Web后端的时候，都会有两个参数http.ResponseWriter和*http.Request
所以Request是我们处理用户请求的接口，学习这个对Web开发也相当重要
Request结构体 type Request struct { Method string URL *url.URL Proto string // &amp;quot;HTTP/1.0&amp;quot; ProtoMajor int // 1 ProtoMinor int // 0 Header Header Body io.ReadCloser GetBody func() (io.ReadCloser, error) ContentLength int64 TransferEncoding []string Close bool Host string Form url.Values PostForm url.Values MultipartForm *multipart.Form Trailer Header RemoteAddr string RequestURI string TLS *tls.ConnectionState Cancel &amp;lt;-chan struct{} Response *Response ctx context.Context }  下面详细介绍每个字段的意义
Method 这就是一个请求的方法(如GET、POST)
但是Go的HTTP客户端不支持发送方法为CONNECT的请求
URL  // URL specifies either the URI being requested (for server // requests) or the URL to access (for client requests).</description>
    </item>
    
    <item>
      <title>Golang Gorm</title>
      <link>https://wushaoqiang.github.io/posts/golang-gorm/</link>
      <pubDate>Fri, 05 Apr 2019 20:37:11 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/golang-gorm/</guid>
      <description>连接数据库 Mysql db, err := gorm.Open(&amp;quot;mysql&amp;quot;, &amp;quot;root:123456@tcp/test?charset=utf8&amp;amp;parseTime=True&amp;quot;) if err != nil { panic(&amp;quot;连接数据库失败&amp;quot;) } defer db.Close() db.SingularTable(true)  选定好数据库后一般会配上
db.SingularTable(true)  如果不调用这个函数，当在数据库加入某个表单的时候，名字会自动加一个s
比如db.CreateTable(&amp;amp;Product{})，在数据库表单里面会得到一个名字为products
所以一般都会加上这个函数
创建Table db.CreateTable(&amp;amp;Product{})  创建多个table
db.CreateTable(&amp;amp;Product{},&amp;amp;User{})  删除Table 关于删除，有两个
db.DropTableIfExist(interface{}) db.DropTable(interface{})  这里可以传入字符串，也可以传入一个结构体
接着上面的例子
db.DropTableIfExist(&amp;quot;product&amp;quot;) db.DropTableIfExist(&amp;amp;Product{})  删除Column 删除Column是要指定Table，所以不能这样
db.DropColumn(&amp;quot;created_at&amp;quot;)  要定位Table，则需要
db.Model(&amp;amp;Product).DropColumn(&amp;quot;created_at&amp;quot;)  创建数据 db.Create(&amp;amp;Product{Code: &amp;quot;L1213&amp;quot;, Price: 1002})  查询数据 // 最后一个符合条件，默认id最后的那个 // Get last record, order by primary key db.Last(&amp;amp;user) //// SELECT * FROM users ORDER BY id DESC LIMIT 1; // 将所有符合条件的返回，这里要传一个结构体数组 // Get all records db.</description>
    </item>
    
    <item>
      <title>Golang Viper</title>
      <link>https://wushaoqiang.github.io/posts/golang-viper/</link>
      <pubDate>Fri, 05 Apr 2019 17:41:18 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/golang-viper/</guid>
      <description>Github
 Viper is a complete configuration solution for Go applications
 这是一个帮组我们读取配置文件的包，总结一些方法，方便以后使用
Reading Config Files  a single Viper instance only supports a single configuration file
 一个Viper对象只能对应一个配置文件，是一个一一对应的映射关系
但是我们在搜索配置文件的时候，可以设置多个路径，如果没有设置路径，则当前程序的目录上寻找，所以我们要设置好路径
这是Github上的一个例子
viper.SetConfigName(&amp;quot;config&amp;quot;) // name of config file (without extension) viper.AddConfigPath(&amp;quot;/etc/appname/&amp;quot;) // path to look for the config file in viper.AddConfigPath(&amp;quot;$HOME/.appname&amp;quot;) // call multiple times to add many search paths viper.AddConfigPath(&amp;quot;.&amp;quot;) // optionally look for config in the working directory err := viper.</description>
    </item>
    
    <item>
      <title>Golang Mega</title>
      <link>https://wushaoqiang.github.io/posts/golang-mega/</link>
      <pubDate>Mon, 01 Apr 2019 15:12:46 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/golang-mega/</guid>
      <description>不积跬步无以至千里，不积小流无以成江海
 本文是博主在学习基础记录的笔记
2019-04-01到2019-04-04，后面会自己DIY一些内容上去(想做成一个小小的技术论坛)
先来总体看一下整个项目的目录吧
. ├── cmd │ └── db_init │ └── main.go ├── config │ └── g.go ├── config.yml ├── controller │ ├── g.go │ ├── home.go │ ├── middle.go │ └── utils.go ├── main.go ├── model │ ├── g.go │ ├── post.go │ ├── user.go │ └── utils.go ├── templates │ ├── 404.html │ ├── _base.html │ ├── content │ │ ├── explore.html │ │ ├── index.</description>
    </item>
    
    <item>
      <title>Golang标准库--http</title>
      <link>https://wushaoqiang.github.io/posts/golangstd-net-http/</link>
      <pubDate>Tue, 19 Mar 2019 20:52:05 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/golangstd-net-http/</guid>
      <description>这篇文章是为了探索Golang中net/http包的实现，笔者暂时只会把主要脉络摸清，具体某些实现逻辑暂不考究，是一篇比较基础的源码阅读文章。
Package http doc.go 先来看看官方对这个包的一个解释
这里说到，这个包是为HTTP提供客户端和服务器端的实现的。
这里还举了一些方法的例子
// Copyright 2011 The Go Authors. All rights reserved. // Use of this source code is governed by a BSD-style // license that can be found in the LICENSE file. /* Package http provides HTTP client and server implementations. Get, Head, Post, and PostForm make HTTP (or HTTPS) requests: resp, err := http.Get(&amp;quot;http://example.com/&amp;quot;) ... resp, err := http.Post(&amp;quot;http://example.com/upload&amp;quot;, &amp;quot;image/jpeg&amp;quot;, &amp;amp;buf) ... resp, err := http.</description>
    </item>
    
    <item>
      <title>Golang Exercism</title>
      <link>https://wushaoqiang.github.io/posts/golang-exercism/</link>
      <pubDate>Sun, 17 Mar 2019 02:15:05 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/golang-exercism/</guid>
      <description>Exercism &amp;ndash; Bob 我的方法：(总之非常愚蠢就是了)
func Hey(remark string) string { // Write some code here to pass the test suite. // Then remove all the stock comments. // They&#39;re here to help you get started but they only clutter a finished solution. // If you leave them in, reviewers may protest! if strings.EqualFold(remark, &amp;quot;&amp;quot;) { return &amp;quot;Fine. Be that way!&amp;quot; } whitespace := true for _, item := range []byte(remark) { if !</description>
    </item>
    
    <item>
      <title>Go圣经读书笔记</title>
      <link>https://wushaoqiang.github.io/posts/golang-bible/</link>
      <pubDate>Sun, 17 Mar 2019 02:13:08 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/golang-bible/</guid>
      <description>第一章 入门 命令行参数 os.Args变量是一个字符串的切片，并且它的第一个元素是命令本身的名字
func main() { var s, sep string for i := 0; i &amp;lt; len(os.Args); i++ { s += sep + os.Args[i] sep = &amp;quot; &amp;quot; } fmt.Println(s) }  运行go run main.go 123
输出/tmp/go-build115927302/b001/exe/main 123
查找重复的行  input := bufio.NewScanner(os.stdin) ~ func NewScanner(r io.Reader) *Scanner  返回一个从r读取的Scanner
 func (s *Scanner) Scan() bool  逐行扫描，当scan停止的时候，或者是到了读取的终点，又或者是发生了错误，这里都会返回false
 func (s *Scanner) Text() string  返回scanner所在行的文本
counts := make(map[string]int) input := bufio.</description>
    </item>
    
    <item>
      <title>Go语言实战</title>
      <link>https://wushaoqiang.github.io/posts/golang-inaction/</link>
      <pubDate>Sun, 17 Mar 2019 02:11:56 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/golang-inaction/</guid>
      <description>Go语言优点：
 Go语言可以说是夹在C/C++和Python这两类语言之间，即提供了较高的性能，又使得开发更加迅速了。
 Go语言内置并发机制，对并发有着更好的性能
 Go语言自带垃圾回收器
 goroutine使用的内存比线程要少，所以常常能够成千上万个goroutine并发
  第六章 并发 概念  进程：当运行一个应用程序时，操作系统会为这个应用程序启动一个进程，可以将这个进程看作一个包含了应用程序在运行中需要用到和维护的各种资源 线程：一个线程是一个空间，这个空间会被操作系统调度来运行函数中所写的代码，线程会被调度到CPU上运行。 每个逻辑处理器绑定在一个线程上 逻辑处理器可以调度goroutine 并发：某一个事情的停止，另一个事情就开始(单线程) 并行：同时开始做(多线程)  goroutine 一个创建goroutine的示例 package main import ( &amp;quot;fmt&amp;quot; &amp;quot;runtime&amp;quot; &amp;quot;sync&amp;quot; ) // main is the entry point for all Go programs. func main() { // Allocate 1 logical processor for the scheduler to use. runtime.GOMAXPROCS(1) // wg is used to wait for the program to finish. // Add a count of two, one for each goroutine.</description>
    </item>
    
    <item>
      <title>Go语言高级编程</title>
      <link>https://wushaoqiang.github.io/posts/golang-highlevel/</link>
      <pubDate>Sun, 17 Mar 2019 02:09:45 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/golang-highlevel/</guid>
      <description>感谢 在文章开头感谢两位作者:柴树杉和曹春晖
这篇文章是开源的，欢迎大家去阅读
本篇博客是笔者对这篇文章的理解，引用的图片也是来自原文，如有侵权请告知！
第一章 基础 1.3 数组、字符串和切片  Go语言的数组是一种值类型，虽然数组的元素可以被修改，但是数组本身的赋值和函数传参都是以整体复制的方式处理的
 Go语言字符串底层数据也是对应的字节数组，但是字符串的只读属性禁止了在程序中对底层字节数组的元素的修改字符串赋值只是复制了数据地址和对应的长度，而不会导致底层数据的复制
 切片头含有底层数据的指针，所以它的赋值也不会导致底层数据的复制
  字符串  字符串的元素不可修改，是一个只读的字节数组
 字符串虽然不是切片，但是支持切片操作
type StringHeader struct { Data uintptr Len int }  字符串结构由两个信息组成：第一个是字符串指向的底层字节数组，第二个是字符串的字节的长度。
  切片 type SliceHeader struct { Data uintptr Len int Cap int }  a = append(a, 0) // 切片扩展1个空间 copy(a[i+1:], a[i:]) // a[i:]向后移动1个位置 a[i] = x // 设置新添加的元素  copy将a[i:]直接搬到了a[i+1:]这个时候就可以在a[i]插入
这种做法可以减少中间创建的临时切片
copy append可以完成切片的添加 删除 插入操作</description>
    </item>
    
    <item>
      <title>Golang--Leetcode</title>
      <link>https://wushaoqiang.github.io/posts/golang-leetcode/</link>
      <pubDate>Sun, 17 Mar 2019 02:07:37 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/golang-leetcode/</guid>
      <description>此文章为做题时发现的不足
 Go语言中的结构体直接赋值是==值传递==，如果要用引用传递，需要这样struct1 := &amp;amp;struct2，也就是要使用取地址符号。但是如果本来struct2就是一个指针，那么就可以直接赋值了。 go func addTwoNumbers(l1 *ListNode, l2 *ListNode) *ListNode { Head := ListNode{} curr := &amp;amp;Head  &amp;mdash;-  给定一个字符串，找出其中不含有重复字符的最长子串的长度方法 - 穷举法：
func lengthOfLongestSubstring(s string) int { var max = 0 for i := 0; i &amp;lt; len(s); i++ { m := make(map[string]bool) for j := i; j &amp;lt; len(s); j++ { if _, ok := m[s[j:j+1]]; !ok { m[s[j:j+1]] = true if j == len(s)-1 { if max &amp;lt; j-i+1 { max = j - i + 1 } } } else { if max &amp;lt; j-i { max = j - i } break } } } return max }   另一个方法： ```go func lengthOfLongestSubstring(s string) int { var max = 0 i := 0 m := make(map[string]int) for j := 0; j &amp;lt; len(s); j++ {  	if _, ok := m[s[j:j+1]]; ok {</description>
    </item>
    
    <item>
      <title>Golang标准库--Unicode</title>
      <link>https://wushaoqiang.github.io/posts/golangstd-unicode/</link>
      <pubDate>Sun, 17 Mar 2019 02:06:01 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/golangstd-unicode/</guid>
      <description>unicode package utf8 utf8.go 这里就不详细分析源码了，只说函数的作用
&amp;mdash; FullRune(p []byte) bool  FullRune报告p中的字节是否以一个rune的完整UTF-8编码开始。
 无效的编码被认为是完整的rune，因为它将转换为宽度为1的错误符文rune。
&amp;mdash; FullRuneInString(s string) bool 和FullRune一样，只是传入了字符串
&amp;mdash; DecodeRune(p []byte) (r rune, size int) 这个函数将切片p中第一个rune返回，并且返回这个rune的大小。
如果p是空的，那么会返回RuneError,0
如果切片中的编码是无效的，那么会返回RuneError,1,对应上一个函数，当编码无效时依然返回true
&amp;mdash; DecodeRuneInString(s string) (r rune, size int) 同上，只是参数变成了字符串
&amp;mdash; func DecodeLastRune(p []byte) (r rune, size int) 只是从后面开始了，功能一样。
&amp;mdash; DecodeLastRuneInString(s string) (r rune, size int) 如上，参数换了字符串
&amp;mdash; RuneLen(r rune) int 返回一个rune的长度，也就是其大小
&amp;mdash; EncodeRune(p []byte, r rune) int 这个就是将rune写入到byte切片上
&amp;mdash; RuneCount(p []byte) int 返回整个切片里面rune的个数</description>
    </item>
    
    <item>
      <title>Golang标准库--String</title>
      <link>https://wushaoqiang.github.io/posts/golangstd-string/</link>
      <pubDate>Sun, 17 Mar 2019 02:04:07 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/golangstd-string/</guid>
      <description>目录 strings builder.go Builder 结构体 noescape(p unsafe.Pointer) unsafe.Pointer &amp;amp; copyCheck() (b *Builder) String() string &amp;amp; (b *Builder) Len() int &amp;amp; (b *Builder) Reset() (b *Builder) Grow(n int) 关于Write的方法 reader.go Reader 结构体 (r *Reader) Len() int &amp;amp; (r *Reader) Size() int64 关于读的方法 (r *Reader) UnreadRune() error (r *Reader) Seek(offset int64, whence int) (int64, error) strings.go  strings builder.go Builder 相当于bytes里面的buffer，并且方法也差不多。但是buffer更加全面
&amp;mdash; 结构体 // A Builder is used to efficiently build a string using Write methods.</description>
    </item>
    
    <item>
      <title>Golang标准库--Bytes</title>
      <link>https://wushaoqiang.github.io/posts/golangstd-bytes/</link>
      <pubDate>Sun, 17 Mar 2019 02:03:03 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/golangstd-bytes/</guid>
      <description>目录 bytes buffer.go Buffer 结构体 const of readOp (b *Buffer) Bytes() []byte (b *Buffer) String() string (b *Buffer) empty() bool (b *Buffer) Len() int (b *Buffer) Cap() int (b *Buffer) Truncate(n int) (b *Buffer) Reset() (b *Buffer) tryGrowByReslice(n int) (int, bool) (b *Buffer) grow(n int) int (b *Buffer) Grow(n int) (b *Buffer) Write(p []byte) (n int, err error) (b *Buffer) WriteString(s string) (n int, err error) makeSlice(n int) []byte (b *Buffer) WriteTo(w io.</description>
    </item>
    
    <item>
      <title>Golang标准库--Bufio</title>
      <link>https://wushaoqiang.github.io/posts/golangstd-bufio/</link>
      <pubDate>Sun, 17 Mar 2019 01:59:52 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/golangstd-bufio/</guid>
      <description>目录 bufio bufio.go 常量 Reader 结构体 常量 NewReaderSize(rd io.Reader, size int) *Reader NewReader(rd io.Reader) *Reader (r *Reader) Size() int (b *Reader) Reset(r io.Reader) &amp;amp; (b *Reader) reset(buf []byte, r io.Reader) (b *Reader) fill() (b *Reader) Peek(n int) ([]byte, error) (b *Reader) Discard(n int) (discarded int, err error) (b *Reader) Read(p []byte) (n int, err error) (b *Reader) ReadByte() (byte, error) (b *Reader) UnreadByte() (b *Reader) ReadRune() (r rune, size int, err error) (b *Reader) UnreadRune() error (b *Reader) Buffered() int (b *Reader) ReadSlice(delim byte) (line []byte, err error) (b *Reader) ReadLine() (line []byte, isPrefix bool, err error) (b *Reader) ReadBytes(delim byte) ([]byte, error) (b *Reader) ReadString(delim byte) (string, error) (b *Reader) WriteTo(w io.</description>
    </item>
    
    <item>
      <title>Web框架</title>
      <link>https://wushaoqiang.github.io/posts/web-strcuture/</link>
      <pubDate>Sun, 17 Mar 2019 01:53:57 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/web-strcuture/</guid>
      <description>这篇文章是参考人世间博主写的一篇文章，这里哪里作为自己了解Gin框架的例子，笔者想在这做初步了解后再去深入了解源码，到时候再写一篇博客来说说Gin源码。
Gin 路由常用方法 func (group *RouterGroup) POST(relativePath string, handlers ...HandlerFunc) IRoutes func (group *RouterGroup) GET(relativePath string, handlers ...HandlerFunc) IRoutes type HandlerFunc func(*Context)  可以看出路由需要的参数是
 相对路径
 处理函数
  这里面是Gin自己定义的一个HandlerFunc，和标准库里面的有所不同，这里的gin.*Context包含了标准库里的ResponseWriter和*http.Request还有一些其它
介绍一些函数 // Query()	是匹配url上的参数，匹配不到就返回空字符串 // DefaultQuery() 也是匹配，如果匹配不到就用默认值 // 127.0.0.1:8000/post?id=111&amp;amp;page=222 // 如果用curl，则需要在&amp;amp;前面加\ id := c.Query(&amp;quot;id&amp;quot;) page := c.DefaultQuery(&amp;quot;page&amp;quot;, &amp;quot;0&amp;quot;) //这个是在表单上获取信息，通过POST方法发送过来的数据 name := c.PostForm(&amp;quot;name&amp;quot;) message := c.PostForm(&amp;quot;message&amp;quot;)  一个完整的路由 router.GET(&amp;quot;/welcome&amp;quot;, func(c *gin.Context) { firstname := c.DefaultQuery(&amp;quot;firstname&amp;quot;, &amp;quot;Guest&amp;quot;) lastname := c.Query(&amp;quot;lastname&amp;quot;) c.</description>
    </item>
    
    <item>
      <title>Go琐碎笔记</title>
      <link>https://wushaoqiang.github.io/posts/learningGo/</link>
      <pubDate>Thu, 14 Mar 2019 16:10:59 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/learningGo/</guid>
      <description>在test文件要是以_test.go结尾，或者是在文件开头加上// +build (tag) 其中tag是自己定的，然后测试的时候在Terminal输入
2019.2.16 go test -tags tagname
构造数组可以先 make([]int,0)
然后 再使用函数：func append(slice []Type, elems ...Type) []Type
unicode.IsLetter(r rune) bool是判断是否为字母，而不是ASCII
res, ok := map[...] 中的ok变量可以用来判断key是否存在
[]rune可以直接转换为字符串string([]rune)
2019.2.17 谨记！ ： 切片和Map在函数传递都是指针传递(引用)
func normalize(cleartext string) string { var b strings.Builder for _, r := range cleartext { if unicode.IsLetter(r) || unicode.IsDigit(r) { b.WriteRune(unicode.ToLower(r)) } } return b.String() }  b.WriteRune(unicode.ToLower(r)) :可以用这种方式代替append()
norm = fmt.Sprintf(&amp;quot;%-[1]*s&amp;quot;, c*r, norm): 其实就是将出c*r代入到[1]*形成的在右侧填充空格
|类型 |默认值 | |int | 0 | |string|“” | | bool | false |  定义一个常量：const name type = value value是必须要有的 枚举：Go没有枚举，用const构造，有两种方法(参考这里的)</description>
    </item>
    
  </channel>
</rss>