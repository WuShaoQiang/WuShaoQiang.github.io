<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Leetcode on Gavin&#39;s Blog</title>
    <link>https://wushaoqiang.github.io/categories/Leetcode/</link>
    <description>Recent content in Leetcode on Gavin&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sat, 04 May 2019 20:58:20 +0800</lastBuildDate>
    
	<atom:link href="https://wushaoqiang.github.io/categories/Leetcode/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Leetcode 242</title>
      <link>https://wushaoqiang.github.io/posts/leetcode-242/</link>
      <pubDate>Sat, 04 May 2019 20:58:20 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/leetcode-242/</guid>
      <description>题目 Given two strings s and t , write a function to determine if t is an anagram of s. Example 1: Input: s = &amp;quot;anagram&amp;quot;, t = &amp;quot;nagaram&amp;quot; Output: true Example 2: Input: s = &amp;quot;rat&amp;quot;, t = &amp;quot;car&amp;quot; Output: false Note: You may assume the string contains only lowercase alphabets. Follow up: What if the inputs contain unicode characters? How would you adapt your solution to such case?</description>
    </item>
    
    <item>
      <title>Leetcode 237</title>
      <link>https://wushaoqiang.github.io/posts/leetcode-237/</link>
      <pubDate>Sat, 04 May 2019 20:58:13 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/leetcode-237/</guid>
      <description>题目 Write a function to delete a node (except the tail) in a singly linked list, given only access to that node. Given linked list -- head = [4,5,1,9], which looks like following: Example 1: Input: head = [4,5,1,9], node = 5 Output: [4,1,9] Explanation: You are given the second node with value 5, the linked list should become 4 -&amp;gt; 1 -&amp;gt; 9 after calling your function. Example 2: Input: head = [4,5,1,9], node = 1 Output: [4,5,9] Explanation: You are given the third node with value 1, the linked list should become 4 -&amp;gt; 5 -&amp;gt; 9 after calling your function.</description>
    </item>
    
    <item>
      <title>Leetcode 235</title>
      <link>https://wushaoqiang.github.io/posts/leetcode-235/</link>
      <pubDate>Sat, 04 May 2019 20:58:10 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/leetcode-235/</guid>
      <description>题目 Given a binary search tree (BST), find the lowest common ancestor (LCA) of two given nodes in the BST. According to the definition of LCA on Wikipedia: “The lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q as descendants (where we allow a node to be a descendant of itself).” Given binary search tree: root = [6,2,8,0,4,7,9,null,null,3,5] Example 1: Input: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8 Output: 6 Explanation: The LCA of nodes 2 and 8 is 6.</description>
    </item>
    
    <item>
      <title>Leetcode 234</title>
      <link>https://wushaoqiang.github.io/posts/leetcode-234/</link>
      <pubDate>Sat, 04 May 2019 20:58:07 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/leetcode-234/</guid>
      <description>题目 Given a singly linked list, determine if it is a palindrome. Example 1: Input: 1-&amp;gt;2 Output: false Example 2: Input: 1-&amp;gt;2-&amp;gt;2-&amp;gt;1 Output: true Follow up: Could you do it in O(n) time and O(1) space?  我的解答 如果不限定空间复杂度
func isPalindrome(head *ListNode) bool { v := make([]int, 0) for head != nil { v = append(v, head.Val) head = head.Next } l := len(v) for i := 0; i &amp;lt; l/2; i++ { if v[i] !</description>
    </item>
    
    <item>
      <title>Leetcode 231</title>
      <link>https://wushaoqiang.github.io/posts/leetcode-231/</link>
      <pubDate>Sat, 04 May 2019 20:58:03 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/leetcode-231/</guid>
      <description>题目 Given an integer, write a function to determine if it is a power of two. Example 1: Input: 1 Output: true Explanation: 20 = 1 Example 2: Input: 16 Output: true Explanation: 24 = 16 Example 3: Input: 218 Output: false  我的解答 func isPowerOfTwo(n int) bool { if n == 0 { return false } return (n &amp;amp; (n - 1)) == 0 }  这其实算是一道智力题，判断这个数是否是2的次方
最优解答 无</description>
    </item>
    
    <item>
      <title>Leetcode 226</title>
      <link>https://wushaoqiang.github.io/posts/leetcode-226/</link>
      <pubDate>Sat, 04 May 2019 20:57:59 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/leetcode-226/</guid>
      <description>题目 Invert a binary tree. Example: Input: 4 / \ 2 7 / \ / \ 1 3 6 9 Output: 4 / \ 7 2 / \ / \ 9 6 3 1 Trivia: This problem was inspired by this original tweet by Max Howell: Google: 90% of our engineers use the software you wrote (Homebrew), but you can’t invert a binary tree on a whiteboard so f*** off.</description>
    </item>
    
    <item>
      <title>Leetcode 219</title>
      <link>https://wushaoqiang.github.io/posts/leetcode-219/</link>
      <pubDate>Sat, 04 May 2019 20:57:54 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/leetcode-219/</guid>
      <description>题目 Given an array of integers and an integer k, find out whether there are two distinct indices i and j in the array such that nums[i] = nums[j] and the absolute difference between i and j is at most k. Example 1: Input: nums = [1,2,3,1], k = 3 Output: true Example 2: Input: nums = [1,0,1,1], k = 1 Output: true Example 3: Input: nums = [1,2,3,1,2,3], k = 2 Output: false  我的解答 这个题目可以用暴力法做，只是速度究极慢</description>
    </item>
    
    <item>
      <title>Leetcode 217</title>
      <link>https://wushaoqiang.github.io/posts/leetcode-217/</link>
      <pubDate>Sat, 04 May 2019 20:57:49 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/leetcode-217/</guid>
      <description>题目 Given an array of integers, find if the array contains any duplicates. Your function should return true if any value appears at least twice in the array, and it should return false if every element is distinct. Example 1: Input: [1,2,3,1] Output: true Example 2: Input: [1,2,3,4] Output: false Example 3: Input: [1,1,1,3,3,4,3,2,4,2] Output: true  我的解答 func containsDuplicate(nums []int) bool { isExist := make(map[int]bool,len(nums)) for _, num := range nums { if _, exist := isExist[num]; exist { return true } isExist[num] = true } return false }  这题比较简单，唯一要注意的点是，提前分配好空间，会有速度提升</description>
    </item>
    
    <item>
      <title>Leetcode 206</title>
      <link>https://wushaoqiang.github.io/posts/leetcode-206/</link>
      <pubDate>Sat, 04 May 2019 20:57:43 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/leetcode-206/</guid>
      <description>题目 Reverse a singly linked list. Example: Input: 1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;5-&amp;gt;NULL Output: 5-&amp;gt;4-&amp;gt;3-&amp;gt;2-&amp;gt;1-&amp;gt;NULL Follow up: A linked list can be reversed either iteratively or recursively. Could you implement both?  我的解答 覆盖了迭代和递归的解法
func reverseList(head *ListNode) *ListNode { if head == nil { return nil } // curr := head // return reverse(nil, curr) return reverse(head) } // func reverse(parent, curr *ListNode) *ListNode { // if curr.Next == nil { // curr.Next = parent // return curr // } // result := reverse(curr, curr.</description>
    </item>
    
    <item>
      <title>Leetcode 205</title>
      <link>https://wushaoqiang.github.io/posts/leetcode-205/</link>
      <pubDate>Sat, 04 May 2019 20:57:39 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/leetcode-205/</guid>
      <description>题目 Given two strings s and t, determine if they are isomorphic. Two strings are isomorphic if the characters in s can be replaced to get t. All occurrences of a character must be replaced with another character while preserving the order of characters. No two characters may map to the same character but a character may map to itself. Example 1: Input: s = &amp;quot;egg&amp;quot;, t = &amp;quot;add&amp;quot; Output: true Example 2: Input: s = &amp;quot;foo&amp;quot;, t = &amp;quot;bar&amp;quot; Output: false Example 3: Input: s = &amp;quot;paper&amp;quot;, t = &amp;quot;title&amp;quot; Output: true  我的解答 func isIsomorphic(s string, t string) bool { beUsed := make(map[byte]bool) letterMap := make(map[byte]byte) for i := 0; i &amp;lt; len(s); i++ { if b, exist := letterMap[s[i]]; !</description>
    </item>
    
    <item>
      <title>Leetcode 204</title>
      <link>https://wushaoqiang.github.io/posts/leetcode-204/</link>
      <pubDate>Sat, 04 May 2019 20:57:35 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/leetcode-204/</guid>
      <description>题目 Count the number of prime numbers less than a non-negative number, n. Example: Input: 10 Output: 4 Explanation: There are 4 prime numbers less than 10, they are 2, 3, 5, 7.  我的解答 这题跟着评论区的思路做出来的&amp;ndash;厄拉多塞筛法
func countPrimes(n int) int { // 简单判断 if n &amp;lt; 3 { return 0 } // 标志哪些0～n-1已经被访问过 flag := make([]bool, n) //因为0,1不是素数，先减去 total := n - 2 // 只需要找n的根号前的素数 for i := 2; i*i &amp;lt; n; i++ { // 访问过 if flag[i] { continue } // 没访问过，这个素数i的所有倍数(在n内)都不是素数，去除 for j := 2; i*j &amp;lt; n; j++ { if !</description>
    </item>
    
    <item>
      <title>Leetcode 203</title>
      <link>https://wushaoqiang.github.io/posts/leetcode-203/</link>
      <pubDate>Sat, 04 May 2019 20:57:33 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/leetcode-203/</guid>
      <description>题目 Remove all elements from a linked list of integers that have value val. Example: Input: 1-&amp;gt;2-&amp;gt;6-&amp;gt;3-&amp;gt;4-&amp;gt;5-&amp;gt;6, val = 6 Output: 1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;5  我的解答 func removeElements(head *ListNode, val int) *ListNode { for head != nil &amp;amp;&amp;amp; head.Val == val { head = head.Next } if head == nil { return head } tmp := head for tmp.Next != nil { if tmp.Next.Val == val { tmp.Next = tmp.Next.Next } else { tmp = tmp.</description>
    </item>
    
    <item>
      <title>Leetcode 202</title>
      <link>https://wushaoqiang.github.io/posts/leetcode-202/</link>
      <pubDate>Sat, 04 May 2019 20:57:29 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/leetcode-202/</guid>
      <description>题目 Write an algorithm to determine if a number is &amp;quot;happy&amp;quot;. A happy number is a number defined by the following process: Starting with any positive integer, replace the number by the sum of the squares of its digits, and repeat the process until the number equals 1 (where it will stay), or it loops endlessly in a cycle which does not include 1. Those numbers for which this process ends in 1 are happy numbers.</description>
    </item>
    
    <item>
      <title>Leetcode 198</title>
      <link>https://wushaoqiang.github.io/posts/leetcode-198/</link>
      <pubDate>Tue, 30 Apr 2019 22:38:42 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/leetcode-198/</guid>
      <description>题目 You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security system connected and it will automatically contact the police if two adjacent houses were broken into on the same night. Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police.</description>
    </item>
    
    <item>
      <title>Leetcode 191</title>
      <link>https://wushaoqiang.github.io/posts/leetcode-191/</link>
      <pubDate>Tue, 30 Apr 2019 22:38:39 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/leetcode-191/</guid>
      <description>题目 Example 1: Input: 00000000000000000000000000001011 Output: 3 Explanation: The input binary string 00000000000000000000000000001011 has a total of three &#39;1&#39; bits. Example 2: Input: 00000000000000000000000010000000 Output: 1 Explanation: The input binary string 00000000000000000000000010000000 has a total of one &#39;1&#39; bit. Example 3: Input: 11111111111111111111111111111101 Output: 31 Explanation: The input binary string 11111111111111111111111111111101 has a total of thirty one &#39;1&#39; bits. Note: Note that in some languages such as Java, there is no unsigned integer type.</description>
    </item>
    
    <item>
      <title>Leetcode 190</title>
      <link>https://wushaoqiang.github.io/posts/leetcode-190/</link>
      <pubDate>Tue, 30 Apr 2019 22:38:37 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/leetcode-190/</guid>
      <description>题目 Reverse bits of a given 32 bits unsigned integer. Example 1: Input: 00000010100101000001111010011100 Output: 00111001011110000010100101000000 Explanation: The input binary string 00000010100101000001111010011100 represents the unsigned integer 43261596, so return 964176192 which its binary representation is 00111001011110000010100101000000. Example 2: Input: 11111111111111111111111111111101 Output: 10111111111111111111111111111111 Explanation: The input binary string 11111111111111111111111111111101 represents the unsigned integer 4294967293, so return 3221225471 which its binary representation is 10101111110010110010011101101001. Note: Note that in some languages such as Java, there is no unsigned integer type.</description>
    </item>
    
    <item>
      <title>Leetcode 189</title>
      <link>https://wushaoqiang.github.io/posts/leetcode-189/</link>
      <pubDate>Tue, 30 Apr 2019 22:38:28 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/leetcode-189/</guid>
      <description>题目 Given an array, rotate the array to the right by k steps, where k is non-negative. Example 1: Input: [1,2,3,4,5,6,7] and k = 3 Output: [5,6,7,1,2,3,4] Explanation: rotate 1 steps to the right: [7,1,2,3,4,5,6] rotate 2 steps to the right: [6,7,1,2,3,4,5] rotate 3 steps to the right: [5,6,7,1,2,3,4] Example 2: Input: [-1,-100,3,99] and k = 2 Output: [3,99,-1,-100] Explanation: rotate 1 steps to the right: [99,-1,-100,3] rotate 2 steps to the right: [3,99,-1,-100] Note: Try to come up as many solutions as you can, there are at least 3 different ways to solve this problem.</description>
    </item>
    
    <item>
      <title>Leetcode 172</title>
      <link>https://wushaoqiang.github.io/posts/leetcode-172/</link>
      <pubDate>Tue, 30 Apr 2019 22:38:25 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/leetcode-172/</guid>
      <description>题目 Given an integer n, return the number of trailing zeroes in n!. Example 1: Input: 3 Output: 0 Explanation: 3! = 6, no trailing zero. Example 2: Input: 5 Output: 1 Explanation: 5! = 120, one trailing zero. Note: Your solution should be in logarithmic time complexity.  我的解答 看了些提示才做出来
func trailingZeroes(n int) int { count := 0 tmp := 1 len := 0 for n/(tmp*5) &amp;gt; 0 { len++ tmp = tmp * 5 } for i := 0; i &amp;lt; len; i++ { count += (n / tmp) tmp = tmp / 5 } return count }  最优解答 无</description>
    </item>
    
    <item>
      <title>Leetcode 171</title>
      <link>https://wushaoqiang.github.io/posts/leetcode-171/</link>
      <pubDate>Tue, 30 Apr 2019 22:38:08 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/leetcode-171/</guid>
      <description>题目 Given a column title as appear in an Excel sheet, return its corresponding column number. For example: A -&amp;gt; 1 B -&amp;gt; 2 C -&amp;gt; 3 ... Z -&amp;gt; 26 AA -&amp;gt; 27 AB -&amp;gt; 28 ... Example 1: Input: &amp;quot;A&amp;quot; Output: 1 Example 2: Input: &amp;quot;AB&amp;quot; Output: 28 Example 3: Input: &amp;quot;ZY&amp;quot; Output: 701  我的解答 func titleToNumber(s string) int { result := 0 tmp := 1 for i := len(s) - 1; i &amp;gt;= 0; i-- { num := int(s[i] - 64) result += (num * tmp) tmp = tmp * 26 } return result }  最优解答 无</description>
    </item>
    
    <item>
      <title>Leetcode 169</title>
      <link>https://wushaoqiang.github.io/posts/leetcode-169/</link>
      <pubDate>Mon, 29 Apr 2019 22:27:15 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/leetcode-169/</guid>
      <description>题目 Given an array of size n, find the majority element. The majority element is the element that appears more than ⌊ n/2 ⌋ times. You may assume that the array is non-empty and the majority element always exist in the array. Example 1: Input: [3,2,3] Output: 3 Example 2: Input: [2,2,1,1,1,2,2] Output: 2  我的解答 func majorityElement(nums []int) int { insertSort(nums) return nums[len(nums)/2] } func insertSort(nums []int) { for i := 1; i &amp;lt; len(nums); i++ { tmp := nums[i] j := i - 1 for ; j &amp;gt;= 0 &amp;amp;&amp;amp; tmp &amp;lt; nums[j]; j-- { nums[j+1] = nums[j] } nums[j+1] = tmp } }  最优解答 func majorityElement(nums []int) int { if len(nums) &amp;lt; 1 { return 0 } count, flag := 1, nums[0] for i := 1; i &amp;lt; len(nums); i++ { if count &amp;lt; 1 { count = 1 flag = nums[i] continue } if flag == nums[i] { count++ } else { count-- } } return flag }  难疑点&amp;amp;核心 因题目特殊性，题目规定众数要超过数量的一半</description>
    </item>
    
    <item>
      <title>Leetcode 168</title>
      <link>https://wushaoqiang.github.io/posts/leetcode-168/</link>
      <pubDate>Mon, 29 Apr 2019 22:27:11 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/leetcode-168/</guid>
      <description>题目 Given a positive integer, return its corresponding column title as appear in an Excel sheet. For example: 1 -&amp;gt; A 2 -&amp;gt; B 3 -&amp;gt; C ... 26 -&amp;gt; Z 27 -&amp;gt; AA 28 -&amp;gt; AB ... Example 1: Input: 1 Output: &amp;quot;A&amp;quot; Example 2: Input: 28 Output: &amp;quot;AB&amp;quot; Example 3: Input: 701 Output: &amp;quot;ZY&amp;quot;  我的解答 func convertToTitle(n int) string { if n &amp;lt;= 0 { return &amp;quot;&amp;quot; } len := 0 tmp := n for tmp/26 &amp;gt; 0 { len++ tmp = tmp / 26 } strs := make([]string, len+1) for n &amp;gt; 0 { n-- strs[len] = string((n % 26) + &#39;A&#39;) n = n / 26 len-- } return strings.</description>
    </item>
    
    <item>
      <title>Leetcode 167</title>
      <link>https://wushaoqiang.github.io/posts/leetcode-167/</link>
      <pubDate>Mon, 29 Apr 2019 22:27:05 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/leetcode-167/</guid>
      <description>题目 Given an array of integers that is already sorted in ascending order, find two numbers such that they add up to a specific target number. The function twoSum should return indices of the two numbers such that they add up to the target, where index1 must be less than index2. Note: Your returned answers (both index1 and index2) are not zero-based. You may assume that each input would have exactly one solution and you may not use the same element twice.</description>
    </item>
    
    <item>
      <title>Leetcode 160</title>
      <link>https://wushaoqiang.github.io/posts/leetcode-160/</link>
      <pubDate>Mon, 29 Apr 2019 22:26:55 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/leetcode-160/</guid>
      <description>题目 Write a program to find the node at which the intersection of two singly linked lists begins. For example, the following two linked lists: begin to intersect at node c1. Example 1: Input: intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3 Output: Reference of the node with value = 8 Input Explanation: The intersected node&#39;s value is 8 (note that this must not be 0 if the two lists intersect).</description>
    </item>
    
    <item>
      <title>Leetcode 155</title>
      <link>https://wushaoqiang.github.io/posts/leetcode-155/</link>
      <pubDate>Mon, 29 Apr 2019 22:26:50 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/leetcode-155/</guid>
      <description>题目  Design a stack that supports push, pop, top, and retrieving the minimum element in constant time. push(x) -- Push element x onto stack. pop() -- Removes the element on top of the stack. top() -- Get the top element. getMin() -- Retrieve the minimum element in the stack. Example: MinStack minStack = new MinStack(); minStack.push(-2); minStack.push(0); minStack.push(-3); minStack.getMin(); --&amp;gt; Returns -3. minStack.pop(); minStack.top(); --&amp;gt; Returns 0. minStack.getMin(); --&amp;gt; Returns -2.</description>
    </item>
    
    <item>
      <title>Leetcode 141</title>
      <link>https://wushaoqiang.github.io/posts/leetcode-141/</link>
      <pubDate>Mon, 29 Apr 2019 22:26:44 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/leetcode-141/</guid>
      <description>题目 Given a linked list, determine if it has a cycle in it. To represent a cycle in the given linked list, we use an integer pos which represents the position (0-indexed) in the linked list where tail connects to. If pos is -1, then there is no cycle in the linked list. Example 1: Input: head = [3,2,0,-4], pos = 1 Output: true Explanation: There is a cycle in the linked list, where tail connects to the second node.</description>
    </item>
    
    <item>
      <title>Leetcode 136</title>
      <link>https://wushaoqiang.github.io/posts/leetcode-136/</link>
      <pubDate>Mon, 29 Apr 2019 22:26:40 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/leetcode-136/</guid>
      <description>题目 Given a non-empty array of integers, every element appears twice except for one. Find that single one. Note: Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory? Example 1: Input: [2,2,1] Output: 1 Example 2: Input: [4,1,2,1,2] Output: 4  我的解答 没想出来，看了评论区才知道
最优解答 func singleNumber(nums []int) int { for i := len(nums) - 1; i &amp;gt; 0; i-- { nums[i-1] = nums[i-1] ^ nums[i] } return nums[0] }  难疑点&amp;amp;核心 因为题目说了，只有一个数字是不会出现两次，其它数字都出现两次</description>
    </item>
    
    <item>
      <title>Leetcode 125</title>
      <link>https://wushaoqiang.github.io/posts/leetcode-125/</link>
      <pubDate>Mon, 29 Apr 2019 22:26:35 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/leetcode-125/</guid>
      <description>题目 给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。 说明：本题中，我们将空字符串定义为有效的回文串。 示例 1: 输入: &amp;quot;A man, a plan, a canal: Panama&amp;quot; 输出: true 示例 2: 输入: &amp;quot;race a car&amp;quot; 输出: false  我的解答 func isPalindrome(s string) bool { s = strings.Join(filter(s), &amp;quot;&amp;quot;) n := len(s) for i := 0; i &amp;lt; n/2; i++ { if s[i] != s[n-1-i] { return false } } return true } func filter(s string) []string { return strings.FieldsFunc(strings.ToLower(s), func(r rune) bool { return !</description>
    </item>
    
    <item>
      <title>Leetcode 122</title>
      <link>https://wushaoqiang.github.io/posts/leetcode-122/</link>
      <pubDate>Mon, 29 Apr 2019 22:26:29 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/leetcode-122/</guid>
      <description>题目 给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。 设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。 注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。 示例 1: 输入: [7,1,5,3,6,4] 输出: 7 解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。 随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。 示例 2: 输入: [1,2,3,4,5] 输出: 4 解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。 注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。 因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。 示例 3: 输入: [7,6,4,3,1] 输出: 0 解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。  我的解答 func maxProfit(prices []int) int { buy := 0 sell := 0 profit := 0 n := len(prices) for { for buy &amp;lt; n-1 &amp;amp;&amp;amp; prices[buy+1] &amp;lt;= prices[buy] { buy++ } sell = buy for sell &amp;lt; n-1 &amp;amp;&amp;amp; prices[sell+1] &amp;gt; prices[sell] { sell++ } if sell == buy { return profit } profit += prices[sell] - prices[buy] buy = sell } }  最优解答 无</description>
    </item>
    
    <item>
      <title>Leetcode 121</title>
      <link>https://wushaoqiang.github.io/posts/leetcode-121/</link>
      <pubDate>Mon, 29 Apr 2019 00:38:18 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/leetcode-121/</guid>
      <description>题目 Say you have an array for which the ith element is the price of a given stock on day i. If you were only permitted to complete at most one transaction (i.e., buy one and sell one share of the stock), design an algorithm to find the maximum profit. Note that you cannot sell a stock before you buy one. Example 1: Input: [7,1,5,3,6,4] Output: 5 Explanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.</description>
    </item>
    
    <item>
      <title>Leetcode 119</title>
      <link>https://wushaoqiang.github.io/posts/leetcode-119/</link>
      <pubDate>Mon, 29 Apr 2019 00:38:14 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/leetcode-119/</guid>
      <description>题目 Given a non-negative index k where k ≤ 33, return the kth index row of the Pascal&#39;s triangle. Note that the row index starts from 0. In Pascal&#39;s triangle, each number is the sum of the two numbers directly above it. Example: Input: 3 Output: [1,3,3,1] Follow up: Could you optimize your algorithm to use only O(k) extra space?  我的解答 func getRow(rowIndex int) []int { result := make([]int, rowIndex+1) result[0] = 1 for i := 0; i &amp;lt; rowIndex; i++ { result[i+1] = result[i] for j := i; j &amp;gt; 0; j-- { result[j] = result[j] + result[j-1] } } return result }  最优解答 无</description>
    </item>
    
    <item>
      <title>Leetcode 118</title>
      <link>https://wushaoqiang.github.io/posts/leetcode-118/</link>
      <pubDate>Mon, 29 Apr 2019 00:38:11 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/leetcode-118/</guid>
      <description>题目 Given a non-negative integer numRows, generate the first numRows of Pascal&#39;s triangle. In Pascal&#39;s triangle, each number is the sum of the two numbers directly above it.  我的解答 func generate(numRows int) [][]int { if numRows == 0 { return nil } result := make([][]int, numRows) for i := 0; i &amp;lt; numRows; i++ { result[i] = make([]int, i+1) result[i][0] = 1 result[i][i] = 1 for j := 1; j &amp;lt; i; j++ { result[i][j] = result[i-1][j-1] + result[i-1][j] } } return result }  最优解答 无</description>
    </item>
    
    <item>
      <title>Leetcode 112</title>
      <link>https://wushaoqiang.github.io/posts/leetcode-112/</link>
      <pubDate>Mon, 29 Apr 2019 00:38:06 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/leetcode-112/</guid>
      <description>题目 Given a binary tree and a sum, determine if the tree has a root-to-leaf path such that adding up all the values along the path equals the given sum. Note: A leaf is a node with no children. Example: Given the below binary tree and sum = 22, 5 / \ 4 8 / / \ 11 13 4 / \ \ 7 2 1 return true, as there exist a root-to-leaf path 5-&amp;gt;4-&amp;gt;11-&amp;gt;2 which sum is 22.</description>
    </item>
    
    <item>
      <title>Leetcode 111</title>
      <link>https://wushaoqiang.github.io/posts/leetcode-111/</link>
      <pubDate>Mon, 29 Apr 2019 00:38:02 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/leetcode-111/</guid>
      <description>题目 Given a binary tree, find its minimum depth. The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node. Note: A leaf is a node with no children. Example: Given binary tree [3,9,20,null,null,15,7], 3 / \ 9 20 / \ 15 7 return its minimum depth = 2.  我的解答 func minDepth(root *TreeNode) int { return findMinDepth(root) } func findMinDepth(root *TreeNode) int { if root == nil { return 0 } return 1 + min(findMinDepth(root.</description>
    </item>
    
    <item>
      <title>Leetcode 110</title>
      <link>https://wushaoqiang.github.io/posts/leetcode-110/</link>
      <pubDate>Mon, 29 Apr 2019 00:38:00 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/leetcode-110/</guid>
      <description>题目 Given a binary tree, determine if it is height-balanced. For this problem, a height-balanced binary tree is defined as: a binary tree in which the depth of the two subtrees of every node never differ by more than 1. Example 1: Given the following tree [3,9,20,null,null,15,7]: 3 / \ 9 20 / \ 15 7 Return true. Example 2: Given the following tree [1,2,2,3,3,null,null,4,4]: 1 / \ 2 2 / \ 3 3 / \ 4 4 Return false.</description>
    </item>
    
    <item>
      <title>Leetcode 108</title>
      <link>https://wushaoqiang.github.io/posts/leetcode-108/</link>
      <pubDate>Sat, 27 Apr 2019 23:13:54 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/leetcode-108/</guid>
      <description>题目 Given an array where elements are sorted in ascending order, convert it to a height balanced BST. For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1. Example: Given the sorted array: [-10,-3,0,5,9], One possible answer is: [0,-3,9,-10,null,5], which represents the following height balanced BST: 0 / \ -3 9 / / -10 5  我的解答 func sortedArrayToBST(nums []int) *TreeNode { if len(nums) == 0 { return nil } mid := (len(nums) - 1) / 2 head := &amp;amp;TreeNode{Val: nums[mid]} heightHalancedTree(head, nums, 0, mid-1) heightHalancedTree(head, nums, mid+1, len(nums)-1) return head } func heightHalancedTree(t *TreeNode, nums []int, left, right int) { if left &amp;lt;= right { mid := (left + right) / 2 // fmt.</description>
    </item>
    
    <item>
      <title>Leetcode 107</title>
      <link>https://wushaoqiang.github.io/posts/leetcode-107/</link>
      <pubDate>Sat, 27 Apr 2019 21:36:47 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/leetcode-107/</guid>
      <description>题目 Given a binary tree, return the bottom-up level order traversal of its nodes&#39; values. (ie, from left to right, level by level from leaf to root). For example: Given binary tree [3,9,20,null,null,15,7], 3 / \ 9 20 / \ 15 7 return its bottom-up level order traversal as: [ [15,7], [9,20], [3] ]  我的解答 没做出来
最优解答 func levelOrderBottom(root *TreeNode) [][]int { var ret [][]int if root == nil { return nil } que := []*TreeNode{root} for len(que) &amp;gt; 0 { //先记录这一层的长度 len := len(que) var level []int //只要遍历完len长度就退出循环 for i := 0; i &amp;lt; len; i++ { // 每次遍历取队列第一个元素，因此队列遍历了一个元素之后要立即删除 node := que[0] que = que[1:] level = append(level, node.</description>
    </item>
    
    <item>
      <title>Leetcode 104</title>
      <link>https://wushaoqiang.github.io/posts/leetcode-104/</link>
      <pubDate>Sat, 27 Apr 2019 21:36:42 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/leetcode-104/</guid>
      <description>题目 Given a binary tree, find its maximum depth. The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node. Note: A leaf is a node with no children. Example: Given binary tree [3,9,20,null,null,15,7], 3 / \ 9 20 / \ 15 7 return its depth = 3.  我的解答 func maxDepth(root *TreeNode) int { if root == nil { return 0 } if root.</description>
    </item>
    
    <item>
      <title>Leetcode 101</title>
      <link>https://wushaoqiang.github.io/posts/leetcode-101/</link>
      <pubDate>Sat, 27 Apr 2019 21:36:39 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/leetcode-101/</guid>
      <description>题目 Given a binary tree, check whether it is a mirror of itself (ie, symmetric around its center). For example, this binary tree [1,2,2,3,4,4,3] is symmetric: 1 / \ 2 2 / \ / \ 3 4 4 3 But the following [1,2,2,null,3,null,3] is not: 1 / \ 2 2 \ \ 3 3 Note: Bonus points if you could solve it both recursively and iteratively.  我的解答 这题做的比较蠢，没有任何参考价值，就不放了</description>
    </item>
    
    <item>
      <title>Leetcode 100</title>
      <link>https://wushaoqiang.github.io/posts/leetcode-100/</link>
      <pubDate>Sat, 27 Apr 2019 21:36:35 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/leetcode-100/</guid>
      <description>题目 Given two binary trees, write a function to check if they are the same or not. Two binary trees are considered the same if they are structurally identical and the nodes have the same value. Example 1: Input: 1 1 / \ / \ 2 3 2 3 [1,2,3], [1,2,3] Output: true Example 2: Input: 1 1 / \ 2 2 [1,2], [1,null,2] Output: false Example 3: Input: 1 1 / \ / \ 2 1 1 2 [1,2,1], [1,1,2] Output: false  我的解答 /** * Definition for a binary tree node.</description>
    </item>
    
    <item>
      <title>Leetcode 88</title>
      <link>https://wushaoqiang.github.io/posts/leetcode-88/</link>
      <pubDate>Sat, 27 Apr 2019 21:33:45 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/leetcode-88/</guid>
      <description>题目 Given two sorted integer arrays nums1 and nums2, merge nums2 into nums1 as one sorted array. Note: The number of elements initialized in nums1 and nums2 are m and n respectively. You may assume that nums1 has enough space (size that is greater or equal to m + n) to hold additional elements from nums2. Example: Input: nums1 = [1,2,3,0,0,0], m = 3 nums2 = [2,5,6], n = 3 Output: [1,2,2,3,5,6]  我的解答 func merge(nums1 []int, m int, nums2 []int, n int) { for m &amp;gt; 0 &amp;amp;&amp;amp; n &amp;gt; 0 { if nums1[m-1] &amp;gt;= nums2[n-1] { nums1[n+m-1] = nums1[m-1] m-- } else { nums1[n+m-1] = nums2[n-1] n-- } } if m == 0 { for n &amp;gt; 0 { nums1[n-1] = nums2[n-1] n-- } return } }  解法思路是归并排序，这相当于归并排序的最后一步了</description>
    </item>
    
    <item>
      <title>Leetcode 83</title>
      <link>https://wushaoqiang.github.io/posts/leetcode-83/</link>
      <pubDate>Tue, 23 Apr 2019 22:21:39 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/leetcode-83/</guid>
      <description>题目 给定一个排序链表，删除所有重复的元素，使得每个元素只出现一次。 示例 1: 输入: 1-&amp;gt;1-&amp;gt;2 输出: 1-&amp;gt;2 示例 2: 输入: 1-&amp;gt;1-&amp;gt;2-&amp;gt;3-&amp;gt;3 输出: 1-&amp;gt;2-&amp;gt;3  我的解答 type ListNode struct { Val int Next *ListNode } func deleteDuplicates(head *ListNode) *ListNode { c := head for c != nil { if c.Next == nil { return head } if c.Val == c.Next.Val { c.Next = c.Next.Next } else { c = c.Next } } return head }  因为是个排序的链表，因此只要前后对比，再根据指针的指向来改变链表
最优解答 /** * Definition for singly-linked list.</description>
    </item>
    
    <item>
      <title>Leetcode 70</title>
      <link>https://wushaoqiang.github.io/posts/leetcode-70/</link>
      <pubDate>Tue, 23 Apr 2019 22:21:35 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/leetcode-70/</guid>
      <description>题目 假设你正在爬楼梯。需要 n 阶你才能到达楼顶。 每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？ 注意：给定 n 是一个正整数。 示例 1： 输入： 2 输出： 2 解释： 有两种方法可以爬到楼顶。 1. 1 阶 + 1 阶 2. 2 阶 示例 2： 输入： 3 输出： 3 解释： 有三种方法可以爬到楼顶。 1. 1 阶 + 1 阶 + 1 阶 2. 1 阶 + 2 阶 3. 2 阶 + 1 阶  我的解答 func climbStairs(n int) int { if n == 1 || n == 2 { return n } count2 := n / 2 result := 0 for ; count2 &amp;gt;= 0; count2-- { result += calc(n-count2, count2) } return result } //注意float的运算可能会出现一些.</description>
    </item>
    
    <item>
      <title>Leetcode 69</title>
      <link>https://wushaoqiang.github.io/posts/leetcode-69/</link>
      <pubDate>Tue, 23 Apr 2019 22:21:31 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/leetcode-69/</guid>
      <description>题目 实现 int sqrt(int x) 函数。 计算并返回 x 的平方根，其中 x 是非负整数。 由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。 示例 1: 输入: 4 输出: 2 示例 2: 输入: 8 输出: 2 说明: 8 的平方根是 2.82842..., 由于返回类型是整数，小数部分将被舍去。  我的解答 func mySqrt(x int) int { return int(math.Floor(math.Sqrt(float64(x)))) }  向下取整
最优解答 func mySqrt(x int) int { if x == 0 || x == 1 { return x } i := x / 2.0 for i*i &amp;gt; x { i = (i + x/i) / 2 } return i }  数学公式</description>
    </item>
    
    <item>
      <title>Leetcode 67</title>
      <link>https://wushaoqiang.github.io/posts/leetcode-67/</link>
      <pubDate>Tue, 23 Apr 2019 22:21:26 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/leetcode-67/</guid>
      <description>题目 给定两个二进制字符串，返回他们的和（用二进制表示）。 输入为非空字符串且只包含数字 1 和 0。 示例 1: 输入: a = &amp;quot;11&amp;quot;, b = &amp;quot;1&amp;quot; 输出: &amp;quot;100&amp;quot; 示例 2: 输入: a = &amp;quot;1010&amp;quot;, b = &amp;quot;1011&amp;quot; 输出: &amp;quot;10101&amp;quot;  我的解答 func addBinary(a string, b string) string { lengthLonger, lengthShorter := 0, 0 tmp := &amp;quot;&amp;quot; if len(a) &amp;gt; len(b) { lengthLonger = len(a) lengthShorter = len(b) } else { lengthLonger = len(b) lengthShorter = len(a) tmp = b b = a a = tmp } resultArray := make([]int, lengthLonger+1) carry := 0 for i := lengthLonger; i &amp;gt;= 0; i-- { if i &amp;gt; (lengthLonger - lengthShorter) { currentA, _ := strconv.</description>
    </item>
    
    <item>
      <title>Leetcode 66</title>
      <link>https://wushaoqiang.github.io/posts/leetcode-66/</link>
      <pubDate>Tue, 23 Apr 2019 22:21:23 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/leetcode-66/</guid>
      <description>题目 给定一个由整数组成的非空数组所表示的非负整数，在该数的基础上加一。 最高位数字存放在数组的首位， 数组中每个元素只存储一个数字。 你可以假设除了整数 0 之外，这个整数不会以零开头。 示例 1: 输入: [1,2,3] 输出: [1,2,4] 解释: 输入数组表示数字 123。 示例 2: 输入: [4,3,2,1] 输出: [4,3,2,2] 解释: 输入数组表示数字 4321。  我的解答 func plusOne(digits []int) []int { for i := len(digits) - 1; i &amp;gt;= 0; i-- { if digits[i] != 9 { digits[i]++ return digits } digits[i] = 0 } digits = append([]int{1}, digits...) return digits }  比较简单
最优解答 无
难疑点&amp;amp;核心 无</description>
    </item>
    
    <item>
      <title>Leetcode 58</title>
      <link>https://wushaoqiang.github.io/posts/leetcode-58/</link>
      <pubDate>Tue, 23 Apr 2019 22:21:19 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/leetcode-58/</guid>
      <description> 题目 给定一个仅包含大小写字母和空格 &#39; &#39; 的字符串，返回其最后一个单词的长度。 如果不存在最后一个单词，请返回 0 。 说明：一个单词是指由字母组成，但不包含任何空格的字符串。 示例: 输入: &amp;quot;Hello World&amp;quot; 输出: 5  我的解答 func lengthOfLastWord(s string) int { if s == &amp;quot;&amp;quot; { return 0 } if !strings.Contains(s, &amp;quot; &amp;quot;) { return len(s) } s = strings.TrimSpace(s) lastSpaceIndex := strings.LastIndex(s, &amp;quot; &amp;quot;) return len(s) - lastSpaceIndex - 1 }  前面两个判断是为了能够快速判断简单情况
要注意去掉头尾的空格，不然索引查找会出错
这里也调用了标准库，可能在算法上不算合规
最优解答 无
难疑点&amp;amp;核心  容易把头尾的空格忽略掉  </description>
    </item>
    
    <item>
      <title>Leetcode 53</title>
      <link>https://wushaoqiang.github.io/posts/leetcode-53/</link>
      <pubDate>Tue, 23 Apr 2019 22:21:16 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/leetcode-53/</guid>
      <description>题目 给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。 示例: 输入: [-2,1,-3,4,-1,2,1,-5,4], 输出: 6 解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。 进阶: 如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的分治法求解。  我的解答 func maxSubArray(nums []int) int { if len(nums) == 0 { return 0 } if len(nums) == 1 { return nums[0] } total := nums[0] max := nums[0] for i := 1; i &amp;lt; len(nums); i++ { if total &amp;lt; 0 { total = 0 } total += nums[i] if max &amp;lt; total { max = total } } return max }  暴力法的话，时间复杂度是O(N^2)，这里使用的方法时间复杂度O(N)</description>
    </item>
    
    <item>
      <title>Leetcode 35</title>
      <link>https://wushaoqiang.github.io/posts/leetcode-35/</link>
      <pubDate>Tue, 23 Apr 2019 22:21:07 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/leetcode-35/</guid>
      <description>题目 给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。 你可以假设数组中无重复元素。 示例 1: 输入: [1,3,5,6], 5 输出: 2 示例 2: 输入: [1,3,5,6], 2 输出: 1 示例 3: 输入: [1,3,5,6], 7 输出: 4 示例 4: 输入: [1,3,5,6], 0 输出: 0  我的解答 func searchInsert(nums []int, target int) int { isFound, idx := binarySearch(nums, 0, len(nums)-1, target) if isFound { return idx } if nums[idx] &amp;gt; target { return idx } else { return idx + 1 } } func binarySearch(nums []int, left, right, target int) (found bool, idx int) { if left &amp;lt; right { mid := (left + right) / 2 if nums[mid] == target { return true, mid } else if nums[mid] &amp;gt; target { return binarySearch(nums, left, mid-1, target) } else { return binarySearch(nums, mid+1, right, target) } } else if nums[left] == target { return true, left } else { return false, left } }  因为是个有序的数组，因此可以不用暴力搜索，这里使用比较简单的二分法，找到索引(就算没有相等的，也找到最后一个查找的索引)</description>
    </item>
    
    <item>
      <title>Leetcode 28</title>
      <link>https://wushaoqiang.github.io/posts/leetcode-28/</link>
      <pubDate>Tue, 23 Apr 2019 22:21:04 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/leetcode-28/</guid>
      <description>题目 实现 strStr() 函数。 给定一个 haystack 字符串和一个 needle 字符串，在 haystack 字符串中找出 needle 字符串出现的第一个位置 (从0开始)。如果不存在，则返回 -1。 示例 1: 输入: haystack = &amp;quot;hello&amp;quot;, needle = &amp;quot;ll&amp;quot; 输出: 2 示例 2: 输入: haystack = &amp;quot;aaaaa&amp;quot;, needle = &amp;quot;bba&amp;quot; 输出: -1 说明: 当 needle 是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。 对于本题而言，当 needle 是空字符串时我们应当返回 0 。这与C语言的 strstr() 以及 Java的 indexOf() 定义相符。  我的解答 func strStr(haystack string, needle string) int { return strings.Index(haystack, needle) }  这里可能有点赖皮，直接调用了标准库，看网上说还有一种KMP的算法，比较难，按笔者现在的进度，先刷60简单题吧，后面再考虑实现。
当然还有暴力算法，但是我宁愿使用标准库吧
最优解答 无</description>
    </item>
    
    <item>
      <title>Leetcode 27</title>
      <link>https://wushaoqiang.github.io/posts/leetcode-27/</link>
      <pubDate>Tue, 23 Apr 2019 22:21:01 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/leetcode-27/</guid>
      <description>题目 给定一个数组 nums 和一个值 val，你需要原地移除所有数值等于 val 的元素，返回移除后数组的新长度。 不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。 元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。 示例 1: 给定 nums = [3,2,2,3], val = 3, 函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。 你不需要考虑数组中超出新长度后面的元素。 示例 2: 给定 nums = [0,1,2,2,3,0,4,2], val = 2, 函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。 注意这五个元素可为任意顺序。 你不需要考虑数组中超出新长度后面的元素。 说明: 为什么返回数值是整数，但输出的答案是数组呢? 请注意，输入数组是以“引用”方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。 你可以想象内部操作如下: // nums 是以“引用”方式传递的。也就是说，不对实参作任何拷贝 int len = removeElement(nums, val); // 在函数里修改输入数组对于调用者是可见的。 // 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。 for (int i = 0; i &amp;lt; len; i++) { print(nums[i]); }  我的解答 func removeElement(nums []int, val int) int { if len(nums) == 0 { return 0 } i := 0 j := len(nums) - 1 for i &amp;lt; j { if nums[i] == val { nums[i] = nums[j] j-- } else { i++ } } if nums[i] == val { return j } return j+1 }  因为题目说只需要给索引就可以了，因此不需要创建新的内存存放，只需要用一个索引将符合要求的值和不符合要求的值划分开(所以要交换它们位置)</description>
    </item>
    
    <item>
      <title>Leetcode 26</title>
      <link>https://wushaoqiang.github.io/posts/leetcode-26/</link>
      <pubDate>Tue, 23 Apr 2019 22:20:55 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/leetcode-26/</guid>
      <description>题目 给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。 不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。 示例 1: 给定数组 nums = [1,1,2], 函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 你不需要考虑数组中超出新长度后面的元素。 示例 2: 给定 nums = [0,0,1,1,1,2,2,3,3,4], 函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。 你不需要考虑数组中超出新长度后面的元素。 说明: 为什么返回数值是整数，但输出的答案是数组呢? 请注意，输入数组是以“引用”方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。 你可以想象内部操作如下: // nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝 int len = removeDuplicates(nums); // 在函数里修改输入数组对于调用者是可见的。 // 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。 for (int i = 0; i &amp;lt; len; i++) { print(nums[i]); }  我的解答 func removeDuplicates(nums []int) int { if len(nums) == 0 || len(nums) == 1 { return len(nums) } count := 0 existMap := make(map[int]bool) for _, num := range nums { if _, exist := existMap[num]; !</description>
    </item>
    
    <item>
      <title>Leetcode 21</title>
      <link>https://wushaoqiang.github.io/posts/leetcode-21/</link>
      <pubDate>Tue, 23 Apr 2019 22:20:50 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/leetcode-21/</guid>
      <description>题目 将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 示例： 输入：1-&amp;gt;2-&amp;gt;4, 1-&amp;gt;3-&amp;gt;4 输出：1-&amp;gt;1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;4  我的解答 /** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode { l4 := &amp;amp;ListNode{} l3 := &amp;amp;ListNode{} l4.Next = l3 for l1 != nil || l2 != nil { if l1 == nil { return l2 } if l2 == nil { return l1 } if l1.</description>
    </item>
    
    <item>
      <title>Leetcode 20</title>
      <link>https://wushaoqiang.github.io/posts/leetcode-20/</link>
      <pubDate>Mon, 22 Apr 2019 00:46:01 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/leetcode-20/</guid>
      <description>题目 给定一个只包括 &#39;(&#39;，&#39;)&#39;，&#39;{&#39;，&#39;}&#39;，&#39;[&#39;，&#39;]&#39; 的字符串，判断字符串是否有效。 有效字符串需满足： 左括号必须用相同类型的右括号闭合。 左括号必须以正确的顺序闭合。 注意空字符串可被认为是有效字符串。 示例 1: 输入: &amp;quot;()&amp;quot; 输出: true 示例 2: 输入: &amp;quot;()[]{}&amp;quot; 输出: true 示例 3: 输入: &amp;quot;(]&amp;quot; 输出: false 示例 4: 输入: &amp;quot;([)]&amp;quot; 输出: false 示例 5: 输入: &amp;quot;{[]}&amp;quot; 输出: true  我的解答 笔者在做这道题的时候想的稍微复杂了点，用了递归的方法做，但速度什么的非常慢，所以不值得参考，只能说一路摸坑吧
var ( relation = map[string]string{&amp;quot;(&amp;quot;: &amp;quot;)&amp;quot;, &amp;quot;[&amp;quot;: &amp;quot;]&amp;quot;, &amp;quot;{&amp;quot;: &amp;quot;}&amp;quot;} ) func isValid(s string) bool { if len(s) == 0 { return true } if (len(s)+2)%2 != 0 { return false } if len(s) == 2 { return string(s[1]) == relation[string(s[0])] } // l := len(s) for { idx := getLastIndex(s) if idx == -1 { return false } if !</description>
    </item>
    
    <item>
      <title>Leetcode 14</title>
      <link>https://wushaoqiang.github.io/posts/leetcode-14/</link>
      <pubDate>Mon, 22 Apr 2019 00:45:56 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/leetcode-14/</guid>
      <description>题目 编写一个函数来查找字符串数组中的最长公共前缀。 如果不存在公共前缀，返回空字符串 &amp;quot;&amp;quot;。 示例 1: 输入: [&amp;quot;flower&amp;quot;,&amp;quot;flow&amp;quot;,&amp;quot;flight&amp;quot;] 输出: &amp;quot;fl&amp;quot; 示例 2: 输入: [&amp;quot;dog&amp;quot;,&amp;quot;racecar&amp;quot;,&amp;quot;car&amp;quot;] 输出: &amp;quot;&amp;quot; 解释: 输入不存在公共前缀。 说明: 所有输入只包含小写字母 a-z 。  我的解答 func longestCommonPrefix(strs []string) string { if len(strs) == 0 { return &amp;quot;&amp;quot; } if len(strs) == 1 { return strs[0] } shortestLen := len(strs[0]) for _, str := range strs { if len(str) &amp;lt; shortestLen { shortestLen = len(str) } } var finalStr string for i := 0; i &amp;lt; shortestLen; i++ { tmp := strs[0][i] for j := 1; j &amp;lt; len(strs); j++ { if tmp !</description>
    </item>
    
    <item>
      <title>Leetcode 13</title>
      <link>https://wushaoqiang.github.io/posts/leetcode-13/</link>
      <pubDate>Mon, 22 Apr 2019 00:45:53 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/leetcode-13/</guid>
      <description>题目 罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。 字符 数值 I 1 V 5 X 10 L 50 C 100 D 500 M 1000 例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做 XXVII, 即为 XX + V + II 。 通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况： I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。 X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。 给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。 示例 1: 输入: &amp;quot;III&amp;quot; 输出: 3 示例 2: 输入: &amp;quot;IV&amp;quot; 输出: 4 示例 3: 输入: &amp;quot;IX&amp;quot; 输出: 9 示例 4: 输入: &amp;quot;LVIII&amp;quot; 输出: 58 解释: L = 50, V= 5, III = 3.</description>
    </item>
    
    <item>
      <title>Leetcode 9</title>
      <link>https://wushaoqiang.github.io/posts/leetcode-9/</link>
      <pubDate>Mon, 22 Apr 2019 00:45:41 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/leetcode-9/</guid>
      <description>题目 判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。 示例 1: 输入: 121 输出: true 示例 2: 输入: -121 输出: false 解释: 从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。 示例 3: 输入: 10 输出: false 解释: 从右向左读, 为 01 。因此它不是一个回文数。 进阶: 你能不将整数转为字符串来解决这个问题吗？  我的解答 func isPalindrome(x int) bool { str := strconv.Itoa(x) for i := 0; i &amp;lt; len(str)/2; i++ { if str[i] != str[len(str)-1-i] { return false } } return true }  转换为字符串进行比较就简单很多了,直接头尾比较，时间复杂度为O(N/2),N为字符串长度</description>
    </item>
    
    <item>
      <title>Leetcode 1</title>
      <link>https://wushaoqiang.github.io/posts/leetcode-1/</link>
      <pubDate>Mon, 22 Apr 2019 00:19:11 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/leetcode-1/</guid>
      <description>题目 给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。
你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。
示例:
给定 nums = [2, 7, 11, 15], target = 9 因为 nums[0] + nums[1] = 2 + 7 = 9 所以返回 [0, 1]  我的解答 func twoSum(nums []int, target int) []int { myMap := make(map[int]int) for idx,num := range nums{ myMap[num] = idx } for idx,num := range nums{ tmp := target - num if pos,exist := myMap[tmp]; exist{ if idx &amp;gt; pos{ return []int{pos,idx} } else if idx &amp;lt; pos{ return []int{idx,pos} }else{ continue } } } return nil }  方法是通过map来达到快速查找，而不像暴力法需要每次都遍历整个数组</description>
    </item>
    
    <item>
      <title>Leetcode 7</title>
      <link>https://wushaoqiang.github.io/posts/leetcode-7/</link>
      <pubDate>Mon, 22 Apr 2019 00:19:11 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/leetcode-7/</guid>
      <description>题目 给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。 示例 1: 输入: 123 输出: 321 示例 2: 输入: -123 输出: -321 示例 3: 输入: 120 输出: 21 注意: 假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为 [−2^31, 2^31 − 1]。请根据这个假设，如果反转后整数溢出那么就返回 0。  我的解答 func reverse(x int) int { var rev int for x != 0 { lastNum := x % 10 x = x / 10 if rev &amp;gt; math.MaxInt32/10 || rev == math.MaxInt32/10 &amp;amp;&amp;amp; lastNum &amp;gt; 7 { return 0 } if rev &amp;lt; math.</description>
    </item>
    
    <item>
      <title>Leetcode 开篇</title>
      <link>https://wushaoqiang.github.io/posts/leetcode-before-start/</link>
      <pubDate>Mon, 22 Apr 2019 00:00:37 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/leetcode-before-start/</guid>
      <description> 不积跬步无以至千里，不积小流无以成江海
 作为Leetcode的开篇作，在这里希望自己能够坚持每天code一两道题(视难度而定)
以后博客应该是以这样的方式呈现
### 题目 ### 我的解答 ### 最优解答 ### 难疑点&amp;amp;核心  </description>
    </item>
    
  </channel>
</rss>