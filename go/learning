---
title: "Go语言学习笔记"
date: 2019-03-14T15:03:15+08:00
---

@[TOC](笔记)
在test文件要是以_test.go结尾，或者是在文件开头加上// +build (tag) 其中tag是自己定的，然后测试的时候在Terminal输入
# 2019.2.16
`go test -tags tagname`

构造数组可以先  `make([]int,0)`
然后  再使用函数：`func append(slice []Type, elems ...Type) []Type`

`unicode.IsLetter(r rune) bool`是判断是否为字母，而不是ASCII
`res, ok := map[...]` 中的ok变量可以用来判断key是否存在

`[]rune`可以直接转换为字符串`string([]rune)`


# 2019.2.17
==谨记！== ： __切片和Map在函数传递都是指针传递(引用)__
```go

func normalize(cleartext string) string {
	var b strings.Builder

	for _, r := range cleartext {
		if unicode.IsLetter(r) || unicode.IsDigit(r) {
			b.WriteRune(unicode.ToLower(r))
		}
	}

	return b.String()
}

```
`b.WriteRune(unicode.ToLower(r))` :可以用这种方式代替append()
`norm = fmt.Sprintf("%-[1]*s", c*r, norm)`: 其实就是将出c*r代入到[1]*形成的在右侧填充空格

|类型|默认值  |
|--|--|
| int | 0 |
|string|“”|
| bool | false |

定义一个常量：`const name type = value` value是必须要有的
枚举：Go没有枚举，用const构造，有两种方法([参考这里的](https://www.jianshu.com/p/cce89a76f6b9))
```go
func enums() {
	// 使用 const 块来实现枚举
	const (
		java = 0
		cpp  = 1
		c    = 2
	)
	fmt.Println(java, cpp, c) // 0 1 2
	// 使用 iota 块来实现自增枚举
	const (
		java1 = iota
		cpp1
		c1
	)
	fmt.Println(java1, cpp1, c1) // 0 1 2
}
```
`if contents, err := ioutil.ReadFile(filename); err != nil `:可以将要判断的变量在if块里定义并且赋值，但是这样就只能在if块里面用了

switch的case里面自带break，如果不需要break，用fallthrough可以继续下面的case里面的内容(不同判断，直接执行)
```go
switch java {
	case 0:
		fmt.Println("yes")
		fallthrough
	case 1:
		fmt.Println("no")
	}
```
```go
输出：
yes
no
```