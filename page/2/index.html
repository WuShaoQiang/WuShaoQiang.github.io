<!doctype html>
<html lang="en-us">
<head>

    <meta charset="utf-8">
    <meta name="generator" content="Hugo 0.40.1" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <title>Gavin&#39;s Blog | Gopher，后端开发，网络基础，WEB协议、架构、存储、缓冲、安全，学习笔记</title>
    <meta property="og:title" content="Gavin&#39;s Blog | Gopher，后端开发，网络基础，WEB协议、架构、存储、缓冲、安全，学习笔记">
    <meta property="og:type" content="website">
    <meta name="Keywords" content="Golang,Gavin,Blog">
    <meta name="description" content="">
    <meta property="og:url" content="https://wushaoqiang.github.io/">
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">

    <link rel="stylesheet" href="/css/normalize.css">
    
    <link rel="stylesheet" href="/css/style.css">
    <link rel="alternate" type="application/rss+xml" href="https://wushaoqiang.github.io/index.xml" title="Gavin's Blog" />
    <script type="text/javascript" src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script>

    


    
    
</head>


<body>
<header id="header" class="clearfix">
    <div class="container">
        <div class="col-group">
            <div class="site-name ">
                
                    <h1>
                        <a id="logo" href="https://wushaoqiang.github.io">
                            Gavin&#39;s Blog
                        </a>
                    </h1>
                
                <p class="description">Gopher，后端开发，网络基础，WEB协议、架构、存储、缓冲、安全，学习笔记</p>
            </div>
            <div>
                <nav id="nav-menu" class="clearfix">
                    <a class="current" href="https://wushaoqiang.github.io">首页</a>
                    
                    <a  href="https://wushaoqiang.github.io/archives/" title="归档">归档</a>
                    
                    <a  href="https://wushaoqiang.github.io/about/" title="关于">关于</a>
                    
                </nav>
            </div>
        </div>
    </div>
</header>


<div id="body">
    <div class="container">
        <div class="col-group">

            <div class="col-8" id="main">
                <div class="res-cons">
                    
                        <article class="post">
                            <header>
                                <h1 class="post-title">
                                    <a href="https://wushaoqiang.github.io/posts/linux/linux-process-life-cycle/" title="Linux Process Life Cycle" >Linux Process Life Cycle</a>
                                </h1>
                            </header>
                            <date class="post-meta meta-date">
                                2019年10月21日
                            </date>
                            
                            <div class="post-meta">
                                <span>|</span>
                                
                                <span class="meta-category"><a href="https://wushaoqiang.github.io/categories/Linux">Linux</a></span>
                                
                            </div>
                            
                            <div class="post-content">
                                我们知道，现在的操作系统，给用户的感觉都是多任务执行的，可能执行的任务(Process)要比CPU还多
这个时候电脑程序看起来还是一起跑的
在Linux的Process Management里面，通过不断的让Scheduler交换执行进程，就可以实现这样的效果
State 这里先来了解一下关于进程生命周期的几个状态
 R(Running or Runnable)是指这个Process正在占用一个CPU，处于执行状态。或者，它处于可被执行的状态
 S(Interruptible Sleep)这种状态表示进程正在等待事件发生，这种情况下是可接收信号的，等到等待的时间发生再次满足Runnable的条件时，会置为R
 D(Uninterruptible Sleep)与上面的区别，这种状态是无法接收信号的
 T(Stopped)这里是暂停或者停止，比如在使用debugger的时候
 Z(Zombie)状态发生在进程被结束，但是数据还有部分残留在Process table里，这个时候在等待父进程调用wait4
  这些状态在linux源码里的linux/sched.h里面有定义
181 #define TASK_RUNNING 0 182 #define TASK_INTERRUPTIBLE 1 183 #define TASK_UNINTERRUPTIBLE 2 184 #define __TASK_STOPPED 4 185 #define __TASK_TRACED 8 186 /* in tsk-&gt;exit_state */ 187 #define EXIT_ZOMBIE 16 188 #define EXIT_DEAD 32 189 /* in tsk-&gt;state again */ 190 #define TASK_DEAD 64 191 #define TASK_WAKEKILL 128 192 #define TASK_WAKING 256 193 #define TASK_STATE_MAX 512  其中TRACED是调用ptrace时用的，主要是为了区分STOPPED……
                            </div>
                            <p class="readmore"><a href="https://wushaoqiang.github.io/posts/linux/linux-process-life-cycle/">阅读全文</a></p>
                        </article>
                    
                        <article class="post">
                            <header>
                                <h1 class="post-title">
                                    <a href="https://wushaoqiang.github.io/posts/life/0-offer-campus-recruitment/" title="我的0-Offer秋招之路" >我的0-Offer秋招之路</a>
                                </h1>
                            </header>
                            <date class="post-meta meta-date">
                                2019年10月15日
                            </date>
                            
                            <div class="post-meta">
                                <span>|</span>
                                
                                <span class="meta-category"><a href="https://wushaoqiang.github.io/categories/%E4%BA%BA%E7%94%9F%E7%BB%8F%E5%8E%86">人生经历</a></span>
                                
                            </div>
                            
                            <div class="post-content">
                                今天算是我秋招的一个结束点了吧，至今还是0 offer，说不难受是假的，但是说很难受好像也没有，因为从中也收获不少。而且我相信秋招的失败经历也不会让我翻不了身(我是咸鱼)
大概经过 我秋招开始的比较晚，是9月18号才开始投简历，那时候很多公司都截止收简历了，所以机会相对较少。再加上不愿意北上，所以只能在深圳和广州两地选择
因为还在实习，所以不得不请了大半个月假来准备笔试面试相关东西
投完简历第二天就开始笔试了，写的也是一塌糊涂，所以笔试这东西还是得提前准备的，就像临考的复习一样，虽然不是长久之计，但是很有效
最多笔试面试的时候还是九月份，下面说一下自己在这些方面的不足和反省吧
笔试 笔试大多考的就是数据结构和算法题，平时少刷算法题的会比较吃亏，这里没什么诀窍，也没有捷径，只能多刷题，一般最少提前半个月刷题，而且刷的题不要太简单。
比如Leetcode上的easy题大多数都非常简单，最起码要刷medium以上的
这里笔者因为时间比较少，再加上之前没有太多积累，很多连笔试都没过
面试 面试是我最痛的伤，我想进的公司基本上都挂在面试上了
状态不好 面试中，状态也很重要，因为很可能很简单的东西，在状态不好的时候会说的一塌糊涂。就像笔者背问了TCP和UDP的区别这种已经准备过的问题时，因为状态不好答的也不是特别令人满意
不够深入 笔者觉得自己在这方面做的非常差，很多东西停留在了表层，没有深入到细节实现上，这样在面试官理解上，可能只是了解，并不会实际的操作
举个例子，面试官问某某项目的某某部分的时候，如果只说了大概思路而没有更具体的东西，可能会让面试官觉得你只是背熟了这个架构，并没有体现出技术的东西
知识面窄 我相信这是很多人都会有的问题，对于一早定位在某一领域上的同学来说，知识面会宽很多。比如说计算机科学，很多非科班的人(包括我)接触到的东西会比较窄(可能有时间关系，可能有个人关系)，这个时候面试官所掌握的技术栈很可能没有太多和你重叠的。意味着他问的东西，很多你都没听说过，这就非常糟糕(所以面试也带有一些运气在里面)
我的感受 在面试的时候，我感觉我很容易会混乱，经常说出来的东西并不是面试官想要的答案(说完后我才发现)，在项目上没有体现细节(我最失败的地方)
一些给自己的建议
 早准备
 准备多一些细节以及亮点
 平时多看开源代码(为了寻找共同的技术栈)
 对基础的东西要非常熟练(网络、操作系统等)
 多努力
  0 offer倒是敲响了我的警钟，也让我明白了自己的大致方向。说实话，我差点就完全错过了整个秋招，还好还是尝试了，感觉还是不亏的
我觉得我自己 不想说自己因为结果不好而不行，我觉得我还是具备成为一个优秀的engineer的因素。。。吧……
                            </div>
                            <p class="readmore"><a href="https://wushaoqiang.github.io/posts/life/0-offer-campus-recruitment/">阅读全文</a></p>
                        </article>
                    
                        <article class="post">
                            <header>
                                <h1 class="post-title">
                                    <a href="https://wushaoqiang.github.io/posts/database/raft/etcd-raft-2/" title="Etcd Raft 源码实现-2" >Etcd Raft 源码实现-2</a>
                                </h1>
                            </header>
                            <date class="post-meta meta-date">
                                2019年10月13日
                            </date>
                            
                            <div class="post-meta">
                                <span>|</span>
                                
                                <span class="meta-category"><a href="https://wushaoqiang.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93">数据库</a></span>
                                
                            </div>
                            
                            <div class="post-content">
                                趁着周末有空，抽几个小时看看源码，这次看的是raftexample
这是一个raft的简单实现，etcd/raft只是实现了raft的主要算法(例如选举、状态机等)
 To keep the codebase small as well as provide flexibility, the library only implements the Raft algorithm; both network and disk IO are left to the user. Library users must implement their own transportation layer for message passing between Raft peers over the wire. Similarly, users must implement their own storage layer to persist the Raft log and state.
 因此我觉得先看一个完整的实例可能对raft的整个逻辑会有一个清晰的认识
因此我们可以先从怎么用etcd的raft来入手
这篇blog的范围仅在raftexample这部分，超过这部分的代码(例如raft和node这些细节，在后面的blog会慢慢接触)暂时不会说
看看大体结构 ├── doc.go ├── httpapi.……
                            </div>
                            <p class="readmore"><a href="https://wushaoqiang.github.io/posts/database/raft/etcd-raft-2/">阅读全文</a></p>
                        </article>
                    
                        <article class="post">
                            <header>
                                <h1 class="post-title">
                                    <a href="https://wushaoqiang.github.io/posts/database/raft/etcd-raft-1/" title="Etcd Raft 源码实现-1" >Etcd Raft 源码实现-1</a>
                                </h1>
                            </header>
                            <date class="post-meta meta-date">
                                2019年10月13日
                            </date>
                            
                            <div class="post-meta">
                                <span>|</span>
                                
                                <span class="meta-category"><a href="https://wushaoqiang.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93">数据库</a></span>
                                
                            </div>
                            
                            <div class="post-content">
                                之前说过的结合源码来学习Raft的blog来了！
这次想尝试写成一个系列吧，因为代码还是有一定量的，大概估计要半个月～一个月的时间(中间太多事情了)
今天来开第一篇，说个稍微简单点的MemoryStorage
MemoryStorage只是一种实现，并不是所有实现都应该和它一样
在raft/storage.go里面就是全部是实现，逻辑也比较简单，因为代码实现比较简单，主要说一下这个的用法吧
先看一下结构体
type MemoryStorage struct { // 上锁 sync.Mutex // 这个暂时可以先不理会 hardState pb.HardState // Snapshot是一个快照 snapshot pb.Snapshot // 这里就是存放log entry的地方 ents []pb.Entry }  这里顺带说一下，如果没看过Raft Paper或者刚接触Raft，还是建议先理解一些概念，因为代码里有很多名词都是相关的
这里我只会举一些稍微难一点的函数(有些太简单就不说了)
取数据的Storage // Entries implements the Storage interface. func (ms *MemoryStorage) Entries(lo, hi, maxSize uint64) ([]pb.Entry, error) { // 先上锁 ms.Lock() defer ms.Unlock() // offset是相对数组而言的，在这里，数组的第一个元素，也就是ents[0]是不用做数据的 offset := ms.ents[0].Index // 这一步可以验证上面说的ents[0]不包含数据的说法 // 如果lo == offset，那么会发生Compact错误 // Compact错误代表着数据不存在(被清理了) if lo &lt;= offset { return nil, ErrCompacted } // 因为是[lo,hi) 所以，hi是不包含的 // 这里的边界条件不加=，也是因为这个 if hi &gt; ms.……
                            </div>
                            <p class="readmore"><a href="https://wushaoqiang.github.io/posts/database/raft/etcd-raft-1/">阅读全文</a></p>
                        </article>
                    
                        <article class="post">
                            <header>
                                <h1 class="post-title">
                                    <a href="https://wushaoqiang.github.io/posts/interview/interview3/" title="Interview3" >Interview3</a>
                                </h1>
                            </header>
                            <date class="post-meta meta-date">
                                2019年10月11日
                            </date>
                            
                            <div class="post-meta">
                                <span>|</span>
                                
                                <span class="meta-category"><a href="https://wushaoqiang.github.io/categories/%E9%9D%A2%E8%AF%95">面试</a></span>
                                
                            </div>
                            
                            <div class="post-content">
                                稍微总结一下今天面试遇到的一些问题以及自己的不足，再接再厉
感觉这篇blog有点像日记了。。。
Link 在前面时间里主要是问了三道和链表相关的题，可能因为平时少练题的缘故，答的不太好
LRU缓存算法 我之前没有听过LRU(Latest Related Used)
在假设一个场景下，一个值被请求，那么下面很有可能会再次多次请求这个值，那么用这种算法能够cache住最新的值，使得效率提高
还好面试官通过解释，我才大概懂得这个LRU是用来干嘛的(但是当时还是没太多思路)
现在用代码大概描述一下
package main type DLinkNode struct { key int val int next *DLinkNode prev *DLinkNode } func addNodeAfter(prev, node *DLinkNode) { node.prev = prev node.next = prev.next if prev.next != nil { prev.next.prev = node } prev.next = node } func removeNode(node *DLinkNode) { if node.prev != nil { node.prev.next = node.next } if node.next != nil { node.next.prev = node.……
                            </div>
                            <p class="readmore"><a href="https://wushaoqiang.github.io/posts/interview/interview3/">阅读全文</a></p>
                        </article>
                    
                        <article class="post">
                            <header>
                                <h1 class="post-title">
                                    <a href="https://wushaoqiang.github.io/posts/golang/go-scheduler/" title="Go Scheduler" >Go Scheduler</a>
                                </h1>
                            </header>
                            <date class="post-meta meta-date">
                                2019年10月10日
                            </date>
                            
                            <div class="post-meta">
                                <span>|</span>
                                
                                <span class="meta-category"><a href="https://wushaoqiang.github.io/categories/Golang">Golang</a></span>
                                
                            </div>
                            
                            <div class="post-content">
                                为什么要Go Scheduler Scheduler是为了实现用户态的线程(协程)的调度，这也也就是实现更加轻量级的并发单元，这也是为什么goroutine的并发数量能够那么多的原因
Goroutine在哪里运行 Goroutine看似每个都在并发运行，其实它们还是通过Scheduler来调度到内核态的线程来执行的，也就是说Goroutine其实也是在内核态的thread里跑的
我们知道，如果创建过多的thread，会有很大的负担，因为内核态的线程不是轻量级的，会消耗不少的系统资源，因此我们内核态的线程和用户态的协程是一个N:M的关系，其中N &lt;= M
如何Schedule goroutine在创建时会被存储在一个local run queue里面，go scheduler就是在这个queue的头拿goroutine，放到内核线程去执行
同理，创建的时候放入local run queue的尾部
并且每一个Kernel Thread 对应了一个local run queue
Kernel Thread的数量 为了均衡性能以及资源的利用，Go Scheduler实现了Number(Core) == Number(Kernel Thread)这样的一个模式
这样在每一个Core上都创建一个Kernel Thread，并且重用这个Thread，这样既能达到充分利用硬件的性能来并行执行
要注意，这里是并行，不是并发
重用也是协程轻量级的一个很大的因素，充分的减少了创建和销毁Kernel Thread
负载均衡 因为每一个Kernel Thread对应了一个local run queue，那么就会有分配不均匀的情况。某些队列排队的goroutine特别多，某些特别少，导致有些Kernel Thread会闲置
这个时候Go scheduler会从繁忙的队列中*偷*一些goroutine放在闲的队列
长时间运行的goroutine 为了不让长时间的goroutine一直霸占着Thread，Go Scheduler会把长时间运行的goroutine在合适的时候停下来，并且将这个goroutine放入global run queue
通过sysmon检测这个长时间运行的goroutine
global run queue的优先级要比local run queue低，因此local run queue里面的goroutine就会被执行到
block 在某一个thread被block的时候，这个thread不被算在limit上，也就是说，这个时候我们可以先创建一个Thread，去运行别的goroutine……
                            </div>
                            <p class="readmore"><a href="https://wushaoqiang.github.io/posts/golang/go-scheduler/">阅读全文</a></p>
                        </article>
                    
                        <article class="post">
                            <header>
                                <h1 class="post-title">
                                    <a href="https://wushaoqiang.github.io/posts/computer-network/get-vs-post/" title="GET VS POST" >GET VS POST</a>
                                </h1>
                            </header>
                            <date class="post-meta meta-date">
                                2019年10月9日
                            </date>
                            
                            <div class="post-meta">
                                <span>|</span>
                                
                                <span class="meta-category"><a href="https://wushaoqiang.github.io/categories/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80">网络基础</a></span>
                                
                            </div>
                            
                            <div class="post-content">
                                趁着晚上还有点时间，积累一下GET和POST的区别
为什么不说其它方法？还是因为这两种比较容易让人混淆吧
有时候在一个项目(一般是写的不太好的项目)的时候，你会惊奇的发现为什么GET请求需要解析里面的请求主体
这个时候其实很大的一个可能就是API设计的不好
我们都懂 当别人问我们他俩的区别是什么的时候，我们可能很快想到的是
 GET是拿数据，POST是发送数据  其实无论是GET还是POST，其实都是HTTP里面的一个方法(只是一个字段不同而已)，说到底，无论是GET还是POST都是要被封装到HTTP报文里面的，HTTP同理也是走TCP/IP的
从底层角度来讲 去看一下HTTP的报文你会发现，GET和POST其实真的没区别，那么为什么会产生出这两种请求方法呢
我猜测这其实就是大家根据现实的一些用法设计出来的公用的方案吧，相当于行内的一套规矩，大家可以遵守这一规矩来达到共识
我们通常来说，GET的请求主体是空的，但其实我们也可以加东西进去。因此不要觉得GET和POST是在底层上的不同，它们只是大家规矩上认同的不同方式
怎么用 因为这一规矩，各大浏览器厂商默认大家的使用方法都是按照规矩来的，因此浏览器能够根据这个约定来对不同的请求方法来做优化，比如说：
 一般来说，我们浏览器会缓存一些GET请求返回的东西，因为我们默认GET请求在一般情况下是不变的，因此结果在短暂的时间内也是不变的，这样能够有效的加快页面的加载。同理，一般是不缓存POST请求的，因为POST的数据是千变万化的。
 需要携带参数的GET一般是通过URL来传递，而POST一般是通过请求主体来传递
  看到这里你会发现，用法是根据职责来区分的，因此我们在用的时候只需要考虑这个HTTP请求方法的职能是什么？是否符合这个场景需求？
这样设计的API才能够被大家所接收
触类旁通 从上面的方法可以看到，通过分析其底层原理就能够分析出一些规律，可以看出它们的本质
通过这方法，我们来看看TCP UDP的区别
看看它们的底层，都是走IP协议的，因此不同之处在哪表现？
其实就在它们的报文段，了解过它们俩的同学肯定能够发现TCP和UDP的报文段有很大的不同
其实所说的TCP拥塞处理，流量管理等等性质，都是通过报文段来获取信息并且处理这些信息(比如超时，ACK，还有一些标志位等)
所以说，在分析两个相似的东西的时候，我们可以先看看它们的底层基础是否一样，如果是一样的，那么我们就只需要关注它们上层有什么不一样了。……
                            </div>
                            <p class="readmore"><a href="https://wushaoqiang.github.io/posts/computer-network/get-vs-post/">阅读全文</a></p>
                        </article>
                    
                        <article class="post">
                            <header>
                                <h1 class="post-title">
                                    <a href="https://wushaoqiang.github.io/posts/database/spanner/spanner-summary/" title="Spanner Summary" >Spanner Summary</a>
                                </h1>
                            </header>
                            <date class="post-meta meta-date">
                                2019年10月8日
                            </date>
                            
                            <div class="post-meta">
                                <span>|</span>
                                
                                <span class="meta-category"><a href="https://wushaoqiang.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93">数据库</a></span>
                                
                            </div>
                            
                            <div class="post-content">
                                近些日子，有来来回回看一些关于Database的论文，也都是一些非常经典的论文。
有关Spanner的论文可以直接在Google上获得，这里想根据自己所看所想做些笔记，记录一些思路
并且这个blog只会将一些复杂的东西尽量简单化，重在理解，想要深入细节还需参考Paper
先说总结 在Paper的总结中说到
 One aspect of our design stands out: the linchpin(核心) of Spanner&rsquo;s feature set is TrueTime.
 Spanner这个系统是和时钟强绑定在一起的。
在我们日常的分布式系统里面，时钟是不可靠的，因为时钟有可能会发生回退，振荡等不稳定现象，并且在分布式下，可能会由于地域问题，取得的时间也可能有所偏差(取得的时间戳可能来自不同的源)。
因此在一般的分布式系统下，我们不会去依赖时钟
Spanner依赖这个时钟意味着Google需要完全保证时钟的稳定性(出错概率无限接近0)，这在后面会稍微提及一下
介绍一下 这里只介绍Spanner较为突出的点
 全球性分布式
 可控的数据分布
 强一致性(一般系统可能是最终一致性)
 类SQL
 强大的Transaction
  我们一般接触的分布式可能是全国性的，Spanner做Global-Distributed的原因可能是为了容忍国家战乱和自然灾害这些因素吧
可控的数据分布指的是，Spanner能够控制数据具体存放在哪个地方，这样能够更好的实现Locality，减少延迟。并且它还能把经常在一起访问的数据放在同一个地方，提高性能
为了解决BigTable的一致性问题(BigTable只提供最终一致性)，Spanner使用了2PC(Two-Phase-Commit)，来保证强一致性。由于2PC会有比较大的开销，不过Spanner还是坚持用2PC，把开销留给使用者来考虑(少用这样的事务就能减少开销)
类SQL，也是为了解决大家对BigTable数据查询的需求，Spanner需要提供像SQL这样的结构化查询语句(和SQL有些不一样)
对于单机的Transaction已经不足以满足现在的需求了，由于数据可能会分布在不同的机器上，因此Spanner能够提供跨多行的Transaction(有可能这个多行分布在不同的地方),相对BigTable的单行Transaction而言更为强大
Spanner还有更多的细节以及特性，可以参照Paper去理解
数据的结构 虽然Spanner在说BigTable只提供了KV的结构，自己则要有关系型的结构，其实不然，Paper中指出，Spanner还是利用了映射的关系来存储数据，主要是分为
 Primary Key
 Non-Primary Key
  其中映射关系就是 Primary Key的Column指向Non-Primary Key Column
文中解释这样的好处是
 it lets applications control data locality through their choices of keys……
                            </div>
                            <p class="readmore"><a href="https://wushaoqiang.github.io/posts/database/spanner/spanner-summary/">阅读全文</a></p>
                        </article>
                    
                        <article class="post">
                            <header>
                                <h1 class="post-title">
                                    <a href="https://wushaoqiang.github.io/posts/database/theory/week-isolation/" title="Week Isolation" >Week Isolation</a>
                                </h1>
                            </header>
                            <date class="post-meta meta-date">
                                2019年10月7日
                            </date>
                            
                            <div class="post-meta">
                                <span>|</span>
                                
                                <span class="meta-category"><a href="https://wushaoqiang.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93">数据库</a></span>
                                
                            </div>
                            
                            <div class="post-content">
                                之前在写Transaction的时候有简单介绍过一些Isolation
对于事务来说，Isolation是一个很重要的性质，随着应用的高并发，数据库对冲突的处理显得尤为重要，这blog里面简单说一些Week Isolation
Week Isolation之所以Week是相对Serializability而言
因为Serializability能够将并发处理转换为串行处理
Read Committed 它保证了两点
 只读committed data
 只覆盖committed data
  也就是No dirty read, No dirty write
先来介绍一下脏读(dirty read)和脏写(dirty write)
在并发的情况下，有可能会有许多事务在并行的执行，如果一个Tx(事务)读到了另一个还没有committed(或者abort)的Tx就称之为Dirty Read。
同理，覆盖了还未committed data就称为Dirty Write
我们要防止这两种情况出现可以使用Read Committed这种Isolation
它主要采取了下面的措施
 对于脏写，采用了Row-Lock，在要写这个Row的时候，先获取Lock再执行操作，操作完(committed或者abort)就释放，理解起来也比较简单
 对于脏读，为了提高性能，避免了Lock的方式，因为读取可能会涉及大量的Row(一个很大的Scan)，因此用了Version的概念。如果一个事务正在执行写操作，那么会有一个Old Value和一个New Value，其中Old Value是已经committed过了的，所以返回Old Value。等到写操作committed或者aborted，就只剩下一个committed的value
  不足的地方 由于读的是可以和写并发进行的，因此在执行Compare and Set操作的时候，会发生问题
因为Compare的时候是读，这个时候如果是符合条件的，那么就会执行写操作。如果有一个并行的写操作正在修改Compare的条件导致Compare不符合写入的条件，但是由于读的时候和写的时候不是一个时刻，因此会产生问题。
书中举了个例子帮助理解
 医生A和B必须要有一个人值班，这个时候两个医生都不想值班，他们需要通过网上的系统进行申请，医生A在申请的时候，系统看到剩余人数是2，因此批准A不值班。同一个时刻，医生B执行操作的时候也看到剩余人数是2，因此也批准。这个时候两个医生都申请成功了，这就违反了值班的原则
 优点 很明显，这个Isolation的优点是性能好，能够并行执行Read和Write
很多数据库默认的Isolation也是这个
Snapshot Isolation 这也是一个比较热门，应用比较广泛的一个Isolation
前面介绍的Read Committed给我们提供了很多很好的功能，但是在某些特定场景下还是会发生问题
我们知道，上一个Isolation的读写是并发执行的，当我们想要备份一个大的数据库文件的时候，我们的读操作会执行很久，这个时候它如果还在继续接收写操作，可能我们保存的数据库文件就会有问题。通常来说我们希望存下来的备份文件是某一个时刻固有的
同理，我们在分析某一个时刻之前的数据时，可能会query很多数据，但我们只想看到这个时刻之前的数据
这个时候Snapshot Isolation可以解决这类问题
每当一个Tx开始的时候，它会保存一份当前时刻数据库的快照，所有的读操作都会在这个快照里面，这个快照是肯定不会被修改的
实现 和Read Committed类似，Write也是用了Lock来避免冲突……
                            </div>
                            <p class="readmore"><a href="https://wushaoqiang.github.io/posts/database/theory/week-isolation/">阅读全文</a></p>
                        </article>
                    
                        <article class="post">
                            <header>
                                <h1 class="post-title">
                                    <a href="https://wushaoqiang.github.io/posts/database/theory/column-oriented-storage/" title="Column Oriented Storage" >Column Oriented Storage</a>
                                </h1>
                            </header>
                            <date class="post-meta meta-date">
                                2019年10月7日
                            </date>
                            
                            <div class="post-meta">
                                <span>|</span>
                                
                                <span class="meta-category"><a href="https://wushaoqiang.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93">数据库</a></span>
                                
                            </div>
                            
                            <div class="post-content">
                                背景 现在大多数的Database都是Row Oriented，因为Row Oriented对OLTP系统的操作友好
但是对于OLAP系统，常常是需要查询上百万条数据，因此Row Oriented的数据库会因为要Load大量数据导致大量的IO
但其实很多的数据可能都是没有用到的，只是为了用一两个Column(Field)而把所有都导入到内存并不是一个好买卖
不仅如此，把全部数据Load到内存上，还需要对其进行过滤，因此在计算资源上也会有一定的开销
因此诞生了Column Oriented。
不同 与Row Oriented不同的是，数据库会把列的数据在硬件上存的更相近，这样在读取的时候会明显块很多(Row Oriented是按Row来存到硬盘上)
其实Column Oriented也很简单，把Column存在一个文件上，Scan的时候就不用都扫描了
其它优势 在除了少读取无用数据之外，还有一些其它的优势值得我们认识
压缩 在一般情况下，一个Column的数据类型都是一样的，而且有很多时候内容也是非常相近的，这个时候是压缩最容易得到有效利用的时候(理论上，越相近的数据压缩越好)
有一种对比较好的压缩方法叫Bitmap，这里我不打算讲这个，有兴趣的可以查阅相关资料
更好的利用CPU缓存 如果是按照Row来读取数据，CPU的数据缓存可能有大部分都是存储我们不用到的数据
相反，当数据的有效率提升了，CPU的缓存利用率也会大大提升，因此可以加快处理速度
排序 为了再进一步提高读取的性能，我们还可以针对Column做排序
一般来说我们可以指定一两个索引进行排序，以至于指定哪个需要根据业务需求来决定
比如业务经常会按照时间来分析一些数据，那么我会在date字段上做排序，这样我在取数据的时候就非常快速
有可能我的业务需要按照不同的排序，这个时候也有一个参考的方法
通过Replication，在每一个副本集上按照不同的排序方式进行存放，然后按照业务需求去取对应的副本集……
                            </div>
                            <p class="readmore"><a href="https://wushaoqiang.github.io/posts/database/theory/column-oriented-storage/">阅读全文</a></p>
                        </article>
                    

                    


<ol class="page-navigator">
    
    <li class="prev">
        <a href="https://wushaoqiang.github.io/">上一页</a>
    </li>
    

    
    <li >
        <a href="https://wushaoqiang.github.io/">1</a>
    </li>
    
    <li  class="current">
        <a href="https://wushaoqiang.github.io/page/2/">2</a>
    </li>
    
    <li >
        <a href="https://wushaoqiang.github.io/page/3/">3</a>
    </li>
    
    <li >
        <a href="https://wushaoqiang.github.io/page/4/">4</a>
    </li>
    
    <li >
        <a href="https://wushaoqiang.github.io/page/5/">5</a>
    </li>
    
    <li >
        <a href="https://wushaoqiang.github.io/page/6/">6</a>
    </li>
    
    <li >
        <a href="https://wushaoqiang.github.io/page/7/">7</a>
    </li>
    
    <li >
        <a href="https://wushaoqiang.github.io/page/8/">8</a>
    </li>
    
    <li >
        <a href="https://wushaoqiang.github.io/page/9/">9</a>
    </li>
    
    <li >
        <a href="https://wushaoqiang.github.io/page/10/">10</a>
    </li>
    
    <li >
        <a href="https://wushaoqiang.github.io/page/11/">11</a>
    </li>
    
    <li >
        <a href="https://wushaoqiang.github.io/page/12/">12</a>
    </li>
    
    <li >
        <a href="https://wushaoqiang.github.io/page/13/">13</a>
    </li>
    
    <li >
        <a href="https://wushaoqiang.github.io/page/14/">14</a>
    </li>
    
    <li >
        <a href="https://wushaoqiang.github.io/page/15/">15</a>
    </li>
    
    <li >
        <a href="https://wushaoqiang.github.io/page/16/">16</a>
    </li>
    
    <li >
        <a href="https://wushaoqiang.github.io/page/17/">17</a>
    </li>
    
    <li >
        <a href="https://wushaoqiang.github.io/page/18/">18</a>
    </li>
    
    <li >
        <a href="https://wushaoqiang.github.io/page/19/">19</a>
    </li>
    
    <li >
        <a href="https://wushaoqiang.github.io/page/20/">20</a>
    </li>
    
    <li >
        <a href="https://wushaoqiang.github.io/page/21/">21</a>
    </li>
    
    <li >
        <a href="https://wushaoqiang.github.io/page/22/">22</a>
    </li>
    
    <li >
        <a href="https://wushaoqiang.github.io/page/23/">23</a>
    </li>
    
    <li >
        <a href="https://wushaoqiang.github.io/page/24/">24</a>
    </li>
    
    <li >
        <a href="https://wushaoqiang.github.io/page/25/">25</a>
    </li>
    
    <li >
        <a href="https://wushaoqiang.github.io/page/26/">26</a>
    </li>
    
    <li >
        <a href="https://wushaoqiang.github.io/page/27/">27</a>
    </li>
    
    <li >
        <a href="https://wushaoqiang.github.io/page/28/">28</a>
    </li>
    
    <li >
        <a href="https://wushaoqiang.github.io/page/29/">29</a>
    </li>
    
    <li >
        <a href="https://wushaoqiang.github.io/page/30/">30</a>
    </li>
    
    <li >
        <a href="https://wushaoqiang.github.io/page/31/">31</a>
    </li>
    
    <li >
        <a href="https://wushaoqiang.github.io/page/32/">32</a>
    </li>
    

    
    <li class="next">
        <a href="https://wushaoqiang.github.io/page/3/">下一页</a>
    </li>
    
</ol>



                </div>
            </div>

            <div id="secondary">
    <section class="widget">
        <form id="search" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank" _lpchecked="1">
      
      <input type="text" name="q" maxlength="20" placeholder="Search">
      <input type="hidden" name="sitesearch" value="https://wushaoqiang.github.io">
      <button type="submit" class="submit icon-search"></button>
</form>
    </section>
    
    <section class="widget">
        <h3 class="widget-title">最近文章</h3>
<ul class="widget-list">
    
    <li>
        <a href="https://wushaoqiang.github.io/posts/linux/linux-interrupt/" title="Linux Interrupt Top Halves">Linux Interrupt Top Halves</a>
    </li>
    
    <li>
        <a href="https://wushaoqiang.github.io/posts/linux/linux-system-call/" title="Linux System Call">Linux System Call</a>
    </li>
    
    <li>
        <a href="https://wushaoqiang.github.io/posts/front-end/different-encoding/" title="Different Encoding">Different Encoding</a>
    </li>
    
    <li>
        <a href="https://wushaoqiang.github.io/posts/linux/linux-memory-management/" title="Linux Memory Management">Linux Memory Management</a>
    </li>
    
    <li>
        <a href="https://wushaoqiang.github.io/posts/linux/linux-process-scheduler/" title="Linux Process Scheduler">Linux Process Scheduler</a>
    </li>
    
    <li>
        <a href="https://wushaoqiang.github.io/posts/linux/linux-process-dofork/" title="Linux Process do_fork">Linux Process do_fork</a>
    </li>
    
    <li>
        <a href="https://wushaoqiang.github.io/posts/linux/linux-process-fork/" title="Linux Process Fork&amp;Clone">Linux Process Fork&amp;Clone</a>
    </li>
    
    <li>
        <a href="https://wushaoqiang.github.io/posts/linux/linux-process-identifier/" title="Linux Process Identifier">Linux Process Identifier</a>
    </li>
    
    <li>
        <a href="https://wushaoqiang.github.io/posts/linux/linux-namespace/" title="Linux Namespace">Linux Namespace</a>
    </li>
    
    <li>
        <a href="https://wushaoqiang.github.io/posts/linux/linux-process-types/" title="Linux Process Types">Linux Process Types</a>
    </li>
    
</ul>
    </section>

    

    <section class="widget">
        <h3 class="widget-title">分类</h3>
<ul class="widget-list">
    
    <li>
        <a href="https://wushaoqiang.github.io/categories//">(1)</a>
    </li>
    
    <li>
        <a href="https://wushaoqiang.github.io/categories/Algorithm/">Algorithm(2)</a>
    </li>
    
    <li>
        <a href="https://wushaoqiang.github.io/categories/Definition/">Definition(1)</a>
    </li>
    
    <li>
        <a href="https://wushaoqiang.github.io/categories/English/">English(2)</a>
    </li>
    
    <li>
        <a href="https://wushaoqiang.github.io/categories/Favorite/">Favorite(1)</a>
    </li>
    
    <li>
        <a href="https://wushaoqiang.github.io/categories/Front-end/">Front-end(14)</a>
    </li>
    
    <li>
        <a href="https://wushaoqiang.github.io/categories/Git/">Git(2)</a>
    </li>
    
    <li>
        <a href="https://wushaoqiang.github.io/categories/Golang/">Golang(50)</a>
    </li>
    
    <li>
        <a href="https://wushaoqiang.github.io/categories/Hugo/">Hugo(1)</a>
    </li>
    
    <li>
        <a href="https://wushaoqiang.github.io/categories/Leetcode/">Leetcode(161)</a>
    </li>
    
    <li>
        <a href="https://wushaoqiang.github.io/categories/Linux/">Linux(30)</a>
    </li>
    
    <li>
        <a href="https://wushaoqiang.github.io/categories/Opinion/">Opinion(1)</a>
    </li>
    
    <li>
        <a href="https://wushaoqiang.github.io/categories/Vscode/">Vscode(1)</a>
    </li>
    
    <li>
        <a href="https://wushaoqiang.github.io/categories/%E4%BA%BA%E7%94%9F%E7%BB%8F%E5%8E%86/">人生经历(1)</a>
    </li>
    
    <li>
        <a href="https://wushaoqiang.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库(29)</a>
    </li>
    
    <li>
        <a href="https://wushaoqiang.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构(2)</a>
    </li>
    
    <li>
        <a href="https://wushaoqiang.github.io/categories/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/">网络基础(14)</a>
    </li>
    
    <li>
        <a href="https://wushaoqiang.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/">计算机基础(1)</a>
    </li>
    
    <li>
        <a href="https://wushaoqiang.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式(2)</a>
    </li>
    
    <li>
        <a href="https://wushaoqiang.github.io/categories/%E8%B5%84%E6%BA%90/">资源(1)</a>
    </li>
    
    <li>
        <a href="https://wushaoqiang.github.io/categories/%E9%9D%A2%E8%AF%95/">面试(1)</a>
    </li>
    
</ul>
    </section>

    <section class="widget">
        <h3 class="widget-title">标签</h3>
<div class="tagcloud">
    
    <a href="https://wushaoqiang.github.io/tags//"></a>
    
    <a href="https://wushaoqiang.github.io/tags/Algorithm/">Algorithm</a>
    
    <a href="https://wushaoqiang.github.io/tags/Array/">Array</a>
    
    <a href="https://wushaoqiang.github.io/tags/Bash/">Bash</a>
    
    <a href="https://wushaoqiang.github.io/tags/Basic/">Basic</a>
    
    <a href="https://wushaoqiang.github.io/tags/Beego/">Beego</a>
    
    <a href="https://wushaoqiang.github.io/tags/BigTable/">BigTable</a>
    
    <a href="https://wushaoqiang.github.io/tags/BinaryTree/">BinaryTree</a>
    
    <a href="https://wushaoqiang.github.io/tags/Blog/">Blog</a>
    
    <a href="https://wushaoqiang.github.io/tags/CSS/">CSS</a>
    
    <a href="https://wushaoqiang.github.io/tags/CSS3/">CSS3</a>
    
    <a href="https://wushaoqiang.github.io/tags/Channel/">Channel</a>
    
    <a href="https://wushaoqiang.github.io/tags/Command/">Command</a>
    
    <a href="https://wushaoqiang.github.io/tags/Context/">Context</a>
    
    <a href="https://wushaoqiang.github.io/tags/Crawler/">Crawler</a>
    
    <a href="https://wushaoqiang.github.io/tags/DHCP/">DHCP</a>
    
    <a href="https://wushaoqiang.github.io/tags/Definition/">Definition</a>
    
    <a href="https://wushaoqiang.github.io/tags/Easy/">Easy</a>
    
    <a href="https://wushaoqiang.github.io/tags/Effective/">Effective</a>
    
    <a href="https://wushaoqiang.github.io/tags/Encoding/">Encoding</a>
    
    <a href="https://wushaoqiang.github.io/tags/English/">English</a>
    
    <a href="https://wushaoqiang.github.io/tags/Exercism/">Exercism</a>
    
    <a href="https://wushaoqiang.github.io/tags/Favorite/">Favorite</a>
    
    <a href="https://wushaoqiang.github.io/tags/Front-end/">Front-end</a>
    
    <a href="https://wushaoqiang.github.io/tags/GC/">GC</a>
    
    <a href="https://wushaoqiang.github.io/tags/Generic/">Generic</a>
    
    <a href="https://wushaoqiang.github.io/tags/Gin/">Gin</a>
    
    <a href="https://wushaoqiang.github.io/tags/Git/">Git</a>
    
    <a href="https://wushaoqiang.github.io/tags/Golang/">Golang</a>
    
    <a href="https://wushaoqiang.github.io/tags/Gopher/">Gopher</a>
    
    <a href="https://wushaoqiang.github.io/tags/HTML/">HTML</a>
    
    <a href="https://wushaoqiang.github.io/tags/HTTP/">HTTP</a>
    
    <a href="https://wushaoqiang.github.io/tags/Hugo/">Hugo</a>
    
    <a href="https://wushaoqiang.github.io/tags/IP/">IP</a>
    
    <a href="https://wushaoqiang.github.io/tags/Interface/">Interface</a>
    
    <a href="https://wushaoqiang.github.io/tags/Internet/">Internet</a>
    
    <a href="https://wushaoqiang.github.io/tags/JS/">JS</a>
    
    <a href="https://wushaoqiang.github.io/tags/LeetCode/">LeetCode</a>
    
    <a href="https://wushaoqiang.github.io/tags/Leetcode/">Leetcode</a>
    
    <a href="https://wushaoqiang.github.io/tags/Life/">Life</a>
    
    <a href="https://wushaoqiang.github.io/tags/Linux/">Linux</a>
    
    <a href="https://wushaoqiang.github.io/tags/Log/">Log</a>
    
    <a href="https://wushaoqiang.github.io/tags/Map/">Map</a>
    
    <a href="https://wushaoqiang.github.io/tags/Module/">Module</a>
    
    <a href="https://wushaoqiang.github.io/tags/Mongodb/">Mongodb</a>
    
    <a href="https://wushaoqiang.github.io/tags/NAT/">NAT</a>
    
    <a href="https://wushaoqiang.github.io/tags/NoSQL/">NoSQL</a>
    
    <a href="https://wushaoqiang.github.io/tags/Paper/">Paper</a>
    
    <a href="https://wushaoqiang.github.io/tags/Path/">Path</a>
    
    <a href="https://wushaoqiang.github.io/tags/Pipeline/">Pipeline</a>
    
    <a href="https://wushaoqiang.github.io/tags/Raft/">Raft</a>
    
    <a href="https://wushaoqiang.github.io/tags/SQL/">SQL</a>
    
    <a href="https://wushaoqiang.github.io/tags/Search/">Search</a>
    
    <a href="https://wushaoqiang.github.io/tags/Sentences/">Sentences</a>
    
    <a href="https://wushaoqiang.github.io/tags/Slice/">Slice</a>
    
    <a href="https://wushaoqiang.github.io/tags/Sort/">Sort</a>
    
    <a href="https://wushaoqiang.github.io/tags/Spanner/">Spanner</a>
    
    <a href="https://wushaoqiang.github.io/tags/Strings/">Strings</a>
    
    <a href="https://wushaoqiang.github.io/tags/TCP/">TCP</a>
    
    <a href="https://wushaoqiang.github.io/tags/TS/">TS</a>
    
    <a href="https://wushaoqiang.github.io/tags/TiDB/">TiDB</a>
    
    <a href="https://wushaoqiang.github.io/tags/UDP/">UDP</a>
    
    <a href="https://wushaoqiang.github.io/tags/Ubuntu/">Ubuntu</a>
    
    <a href="https://wushaoqiang.github.io/tags/Validation/">Validation</a>
    
    <a href="https://wushaoqiang.github.io/tags/Vscode/">Vscode</a>
    
    <a href="https://wushaoqiang.github.io/tags/Web/">Web</a>
    
    <a href="https://wushaoqiang.github.io/tags/easy/">easy</a>
    
    <a href="https://wushaoqiang.github.io/tags/gocode/">gocode</a>
    
    <a href="https://wushaoqiang.github.io/tags/goquery/">goquery</a>
    
    <a href="https://wushaoqiang.github.io/tags/gorm/">gorm</a>
    
    <a href="https://wushaoqiang.github.io/tags/handler/">handler</a>
    
    <a href="https://wushaoqiang.github.io/tags/make/">make</a>
    
    <a href="https://wushaoqiang.github.io/tags/mega/">mega</a>
    
    <a href="https://wushaoqiang.github.io/tags/network/">network</a>
    
    <a href="https://wushaoqiang.github.io/tags/new/">new</a>
    
    <a href="https://wushaoqiang.github.io/tags/questions/">questions</a>
    
    <a href="https://wushaoqiang.github.io/tags/viper/">viper</a>
    
    <a href="https://wushaoqiang.github.io/tags/%E4%B8%AD%E6%96%AD/">中断&#34;</a>
    
    <a href="https://wushaoqiang.github.io/tags/%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5/">依赖注入</a>
    
    <a href="https://wushaoqiang.github.io/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/">内存管理</a>
    
    <a href="https://wushaoqiang.github.io/tags/%E5%8A%A0%E5%AF%86/">加密</a>
    
    <a href="https://wushaoqiang.github.io/tags/%E5%9F%BA%E7%A1%80/">基础</a>
    
    <a href="https://wushaoqiang.github.io/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/">基础知识</a>
    
    <a href="https://wushaoqiang.github.io/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/">密码学</a>
    
    <a href="https://wushaoqiang.github.io/tags/%E5%B0%8F%E6%8A%80%E5%B7%A7/">小技巧</a>
    
    <a href="https://wushaoqiang.github.io/tags/%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/">异常处理</a>
    
    <a href="https://wushaoqiang.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a>
    
    <a href="https://wushaoqiang.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a>
    
    <a href="https://wushaoqiang.github.io/tags/%E6%A0%87%E5%87%86%E5%BA%93/">标准库</a>
    
    <a href="https://wushaoqiang.github.io/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">源码分析</a>
    
    <a href="https://wushaoqiang.github.io/tags/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%8C%85/">第三方包</a>
    
    <a href="https://wushaoqiang.github.io/tags/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/">系统调用</a>
    
    <a href="https://wushaoqiang.github.io/tags/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/">网络协议</a>
    
    <a href="https://wushaoqiang.github.io/tags/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/">网络基础</a>
    
    <a href="https://wushaoqiang.github.io/tags/%E7%BD%91%E7%BB%9C%E7%AE%A1%E7%90%86/">网络管理</a>
    
    <a href="https://wushaoqiang.github.io/tags/%E8%A7%82%E7%82%B9/">观点</a>
    
    <a href="https://wushaoqiang.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/">计算机基础</a>
    
    <a href="https://wushaoqiang.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/">计算机系统</a>
    
    <a href="https://wushaoqiang.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a>
    
    <a href="https://wushaoqiang.github.io/tags/%E8%B5%84%E6%BA%90/">资源</a>
    
    <a href="https://wushaoqiang.github.io/tags/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/">进程管理</a>
    
    <a href="https://wushaoqiang.github.io/tags/%E9%85%8D%E7%BD%AE%E9%97%AE%E9%A2%98/">配置问题</a>
    
    <a href="https://wushaoqiang.github.io/tags/%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/">错误处理</a>
    
    <a href="https://wushaoqiang.github.io/tags/%E9%9D%A2%E8%AF%95/">面试</a>
    
</div>
    </section>

    

    <section class="widget">
        <h3 class="widget-title">其它</h3>
        <ul class="widget-list">
            <li><a href="https://wushaoqiang.github.io/index.xml">文章 RSS</a></li>
        </ul>
    </section>
</div>
        </div>
    </div>
</div>
<footer id="footer">
    <div class="container">
        &copy; 2019 <a href="https://wushaoqiang.github.io">Gavin&#39;s Blog By Gavin</a>.
        Powered by <a rel="nofollow noreferer noopener" href="https://gohugo.io" target="_blank">Hugo</a>.
        <a href="https://www.flysnow.org/" target="_blank">Theme</a> based on <a href="https://github.com/rujews/maupassant-hugo" target="_blank">maupassant</a>.
        
    </div>
</footer>


<a id="rocket" href="#top"></a>
<script type="text/javascript" src="/js/totop.js?v=0.0.0" async=""></script>



<script type="text/javascript" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script>





</body>
</html>
