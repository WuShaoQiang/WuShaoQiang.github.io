<!doctype html>
<html lang="en-us">
<head>

    <meta charset="utf-8">
    <meta name="generator" content="Hugo 0.40.1" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <title>Gavin&#39;s Blog | Gopher，后端开发，网络基础，WEB协议、架构、存储、缓冲、安全，学习笔记</title>
    <meta property="og:title" content="Gavin&#39;s Blog | Gopher，后端开发，网络基础，WEB协议、架构、存储、缓冲、安全，学习笔记">
    <meta property="og:type" content="website">
    <meta name="Keywords" content="Golang,Gavin,Blog">
    <meta name="description" content="">
    <meta property="og:url" content="https://wushaoqiang.github.io/">
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">

    <link rel="stylesheet" href="/css/normalize.css">
    
    <link rel="stylesheet" href="/css/style.css">
    <link rel="alternate" type="application/rss+xml" href="https://wushaoqiang.github.io/index.xml" title="Gavin's Blog" />
    <script type="text/javascript" src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script>

    


    
    
</head>


<body>
<header id="header" class="clearfix">
    <div class="container">
        <div class="col-group">
            <div class="site-name ">
                
                    <h1>
                        <a id="logo" href="https://wushaoqiang.github.io">
                            Gavin&#39;s Blog
                        </a>
                    </h1>
                
                <p class="description">Gopher，后端开发，网络基础，WEB协议、架构、存储、缓冲、安全，学习笔记</p>
            </div>
            <div>
                <nav id="nav-menu" class="clearfix">
                    <a class="current" href="https://wushaoqiang.github.io">首页</a>
                    
                    <a  href="https://wushaoqiang.github.io/archives/" title="归档">归档</a>
                    
                    <a  href="https://wushaoqiang.github.io/about/" title="关于">关于</a>
                    
                </nav>
            </div>
        </div>
    </div>
</header>


<div id="body">
    <div class="container">
        <div class="col-group">

            <div class="col-8" id="main">
                <div class="res-cons">
                    
                        <article class="post">
                            <header>
                                <h1 class="post-title">
                                    <a href="https://wushaoqiang.github.io/posts/database/theory/2pc-and-2pl/" title="2PC and 2PL" >2PC and 2PL</a>
                                </h1>
                            </header>
                            <date class="post-meta meta-date">
                                2019年10月7日
                            </date>
                            
                            <div class="post-meta">
                                <span>|</span>
                                
                                <span class="meta-category"><a href="https://wushaoqiang.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93">数据库</a></span>
                                
                            </div>
                            
                            <div class="post-content">
                                2PC == Two Phase Commit
2PL == Two Phase Lock
两者是完全不一样的东西
目的 2PC的目的是为了达到多节点的Consensus
2PL的目的是一种Isolation，防止并发的冲突
简单讲讲 今天看到2PC，在名词上和之前看到的2PL有点相像，为了区分开来，我觉得还是有必要简单总结一下
2PL
Two Phase Lock包含两种Lock
 Shared Lock
 Exclusive Lock
  在多个线程并发读取某一个数据的时候，它们申请的都是Shared Lock，也就是说Shared Lock是能够共存的
Exclusive Lock是写的时候申请获取的Lock，它能够把所有操作都排除在外，必须要得到释放后，后面的操作才能执行
因此2PL是一种Isolation，这是一种强保证的Isolation
2PC
Two Phase Commit是解决多节点事务共识提出来的方案
简单描述就是，当事务被提交到多个节点，会有一个中心化的Coordinator来决定这个事务是commit还是abort
在接收到一个外界提交的事务后
 Coordinate会给这个事务一个唯一的id
 Coordinate会将这个事务发给所有的节点
 当这个事务准备要commit的时候，Coordinate会先发一个Prepare请求，询问所有节点是否准备好commit
 只有收到所有节点的肯定回复，这个时候Coordinate才会进入第二阶段，给所有节点发送commit命令，这样所有节点都一定会commit，以此来保证共识
  这只是一个正常commit的流程
在分布式系统中还要充分考虑很多意外情况，因此2PC并没有这么简单
不过有一个非常重要的点，一旦Coordinate决定这个事务要commit，那么这个事务就一定要被commit，无论中间出了什么差错。所以这是不可逆转的决定，也只有这样才能保证节点的一致性
简单总结 这里除了是让我分清楚2PC和2PL是完全不一样的东西之外，还大概阐述了一下它们的作用以及目的……
                            </div>
                            <p class="readmore"><a href="https://wushaoqiang.github.io/posts/database/theory/2pc-and-2pl/">阅读全文</a></p>
                        </article>
                    
                        <article class="post">
                            <header>
                                <h1 class="post-title">
                                    <a href="https://wushaoqiang.github.io/posts/database/bigtable/bigtable-summary/" title="BigTable Summary" >BigTable Summary</a>
                                </h1>
                            </header>
                            <date class="post-meta meta-date">
                                2019年10月7日
                            </date>
                            
                            <div class="post-meta">
                                <span>|</span>
                                
                                <span class="meta-category"><a href="https://wushaoqiang.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93">数据库</a></span>
                                
                            </div>
                            
                            <div class="post-content">
                                国庆放假前几天，去翻阅了一下有关分布式存储的论文，其中有
 Google BigTable
 Google Spanner
 Raft
  不得不说，Google大法好
BigTable  Bigtable is a distributed storage system for managing structured data that is designed to scale to a very large size
 BigTable还结合了GFS，Chubby以及SSTable
先了解一些名词  tablet server 一个tablet server可以管理多个tablet
 tablet 是管理数据的最小单位
 table 一个table可以由多个tablet组成，或者说一个table可以分割成多个tablet
  它的数据模型 BigTable用了三个索引来标识一个数据
 Row
 Column
 Timestamp
  (row:string, column:string, time:int64) -&gt; string
Row BigTable会根据Row Key对数据进行排序，所以在同一个tablet上的数据都是有序的。所以相对Hash这种存储方式，有序能够方便范围性的Scan
Column and Column Family 一般来说Column Family包含多个Column，一个Column可以由family:qualifier来唯一标识。并且，Column Family一般是由同类型的Column组成，这样有助于压缩(压缩在下面优化的时候说到)。……
                            </div>
                            <p class="readmore"><a href="https://wushaoqiang.github.io/posts/database/bigtable/bigtable-summary/">阅读全文</a></p>
                        </article>
                    
                        <article class="post">
                            <header>
                                <h1 class="post-title">
                                    <a href="https://wushaoqiang.github.io/posts/database/raft/leader-election/" title="Leader Election" >Leader Election</a>
                                </h1>
                            </header>
                            <date class="post-meta meta-date">
                                2019年10月6日
                            </date>
                            
                            <div class="post-meta">
                                <span>|</span>
                                
                                <span class="meta-category"><a href="https://wushaoqiang.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93">数据库</a></span>
                                
                            </div>
                            
                            <div class="post-content">
                                在这里总结一些Leader Election的Case，通过例子来理解Raft的Leader Election或许会更有印象
下面用到的term是指任期值，index是最后一个committed log的位置
大家的Term和Index都相同 当大家的term和index都相同的时候，某一个Follower长时间未收到Leader的心跳发生timeout，就会变成candidate，并且term = currentTerm + 1， 这个时候这个candidate就会号召大家为它投票
投票是按照两个依据来选择是否投票的
 投票请求(RPC)带来的term一定要大于currentTerm，这样节点才知道这是新的一轮投票了
 满足上面条件后，还需要检测请求带来的lastLogIndex以及lastLogTerm以确保candidate拥有比自己新或者和自己一样的状态
  主要满足这两个条件，拥有投票权的节点就会给这个candidate投票
投票是需要majority节点同意的
在我们假设term和index都相同的前提下，发起选举，那么就会有谁先发起谁就非常大概率当Leader
Term相同，Index不一样 我们假设有两个candidate在竞选Leader，candidate1.index &lt; candidate2.index
也就是说candidate2拥有更加新的状态，我们来模拟一下竞选过程
candidate1和candidate2都会向所有节点发起投票请求(RPC)，candidate自己是给自己投票的
那么其它节点如何判断呢？
其实还是上面的那两个依据，不记得请往上面翻一翻
term相同，那么它们都会比currentTerm大(通过)
第二个是比较index，由于Raft会保证committed会在majority上，因此candidate1肯定会被majority拒绝(可能会得到一小部分未更新的节点的投票)
所以candidate2会得到majority的投票，因此成为Leader
结论就是term值一样的candidate，index新的会赢
Term不一样，Index相同 这种情况是term大的会赢
假设candidate1.term &lt; candidate2.term
这一部分我的理解可能不一定正确
因为对于所有server来说，接收到请求里的term要比自己的term大，都会变为Follower，因此我觉得candidate1 在接收到 candidate2的term时，会转换为Follower，这个时候candidate1就像是被迫离场一样
Term不一样，Index不一样 这里假设Leader.term &lt; Candidate.term 但是 Leader.index &gt; candidate.index
这个时候Leader收到了比自己term大的term，因此转换为Follower
但是因为candidate的index不是最新的，因此它不能够得到majority的投票，因此它会再次超时并且sleep一段时间
这个时候之前的Leader term已经是追上了，因此参加选举，这个时候满足选举投票的两个条件，因此再次成为Leader，并且宣布自己是Leader，所以之前的candidate看到有人宣布了Leader，就会放弃选举，变成Follower
不严谨 以上只是读者自己在看Raft Paper以及一些参考的理解，不一定是严谨的，有疑惑的地方还是参照更加官方的资料……
                            </div>
                            <p class="readmore"><a href="https://wushaoqiang.github.io/posts/database/raft/leader-election/">阅读全文</a></p>
                        </article>
                    
                        <article class="post">
                            <header>
                                <h1 class="post-title">
                                    <a href="https://wushaoqiang.github.io/posts/database/raft/tips/" title="Tips" >Tips</a>
                                </h1>
                            </header>
                            <date class="post-meta meta-date">
                                2019年10月5日
                            </date>
                            
                            <div class="post-meta">
                                <span>|</span>
                                
                                <span class="meta-category"><a href="https://wushaoqiang.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93">数据库</a></span>
                                
                            </div>
                            
                            <div class="post-content">
                                大概情况 今天看了Raft Paper，这是第一遍，我觉得自己还是有很多地方没有理解到位的(尽管我看了将近五个小时)
所以先是记录一下tips，后面重新回来看的时候再追加一下细节(或者还可以结合一下源码)，在raft官网上有相应的源码实现
tips 整体来理解Raft 当Leader接收到来自client的非读请求时，它会先记录在自己的log里面，然后再并发传递给Followers Server，一旦传递给了majority，那么每一个Server都会将log里面的东西放到state machine去执行，结果也将返回给client
先理解一些专有名词  term是描述一个版本号的，越大代表版本越新
 log entry就是我们要保证一致性的信息，整个算法核心就是如何让每一个节点上的log entry一致
 index是索引，节点上面存的log entry都是具有唯一标识的，这个标识就是由term和index来组成，这里可以简单理解为log entry所在的位置
 AppendEntries RPC代表Leader向Followers发送log entry(也可能是心跳)的RPC调用
  一些规则 对所有server来说
 自身的commitIndex &gt; lastApplied，那么就会lastApplied++，然后加入到state machine里
 只要接收到的term比自己的currentTerm大，那么就更新currentTerm，并且转换为Follower
  对于Follower来说
 要处理来自Leader和Candidate的请求
 如果因为没有收到AppendEntries而发生timeout或者给某一个candidate投票了，都会转换为candidate
  对于Candidate来说：
 在选举期间：
 currentTerm++
 给自己投票
 重置election timer
 给其它server发生RequestVote请求
  如果接收到了来自majority的投票，成为Leader
 如果收到了来自新Leader的AppendEntries，成为Follower
 如果过了election timeout的时间，开始新一轮竞选
  对于Leader来说：
 如果是赢得竞选，则发生空的AppendEntries(心跳)来告知其它server，并且持续发送心跳来维护自己Leader地位……
                            </div>
                            <p class="readmore"><a href="https://wushaoqiang.github.io/posts/database/raft/tips/">阅读全文</a></p>
                        </article>
                    
                        <article class="post">
                            <header>
                                <h1 class="post-title">
                                    <a href="https://wushaoqiang.github.io/posts/database/raft/safety-argument/" title="Safety Argument" >Safety Argument</a>
                                </h1>
                            </header>
                            <date class="post-meta meta-date">
                                2019年10月5日
                            </date>
                            
                            <div class="post-meta">
                                <span>|</span>
                                
                                <span class="meta-category"><a href="https://wushaoqiang.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93">数据库</a></span>
                                
                            </div>
                            
                            <div class="post-content">
                                起因 笔者在看Raft Paper的时候，遇到一个比较有意思的证明过程，不过这个证明过程对上下文有着紧密关系，因此在这里想用简单点的逻辑进行描述
这个证明有意思的在于，它通过引出矛盾来证明这个结论是正确的，也算是一种反证法吧
Let&rsquo;s Go 这里证明的是，通过Raft选择出来的Leader，一定拥有最新的committed
假设一下 这里假设有两个Leader，分别为Old Leader，New Leader。
我们假设New Leader在被选举出来的时候并没有最新的committed，什么意思呢，也就是说Old Leader在Crash之前已经commit了一个log，但是这个log并没有在New Leader里
我们知道，要commit一个log需要majority的followers同意。然后，选举一个新的Leader也是需要majority的candidates同意的。这就给出一个结论
因为两者都需要超过半数的节点同意，因此它们肯定有交集的节点
 注：这里用节点是因为不同的场景会有不同的角色，所以统一称为节点  引出矛盾 交集的节点做了两件事情(按顺序)
 接收到了Old Leader宕机之前的log，并且是committed
 给New Leader投票
  我们知道，选举的时候是有限制的，只有拥有最新committed log的节点才有被选举权，所以给New Leader投票说明New Leader在还没成为Leader之前是有这个committed log的(和前面假设冲突)
或者说，New Leader拥有比这个投票者所知道的更加新的committed log，换句话说，New Leader在之前就已经有更新版本的committed log，但是按照原则，创建这个最新版本log的Leader应该是拥有Old Leader的全部committed log的，所以按道理New Leader也应该要有这个log(所以还是和假设冲突)
结论 所以说，New Leader保证是会拥有Old Leader的所有committed log……
                            </div>
                            <p class="readmore"><a href="https://wushaoqiang.github.io/posts/database/raft/safety-argument/">阅读全文</a></p>
                        </article>
                    
                        <article class="post">
                            <header>
                                <h1 class="post-title">
                                    <a href="https://wushaoqiang.github.io/posts/database/tidb/tidb-server-source-sql-core-layer/" title="TiDB Server源码分析 SQL Core Layer" >TiDB Server源码分析 SQL Core Layer</a>
                                </h1>
                            </header>
                            <date class="post-meta meta-date">
                                2019年10月3日
                            </date>
                            
                            <div class="post-meta">
                                <span>|</span>
                                
                                <span class="meta-category"><a href="https://wushaoqiang.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93">数据库</a></span>
                                
                            </div>
                            
                            <div class="post-content">
                                还是架构 还是先放一张架构图，当思路不清晰的时候，看一看架构图能够帮我们整理思路
回想一下 上一篇blog是介绍了Protocol Layer，这一层整体思路还是比较简单，只是兼容MySQL协议会产生很多相应的函数方法
应该还记得，在上一篇blog，我有提到Driver这个词，并且看到了它的接口只有一个函数OpenCtx(...)...，从结构图上来将，我们需要将SQL传入到Session Context里面，而OpenCtx就是帮我们从Protocol Layer打开到SQL Core Layer的通道，然后再通过这个通道将数据传入进去。打开后会返回QueryCtx接口，这个接口是我们执行SQL的唯一入口，也就是Protocol Layer到SQL Core Layer的唯一入口
什么时候打开通道 通过编辑器可以发现，server/driver.go里的IDriver接口只在一个函数上有调用
func (cc *clientConn) openSessionAndDoAuth(authData []byte) error { var tlsStatePtr *tls.ConnectionState // 如果是SSL连接，就取出这个连接的状态 if cc.tlsConn != nil { tlsState := cc.tlsConn.ConnectionState() tlsStatePtr = &amp;tlsState } var err error // 打开通道，这里将返回的QueryCtx给到clientConn，它以后就用这个Ctx和SQL Core Layer进行交互 cc.ctx, err = cc.server.driver.OpenCtx(uint64(cc.connectionID), cc.capability, cc.collation, cc.dbname, tlsStatePtr) if err != nil { return err } // 忽略验证过程 return nil }  这个函数也只有两个地方会调用到……
                            </div>
                            <p class="readmore"><a href="https://wushaoqiang.github.io/posts/database/tidb/tidb-server-source-sql-core-layer/">阅读全文</a></p>
                        </article>
                    
                        <article class="post">
                            <header>
                                <h1 class="post-title">
                                    <a href="https://wushaoqiang.github.io/posts/database/tidb/tidb-server/" title="TiDB Server源码分析 Protocol Layer" >TiDB Server源码分析 Protocol Layer</a>
                                </h1>
                            </header>
                            <date class="post-meta meta-date">
                                2019年10月3日
                            </date>
                            
                            <div class="post-meta">
                                <span>|</span>
                                
                                <span class="meta-category"><a href="https://wushaoqiang.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93">数据库</a></span>
                                
                            </div>
                            
                            <div class="post-content">
                                简单介绍 最近趁着国庆放假，花点时间来看看TiDB这个工程，关于TiDB我就不介绍了，这一个blog主要是关于如何入手了解TiDB Server层，先来看一下这个架构图
因为TiDB源码还是比较多的，因此也是花了两天时间去看了下源码才准备写这个blog，算是个人的一个记录吧
怎么入手 TiDB-Server的架构图还是非常容易懂的，并且这篇文章只用关心左边Protocol Layer
我们可以简单的从tidb-server/main.go来入手，来简单了解一下基本组成
为了方便看源码，我这里直接贴上来了，为了保持逻辑简单，我建议前几次看的时候把一些关系不大的模块忽略，我只做简单的介绍
func main() { // 解析命令行 flag.Parse() // 如果带有version，则只是输出version if *version { fmt.Println(printer.GetTiDBInfo()) os.Exit(0) } // (可忽略)这里是注册store，会分别注册&quot;tikv&quot;和&quot;mock-tikv&quot; registerStores() // (可忽略)这个是和prometheus相关的 registerMetrics() // (可忽略) 配置，我们暂时可以考虑默认 configWarning := loadConfig() overrideConfig() if err := cfg.Valid(); err != nil { fmt.Fprintln(os.Stderr, &quot;invalid config&quot;, err) os.Exit(1) } if *configCheck { fmt.Println(&quot;config check successful&quot;) os.Exit(0) } // (可忽略) 都只是一些配置 setGlobalVars() setCPUAffinity() setupLog() // If configStrict had been specified, and there had been an error, the server would already // have exited by now.……
                            </div>
                            <p class="readmore"><a href="https://wushaoqiang.github.io/posts/database/tidb/tidb-server/">阅读全文</a></p>
                        </article>
                    
                        <article class="post">
                            <header>
                                <h1 class="post-title">
                                    <a href="https://wushaoqiang.github.io/posts/computer-network/tcp-vs-upd/" title="TCP vs UDP" >TCP vs UDP</a>
                                </h1>
                            </header>
                            <date class="post-meta meta-date">
                                2019年9月29日
                            </date>
                            
                            <div class="post-meta">
                                <span>|</span>
                                
                                <span class="meta-category"><a href="https://wushaoqiang.github.io/categories/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80">网络基础</a></span>
                                
                            </div>
                            
                            <div class="post-content">
                                TCP和UDP的区别这个问题已经遇到过很多次了，有简简单单的回答，也有绞尽脑汁去想，今天来详细总结一下区别吧
面向连接 TCP是面向连接的，也就是说TCP在连接上会有许多事情做，包括拥塞控制，流量控制，超时，重传，确认，序号等等。事情越多，负担就越多，并且对应的报文也比UDP报文要大
关于拥塞控制和流量控制，可以看我别的blog
UDP是没有连接的，我们只需要将数据传递给UDP，因此理论上UDP可支持的并发数要比TCP要高，UDP就会打包好数据传到网络层(IP)。反过来想，UDP这种“无法无天”的传输可能会造成很多不可靠问题。
 UDP没有序号，因此会产生包的乱序问题
 UDP没有流量控制，发太快可能会导致溢出，溢出的包可能因此就不见了
  连接状态 由于TCP是面向连接的，所以会有连接状态
发起连接 在还未连接的时候，客户端的状态为CLOSED，服务器端为LISTEN
 当客户端给服务器端发起一个SYN包的时候，客户端的状态变为SYS_SEND
 服务器端接收到，发一个SYN+ACK包，服务器端的状态变为SYS_RECV
 客户端接收到，并且会发一个ACK包，客户端状态变为ESTABLISH
 服务器端收到后也会变为ESTABLISH
  结束连接 初始状态，客户端和服务器端都为ESTABLISH
 假设客户端发了一个FIN包过去，这个时候客户端状态为FIN_WAIT1
 服务器收到了这个包，并且发送一个ACK包，服务端状态为CLOSE_WAIT
 服务器主动发一个FIN包，状态改为LAST_ACK
 客户端收到服务器的包，并且发送一个ACK包，将状态改为TIME_WAIT
 服务器收到ACK后进入CLOSED状态
 等待一段时间后没收到包，客户端也进入CLOSED
  这里为什么要等待一段时间呢？ 主要是要看最后面客户端给服务端的ACK是否到了，如果中间网络出了问题，服务器端没有收到这个ACK，那么它将会重发FIN，这个时候客户端还能够重新处理这个FIN……
                            </div>
                            <p class="readmore"><a href="https://wushaoqiang.github.io/posts/computer-network/tcp-vs-upd/">阅读全文</a></p>
                        </article>
                    
                        <article class="post">
                            <header>
                                <h1 class="post-title">
                                    <a href="https://wushaoqiang.github.io/posts/database/theory/transaction/" title="Transaction" >Transaction</a>
                                </h1>
                            </header>
                            <date class="post-meta meta-date">
                                2019年9月28日
                            </date>
                            
                            <div class="post-meta">
                                <span>|</span>
                                
                                <span class="meta-category"><a href="https://wushaoqiang.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93">数据库</a></span>
                                
                            </div>
                            
                            <div class="post-content">
                                事务这个词估计做软件开发的都不会陌生，我们可以简单的理解为：事务是一件事，要么成功，要么失败，而失败是全部失败，并不是局部失败
事务这么流行的原因就是，它帮助软件开发者解决了很多难办的事情：
 数据库可能会在任意时间因为软件或者硬件问题直接挂掉(可能这个时候正在执行一些写操作)
 应用也可能会在任意时间宕机
 网络通信是不可靠的
 可能在高并发下，数据库会发生冲突
  等等，这些事情，如果每一个都要想相应的解决方法，是需要大量的时间以及研究大量的算法，并且需要大量的测试集去验证这些算法实现是有用的
事务是为了将这些事情变得简单点，当出现任何不希望出现的状况，我可以选择抛弃这个操作，然后告诉用户，这个操作失败了。最起码，它在操作失败这件事情上，它是正确的
一般来说，事务会集合多个操作(Insert, Update, Delete)，变成一个操作，提交到数据库里，数据库会帮这些打包的操作看作是一个整体，因此操作到一半的时候发生错误，就会发生回滚，把之前的操作都抹去
那么是否用事务就能解决一切复杂的事情呢？
事务不是完美的，就像一直提到的，在数据库设计这一块，都是有的有舍，并没有完美的东西，因此我们也要很好的了解事务的优缺点。
ACID 相信大家对这个词也是不陌生的，但是其实笔者一开始将里面的各个意思理解错了，现在从先来理解一边
Atomicity 这里的中文虽然叫原子性，但是它和我们平常理解的原子性不一样，它这里并不是描述一个并发的过程
这里是指，一系列的操作被打包成一个事务，如果这个事务具有Atomicity，那么它要么被commit，要么被abort，这也保证了这个事务不会修改一部分数据后失败，能够让client放心的去做retry了
所以可以看出，这个Atomicity并不是在描述原子性，而是在描述操作的abortability，是否拥有abort操作
Consistency Consistency在这里是指一个好的状态，这个好的状态是指你的数据应该不违反规则。
但是在数据库层面，是不知道数据是否有效，所以这就需要开发者在应用的代码上写好事务的Consistency
Isolation 这个才是真正和并发相关的特性，隔离机制，后面也会详细讲讲各种隔离机制，以及它们的优缺点
我们在这里，可以简单的认为，我们可以利用隔离机制，将并发的事务一个个进行执行，这样就能够防止RACE发生，这种隔离机制叫serializable isolation但是，一个个执行是多么的低效，完完全全舍弃了并发的优势，所以下面我们会介绍许多没有如此强保证的隔离机制
Durability 持久化是数据库最根本的目的，一个拥有Durability的事务意味着数据能够被写入到硬盘，这里也运用到了之前所说的log或者一些其它方式来记录操作，这样可以在数据库重启后能够自己恢复
Weak Isolation Levels 因为性能问题，很多软件并不想用像serialzable isolation这种最高级别隔离的机制，因为这样的数据库很可能会在整个系统中称为瓶颈。
Read Commited 最基础的一个隔离机制，它能够给我们保证：
 所有读取的数据都是经过committed的
 写入数据库的时候，你只能够重写以及committed的数据
  但是多个事务在操作多个对象的时候，有可能会因为执行顺序不一样导致，事务之间读取到对方committed后的值
如何实现这个隔离机制呢
一般来说，会有一个row-level lock，每一个写操作都会请求对应行的lock，一个lock也只能被一个事务获取并且一直到它committed或者aborted才释放
那读取数据呢？简单点的我们可以也持有lock，但是我们知道，持有lock的代价是很大的，万一读操作很久，或者写操作很久，整个系统的性能就会受到影响，因此我们需要更好的方法去让读尽可能的不用获取lock
一个方法就是，数据库会帮忙记住lock之前的值，如果读取的时候发现是locked了，那么就那之前的值
Snapshot Isolation 其功能和其名字差不多，Snapshot Isolation的做法就是这个事务读取的数据是从一个快照里面读取的，当然，这个快照是不会被改变的，所以所有的事务都只能看见某一个时间点之前的老数据。
当我们在备份的时候， 我们可能不想在备份的时候，数据还在被修改，状态还是不稳定。所以这个隔离让我们不用担心这些问题。这个隔离机制在很多时候帮助我们很多，我们不用担心它有各种奇怪的问题，因为它已经是固定的了
其实Snapshot的实现机制和Read Committed差不多，也是通过lock来控制写入操作，然后读是不用锁的
 readers never block writers, and writers never block readers.……
                            </div>
                            <p class="readmore"><a href="https://wushaoqiang.github.io/posts/database/theory/transaction/">阅读全文</a></p>
                        </article>
                    
                        <article class="post">
                            <header>
                                <h1 class="post-title">
                                    <a href="https://wushaoqiang.github.io/posts/database/theory/partition/" title="Partition" >Partition</a>
                                </h1>
                            </header>
                            <date class="post-meta meta-date">
                                2019年9月28日
                            </date>
                            
                            <div class="post-meta">
                                <span>|</span>
                                
                                <span class="meta-category"><a href="https://wushaoqiang.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93">数据库</a></span>
                                
                            </div>
                            
                            <div class="post-content">
                                Partition And Replication 之前在学习Replication的时候，我们可以简单理解为副本集，也就是数据的复制
但是如果数据量很大，然后还复制几分，那不就上天了。Partition提供一种叫分片的方法，能够有效的将数据分隔存储在不同的节点
顺便说一下，默认的partition每个节点上的数据就只有该节点有，其它节点是没有的，也就是说，数据很可能会因为某一个结点不可用而导致该部分数据不可读取
这个时候我们可以选择将Replication和Partition结合起来用，你可能会问这样的一个问题：那数据不是还是复制了好几份了吗?
在Replication里，数据可以认为是相等的，假设我有5个节点，每个节点5TB的数据，总共25TB
在Partition和Replication结合起来用，会有多少呢？我们来算一下
首先，我们有5TB的数据，分片成5份，每一份1TB，每一份再通过Replication来复制到另外两个节点，所以每一份数据实际上有3份，也就是15TB。
这里的巧妙之处在于，你并不用每台机器都要有，备份只需要根据你集群的大小来选择合适的备份数量即可
How to partitioning the data 我们分片要有依据，如果随便存储，那么到时候不知道往哪查找了
我们可以像字典一样，用某一个key的区间作为一个partition，用区间作为区分有一些优点：
 有序，这样在查找的时候，可以按照区间大小一次性取出大量数据(还记得LSM-Tree)
 每个partition的区间大小可以自己指定
  但是也有一些缺点：
 分片有可能严重倾斜，有一些节点已经Overload，而别的节点却很闲  Partitioning by Hash of Key 为了解决Hot Spot问题，我们可以采用随机性较强的哈希函数对每一个key进行一次Hash，再进行分片，这样在大概率上是平均分配给每个节点的
虽然解决了一些问题，但是上面的有序性就被破坏了
我们知道，数据被分散了情况下，读取就会变得越来越麻烦，可能一次查询，就要用到许多的partition，所以也是有很多缺点
Partitioning and Secondary Indexes Secondary Indexes不能唯一标识一个实例，它可以是一个颜色，一个城市等等，许多人可能都生活在一个城市，所以一个城市并不能标识哪个人
这里主要有两种方法将数据库分片，并且是带上Secondary Indexes的
 document-based partitioning
 term-based partitioning
  这两种不同的Secondary Indexes主要的区别在于，document-based只的对它当前节点的数据进行索引
而term-based是对整个集群的索引
我们来看一下它们在读写方面的优劣情况
在写的时候，document-based理论上会有更好的性能
在对一个数据进行更新的时候，document-based只需要修改被更新的partition里的索引，而term-based则可能需要修改多个partition里面的索引
在读的时候，term-based理论上会有更好的性能
因为document-based的索引是分开在各个partition的，所以查询的时候有可能要遍历所有的partition，而term-based因为某些索引集中在一个partition，所以很快能够找到索引值
Rebalancing Partitions 我们无论是新增节点还是删除节点，都需要做这件事情
有一个方法可能大家都听过&ndash;mod
这个方法会导致节点变动时，里面的数据会大量变动，并不是一个好的选择
下面介绍一种方法fixed number of partitions……
                            </div>
                            <p class="readmore"><a href="https://wushaoqiang.github.io/posts/database/theory/partition/">阅读全文</a></p>
                        </article>
                    

                    


<ol class="page-navigator">
    
    <li class="prev">
        <a href="https://wushaoqiang.github.io/page/2/">上一页</a>
    </li>
    

    
    <li >
        <a href="https://wushaoqiang.github.io/">1</a>
    </li>
    
    <li >
        <a href="https://wushaoqiang.github.io/page/2/">2</a>
    </li>
    
    <li  class="current">
        <a href="https://wushaoqiang.github.io/page/3/">3</a>
    </li>
    
    <li >
        <a href="https://wushaoqiang.github.io/page/4/">4</a>
    </li>
    
    <li >
        <a href="https://wushaoqiang.github.io/page/5/">5</a>
    </li>
    
    <li >
        <a href="https://wushaoqiang.github.io/page/6/">6</a>
    </li>
    
    <li >
        <a href="https://wushaoqiang.github.io/page/7/">7</a>
    </li>
    
    <li >
        <a href="https://wushaoqiang.github.io/page/8/">8</a>
    </li>
    
    <li >
        <a href="https://wushaoqiang.github.io/page/9/">9</a>
    </li>
    
    <li >
        <a href="https://wushaoqiang.github.io/page/10/">10</a>
    </li>
    
    <li >
        <a href="https://wushaoqiang.github.io/page/11/">11</a>
    </li>
    
    <li >
        <a href="https://wushaoqiang.github.io/page/12/">12</a>
    </li>
    
    <li >
        <a href="https://wushaoqiang.github.io/page/13/">13</a>
    </li>
    
    <li >
        <a href="https://wushaoqiang.github.io/page/14/">14</a>
    </li>
    
    <li >
        <a href="https://wushaoqiang.github.io/page/15/">15</a>
    </li>
    
    <li >
        <a href="https://wushaoqiang.github.io/page/16/">16</a>
    </li>
    
    <li >
        <a href="https://wushaoqiang.github.io/page/17/">17</a>
    </li>
    
    <li >
        <a href="https://wushaoqiang.github.io/page/18/">18</a>
    </li>
    
    <li >
        <a href="https://wushaoqiang.github.io/page/19/">19</a>
    </li>
    
    <li >
        <a href="https://wushaoqiang.github.io/page/20/">20</a>
    </li>
    
    <li >
        <a href="https://wushaoqiang.github.io/page/21/">21</a>
    </li>
    
    <li >
        <a href="https://wushaoqiang.github.io/page/22/">22</a>
    </li>
    
    <li >
        <a href="https://wushaoqiang.github.io/page/23/">23</a>
    </li>
    
    <li >
        <a href="https://wushaoqiang.github.io/page/24/">24</a>
    </li>
    
    <li >
        <a href="https://wushaoqiang.github.io/page/25/">25</a>
    </li>
    
    <li >
        <a href="https://wushaoqiang.github.io/page/26/">26</a>
    </li>
    
    <li >
        <a href="https://wushaoqiang.github.io/page/27/">27</a>
    </li>
    
    <li >
        <a href="https://wushaoqiang.github.io/page/28/">28</a>
    </li>
    
    <li >
        <a href="https://wushaoqiang.github.io/page/29/">29</a>
    </li>
    
    <li >
        <a href="https://wushaoqiang.github.io/page/30/">30</a>
    </li>
    
    <li >
        <a href="https://wushaoqiang.github.io/page/31/">31</a>
    </li>
    
    <li >
        <a href="https://wushaoqiang.github.io/page/32/">32</a>
    </li>
    

    
    <li class="next">
        <a href="https://wushaoqiang.github.io/page/4/">下一页</a>
    </li>
    
</ol>



                </div>
            </div>

            <div id="secondary">
    <section class="widget">
        <form id="search" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank" _lpchecked="1">
      
      <input type="text" name="q" maxlength="20" placeholder="Search">
      <input type="hidden" name="sitesearch" value="https://wushaoqiang.github.io">
      <button type="submit" class="submit icon-search"></button>
</form>
    </section>
    
    <section class="widget">
        <h3 class="widget-title">最近文章</h3>
<ul class="widget-list">
    
    <li>
        <a href="https://wushaoqiang.github.io/posts/linux/linux-interrupt/" title="Linux Interrupt Top Halves">Linux Interrupt Top Halves</a>
    </li>
    
    <li>
        <a href="https://wushaoqiang.github.io/posts/linux/linux-system-call/" title="Linux System Call">Linux System Call</a>
    </li>
    
    <li>
        <a href="https://wushaoqiang.github.io/posts/front-end/different-encoding/" title="Different Encoding">Different Encoding</a>
    </li>
    
    <li>
        <a href="https://wushaoqiang.github.io/posts/linux/linux-memory-management/" title="Linux Memory Management">Linux Memory Management</a>
    </li>
    
    <li>
        <a href="https://wushaoqiang.github.io/posts/linux/linux-process-scheduler/" title="Linux Process Scheduler">Linux Process Scheduler</a>
    </li>
    
    <li>
        <a href="https://wushaoqiang.github.io/posts/linux/linux-process-dofork/" title="Linux Process do_fork">Linux Process do_fork</a>
    </li>
    
    <li>
        <a href="https://wushaoqiang.github.io/posts/linux/linux-process-fork/" title="Linux Process Fork&amp;Clone">Linux Process Fork&amp;Clone</a>
    </li>
    
    <li>
        <a href="https://wushaoqiang.github.io/posts/linux/linux-process-identifier/" title="Linux Process Identifier">Linux Process Identifier</a>
    </li>
    
    <li>
        <a href="https://wushaoqiang.github.io/posts/linux/linux-namespace/" title="Linux Namespace">Linux Namespace</a>
    </li>
    
    <li>
        <a href="https://wushaoqiang.github.io/posts/linux/linux-process-types/" title="Linux Process Types">Linux Process Types</a>
    </li>
    
</ul>
    </section>

    

    <section class="widget">
        <h3 class="widget-title">分类</h3>
<ul class="widget-list">
    
    <li>
        <a href="https://wushaoqiang.github.io/categories//">(1)</a>
    </li>
    
    <li>
        <a href="https://wushaoqiang.github.io/categories/Algorithm/">Algorithm(2)</a>
    </li>
    
    <li>
        <a href="https://wushaoqiang.github.io/categories/Definition/">Definition(1)</a>
    </li>
    
    <li>
        <a href="https://wushaoqiang.github.io/categories/English/">English(2)</a>
    </li>
    
    <li>
        <a href="https://wushaoqiang.github.io/categories/Favorite/">Favorite(1)</a>
    </li>
    
    <li>
        <a href="https://wushaoqiang.github.io/categories/Front-end/">Front-end(14)</a>
    </li>
    
    <li>
        <a href="https://wushaoqiang.github.io/categories/Git/">Git(2)</a>
    </li>
    
    <li>
        <a href="https://wushaoqiang.github.io/categories/Golang/">Golang(50)</a>
    </li>
    
    <li>
        <a href="https://wushaoqiang.github.io/categories/Hugo/">Hugo(1)</a>
    </li>
    
    <li>
        <a href="https://wushaoqiang.github.io/categories/Leetcode/">Leetcode(161)</a>
    </li>
    
    <li>
        <a href="https://wushaoqiang.github.io/categories/Linux/">Linux(30)</a>
    </li>
    
    <li>
        <a href="https://wushaoqiang.github.io/categories/Opinion/">Opinion(1)</a>
    </li>
    
    <li>
        <a href="https://wushaoqiang.github.io/categories/Vscode/">Vscode(1)</a>
    </li>
    
    <li>
        <a href="https://wushaoqiang.github.io/categories/%E4%BA%BA%E7%94%9F%E7%BB%8F%E5%8E%86/">人生经历(1)</a>
    </li>
    
    <li>
        <a href="https://wushaoqiang.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库(29)</a>
    </li>
    
    <li>
        <a href="https://wushaoqiang.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构(2)</a>
    </li>
    
    <li>
        <a href="https://wushaoqiang.github.io/categories/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/">网络基础(14)</a>
    </li>
    
    <li>
        <a href="https://wushaoqiang.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/">计算机基础(1)</a>
    </li>
    
    <li>
        <a href="https://wushaoqiang.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式(2)</a>
    </li>
    
    <li>
        <a href="https://wushaoqiang.github.io/categories/%E8%B5%84%E6%BA%90/">资源(1)</a>
    </li>
    
    <li>
        <a href="https://wushaoqiang.github.io/categories/%E9%9D%A2%E8%AF%95/">面试(1)</a>
    </li>
    
</ul>
    </section>

    <section class="widget">
        <h3 class="widget-title">标签</h3>
<div class="tagcloud">
    
    <a href="https://wushaoqiang.github.io/tags//"></a>
    
    <a href="https://wushaoqiang.github.io/tags/Algorithm/">Algorithm</a>
    
    <a href="https://wushaoqiang.github.io/tags/Array/">Array</a>
    
    <a href="https://wushaoqiang.github.io/tags/Bash/">Bash</a>
    
    <a href="https://wushaoqiang.github.io/tags/Basic/">Basic</a>
    
    <a href="https://wushaoqiang.github.io/tags/Beego/">Beego</a>
    
    <a href="https://wushaoqiang.github.io/tags/BigTable/">BigTable</a>
    
    <a href="https://wushaoqiang.github.io/tags/BinaryTree/">BinaryTree</a>
    
    <a href="https://wushaoqiang.github.io/tags/Blog/">Blog</a>
    
    <a href="https://wushaoqiang.github.io/tags/CSS/">CSS</a>
    
    <a href="https://wushaoqiang.github.io/tags/CSS3/">CSS3</a>
    
    <a href="https://wushaoqiang.github.io/tags/Channel/">Channel</a>
    
    <a href="https://wushaoqiang.github.io/tags/Command/">Command</a>
    
    <a href="https://wushaoqiang.github.io/tags/Context/">Context</a>
    
    <a href="https://wushaoqiang.github.io/tags/Crawler/">Crawler</a>
    
    <a href="https://wushaoqiang.github.io/tags/DHCP/">DHCP</a>
    
    <a href="https://wushaoqiang.github.io/tags/Definition/">Definition</a>
    
    <a href="https://wushaoqiang.github.io/tags/Easy/">Easy</a>
    
    <a href="https://wushaoqiang.github.io/tags/Effective/">Effective</a>
    
    <a href="https://wushaoqiang.github.io/tags/Encoding/">Encoding</a>
    
    <a href="https://wushaoqiang.github.io/tags/English/">English</a>
    
    <a href="https://wushaoqiang.github.io/tags/Exercism/">Exercism</a>
    
    <a href="https://wushaoqiang.github.io/tags/Favorite/">Favorite</a>
    
    <a href="https://wushaoqiang.github.io/tags/Front-end/">Front-end</a>
    
    <a href="https://wushaoqiang.github.io/tags/GC/">GC</a>
    
    <a href="https://wushaoqiang.github.io/tags/Generic/">Generic</a>
    
    <a href="https://wushaoqiang.github.io/tags/Gin/">Gin</a>
    
    <a href="https://wushaoqiang.github.io/tags/Git/">Git</a>
    
    <a href="https://wushaoqiang.github.io/tags/Golang/">Golang</a>
    
    <a href="https://wushaoqiang.github.io/tags/Gopher/">Gopher</a>
    
    <a href="https://wushaoqiang.github.io/tags/HTML/">HTML</a>
    
    <a href="https://wushaoqiang.github.io/tags/HTTP/">HTTP</a>
    
    <a href="https://wushaoqiang.github.io/tags/Hugo/">Hugo</a>
    
    <a href="https://wushaoqiang.github.io/tags/IP/">IP</a>
    
    <a href="https://wushaoqiang.github.io/tags/Interface/">Interface</a>
    
    <a href="https://wushaoqiang.github.io/tags/Internet/">Internet</a>
    
    <a href="https://wushaoqiang.github.io/tags/JS/">JS</a>
    
    <a href="https://wushaoqiang.github.io/tags/LeetCode/">LeetCode</a>
    
    <a href="https://wushaoqiang.github.io/tags/Leetcode/">Leetcode</a>
    
    <a href="https://wushaoqiang.github.io/tags/Life/">Life</a>
    
    <a href="https://wushaoqiang.github.io/tags/Linux/">Linux</a>
    
    <a href="https://wushaoqiang.github.io/tags/Log/">Log</a>
    
    <a href="https://wushaoqiang.github.io/tags/Map/">Map</a>
    
    <a href="https://wushaoqiang.github.io/tags/Module/">Module</a>
    
    <a href="https://wushaoqiang.github.io/tags/Mongodb/">Mongodb</a>
    
    <a href="https://wushaoqiang.github.io/tags/NAT/">NAT</a>
    
    <a href="https://wushaoqiang.github.io/tags/NoSQL/">NoSQL</a>
    
    <a href="https://wushaoqiang.github.io/tags/Paper/">Paper</a>
    
    <a href="https://wushaoqiang.github.io/tags/Path/">Path</a>
    
    <a href="https://wushaoqiang.github.io/tags/Pipeline/">Pipeline</a>
    
    <a href="https://wushaoqiang.github.io/tags/Raft/">Raft</a>
    
    <a href="https://wushaoqiang.github.io/tags/SQL/">SQL</a>
    
    <a href="https://wushaoqiang.github.io/tags/Search/">Search</a>
    
    <a href="https://wushaoqiang.github.io/tags/Sentences/">Sentences</a>
    
    <a href="https://wushaoqiang.github.io/tags/Slice/">Slice</a>
    
    <a href="https://wushaoqiang.github.io/tags/Sort/">Sort</a>
    
    <a href="https://wushaoqiang.github.io/tags/Spanner/">Spanner</a>
    
    <a href="https://wushaoqiang.github.io/tags/Strings/">Strings</a>
    
    <a href="https://wushaoqiang.github.io/tags/TCP/">TCP</a>
    
    <a href="https://wushaoqiang.github.io/tags/TS/">TS</a>
    
    <a href="https://wushaoqiang.github.io/tags/TiDB/">TiDB</a>
    
    <a href="https://wushaoqiang.github.io/tags/UDP/">UDP</a>
    
    <a href="https://wushaoqiang.github.io/tags/Ubuntu/">Ubuntu</a>
    
    <a href="https://wushaoqiang.github.io/tags/Validation/">Validation</a>
    
    <a href="https://wushaoqiang.github.io/tags/Vscode/">Vscode</a>
    
    <a href="https://wushaoqiang.github.io/tags/Web/">Web</a>
    
    <a href="https://wushaoqiang.github.io/tags/easy/">easy</a>
    
    <a href="https://wushaoqiang.github.io/tags/gocode/">gocode</a>
    
    <a href="https://wushaoqiang.github.io/tags/goquery/">goquery</a>
    
    <a href="https://wushaoqiang.github.io/tags/gorm/">gorm</a>
    
    <a href="https://wushaoqiang.github.io/tags/handler/">handler</a>
    
    <a href="https://wushaoqiang.github.io/tags/make/">make</a>
    
    <a href="https://wushaoqiang.github.io/tags/mega/">mega</a>
    
    <a href="https://wushaoqiang.github.io/tags/network/">network</a>
    
    <a href="https://wushaoqiang.github.io/tags/new/">new</a>
    
    <a href="https://wushaoqiang.github.io/tags/questions/">questions</a>
    
    <a href="https://wushaoqiang.github.io/tags/viper/">viper</a>
    
    <a href="https://wushaoqiang.github.io/tags/%E4%B8%AD%E6%96%AD/">中断&#34;</a>
    
    <a href="https://wushaoqiang.github.io/tags/%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5/">依赖注入</a>
    
    <a href="https://wushaoqiang.github.io/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/">内存管理</a>
    
    <a href="https://wushaoqiang.github.io/tags/%E5%8A%A0%E5%AF%86/">加密</a>
    
    <a href="https://wushaoqiang.github.io/tags/%E5%9F%BA%E7%A1%80/">基础</a>
    
    <a href="https://wushaoqiang.github.io/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/">基础知识</a>
    
    <a href="https://wushaoqiang.github.io/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/">密码学</a>
    
    <a href="https://wushaoqiang.github.io/tags/%E5%B0%8F%E6%8A%80%E5%B7%A7/">小技巧</a>
    
    <a href="https://wushaoqiang.github.io/tags/%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/">异常处理</a>
    
    <a href="https://wushaoqiang.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a>
    
    <a href="https://wushaoqiang.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a>
    
    <a href="https://wushaoqiang.github.io/tags/%E6%A0%87%E5%87%86%E5%BA%93/">标准库</a>
    
    <a href="https://wushaoqiang.github.io/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">源码分析</a>
    
    <a href="https://wushaoqiang.github.io/tags/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%8C%85/">第三方包</a>
    
    <a href="https://wushaoqiang.github.io/tags/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/">系统调用</a>
    
    <a href="https://wushaoqiang.github.io/tags/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/">网络协议</a>
    
    <a href="https://wushaoqiang.github.io/tags/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/">网络基础</a>
    
    <a href="https://wushaoqiang.github.io/tags/%E7%BD%91%E7%BB%9C%E7%AE%A1%E7%90%86/">网络管理</a>
    
    <a href="https://wushaoqiang.github.io/tags/%E8%A7%82%E7%82%B9/">观点</a>
    
    <a href="https://wushaoqiang.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/">计算机基础</a>
    
    <a href="https://wushaoqiang.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/">计算机系统</a>
    
    <a href="https://wushaoqiang.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a>
    
    <a href="https://wushaoqiang.github.io/tags/%E8%B5%84%E6%BA%90/">资源</a>
    
    <a href="https://wushaoqiang.github.io/tags/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/">进程管理</a>
    
    <a href="https://wushaoqiang.github.io/tags/%E9%85%8D%E7%BD%AE%E9%97%AE%E9%A2%98/">配置问题</a>
    
    <a href="https://wushaoqiang.github.io/tags/%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/">错误处理</a>
    
    <a href="https://wushaoqiang.github.io/tags/%E9%9D%A2%E8%AF%95/">面试</a>
    
</div>
    </section>

    

    <section class="widget">
        <h3 class="widget-title">其它</h3>
        <ul class="widget-list">
            <li><a href="https://wushaoqiang.github.io/index.xml">文章 RSS</a></li>
        </ul>
    </section>
</div>
        </div>
    </div>
</div>
<footer id="footer">
    <div class="container">
        &copy; 2019 <a href="https://wushaoqiang.github.io">Gavin&#39;s Blog By Gavin</a>.
        Powered by <a rel="nofollow noreferer noopener" href="https://gohugo.io" target="_blank">Hugo</a>.
        <a href="https://www.flysnow.org/" target="_blank">Theme</a> based on <a href="https://github.com/rujews/maupassant-hugo" target="_blank">maupassant</a>.
        
    </div>
</footer>


<a id="rocket" href="#top"></a>
<script type="text/javascript" src="/js/totop.js?v=0.0.0" async=""></script>



<script type="text/javascript" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script>





</body>
</html>
