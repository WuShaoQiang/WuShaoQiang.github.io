<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Gavin&#39;s Blog</title>
    <link>https://wushaoqiang.github.io/</link>
    <description>Recent content on Gavin&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 22 Apr 2019 20:59:55 +0800</lastBuildDate>
    
	<atom:link href="https://wushaoqiang.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>DHCP 和 NAT</title>
      <link>https://wushaoqiang.github.io/posts/DHCP-and-NAT/</link>
      <pubDate>Mon, 22 Apr 2019 20:59:55 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/DHCP-and-NAT/</guid>
      <description>DHCP(动态主机配置协议) 我们在上网的时候，其实是向某一个ISP请求一个IP地址，这个IP地址是临时的，到期是要被回收的
四个步骤  让DHCP服务器发现客户端：客户端创建一个请求报文，请求端口号为67，但这个时候它连自己的IP地址都不知道(因为还没分配)，就用0.0.0.0:68来代替，但是它也不知道目标地址，所以用广播地址255.255.255.255:67
 DHCP服务器提供：DHCP收到了请求，做出响应，目标地址仍然使用255.255.255.255:68(这里端口号为68.因为客户68端口是接收这个包的)，这个时候客户端已经知道DHCP的位置了
 再次对准确地址发出请求
 DHCP响应
  到这里交互就完成了
NAT(网络地址转换) 这个是普遍使用在学校，家庭，公司等，因为现在IPv4的资源已经枯竭，利用NAT能够使得大家共用一个对外的IP，而内部会有不同的IP(局域网内IP)
比如我在学习请求百度这个网页，百度实际上看到的IP地址是我学校的IP地址，并且将内容返回给这个IP地址，学校再通过NAT转换表把东西转给我
有些人也说道，NAT实质上很大阻碍了IPv6的发展</description>
    </item>
    
    <item>
      <title>IPv4 数据报格式与分片</title>
      <link>https://wushaoqiang.github.io/posts/ip-message-field/</link>
      <pubDate>Mon, 22 Apr 2019 20:21:55 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/ip-message-field/</guid>
      <description>直接上图  版本号
 首部长度：一般为20
 服务类型：为了区分数据报，有点想女士优先这种
 数据报长度(首部加数据，一般不超过1500字节)
 标识、标志、片偏移：与IP数据报分片有关(别的篇幅讲)
 寿命：每经过一台路由器，TTL减1，若为0的时候，这个数据报就要丢掉了
 上层协议：6代表TCP；17代表UDP
 首部校验和(检验IP数据报比特错误)
 源和目的IP地址
 选项(很少用)
 数据(TCP or UDP报文段)
  IP数据报分片 发送方与目的地路径上的每段链路可能使用不同的链路层协议，且每种协议可能具备不同的MTU
比如以太网的MTU为1500
所以在通过MTU比较小的链路段时，就需要分片了
为了让目的主机执行重装任务，IPv4的设计者将标识、标志、片偏移字段放在IP数据报首部
分别解释这三个字段 标识 发送主机在发送IP数据报的时候，通常会将它发送的每个数据报的标识号加1
所以目的地址收到了很多片，这些片上标识号是同一个数字的，那么它们就是可以组合的
标志 最后一个片的标志比特被设为0，表明已经接收到某个标识的最后一个片
偏移量 毫无疑问，是为了将片重新组织回去的</description>
    </item>
    
    <item>
      <title>HTTP 报文</title>
      <link>https://wushaoqiang.github.io/posts/http-message-field/</link>
      <pubDate>Mon, 22 Apr 2019 19:17:47 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/http-message-field/</guid>
      <description> 客户向它的套接字接口发送HTTP请求报文和向它的套接字接口接收HTTP响应报文
HTTP是一个无状态协议
报文格式 响应报文格式 常见状态码 //Success 200 OK ：表示请求成功 201 Created ：表示请求成功且新建了资源 202 Accepted ：请求成功，但还没创建资源 //Redirection 301 Moved Permanently ：永久转移，服务器会自动转到新的位置 302 Found ：暂时转移，下次还是用这个URI 304 Not Modified ：服务端已经执行了GET，但文件未变化 //Client Error 400 Bad Request ：报文中存在语法错误 401 Unauthorized ：未认证 403 Forbidden ：对请求资源的访问被服务器拒绝了 404 Not Found ：无法找到指定的资源 //Server Error 500 Internal Server Error :服务器端在执行请求时发生了错误 503 Service Unavailable :服务器暂时处于超负载或正在进行停机维护  </description>
    </item>
    
    <item>
      <title>UDP</title>
      <link>https://wushaoqiang.github.io/posts/udp/</link>
      <pubDate>Mon, 22 Apr 2019 16:35:03 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/udp/</guid>
      <description>  UDP无连接建立
 不需要维护连接状态
 报文头比TCP小
 能尽可能的快，没有速度限制
  应用场景 对丢包不是很看重，对速度很敏感
 DNS
 SNMP
  报文结构 </description>
    </item>
    
    <item>
      <title>TCP 流量控制</title>
      <link>https://wushaoqiang.github.io/posts/tcp-flow-control/</link>
      <pubDate>Mon, 22 Apr 2019 15:17:17 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/tcp-flow-control/</guid>
      <description>流量控制是为了匹配发送方和接收方的数据交换速度，如果发送方发的太快，接收方的缓存可能会溢出
还要提醒一下流量控制和拥塞控制是两码事
TCP通过让发送方维护一个称为接收窗口的变量来提供流量控制
在接收方一定要满足
LastByteRcvd - LastByteRead &amp;lt;= RcvBuffer
用rwnd表示还有多少空间可以用，所以rwnd = RcvBuffer - (LastByteRcvd - LastByteRead)
在TCP报文首部里有一个叫做接收窗口，这个就是接收者告诉发送者rwnd的
在发送方，通过将未确认的数据量控制在值rwnd以内，就可以保证接收者不会缓存溢出了
UDP是不提供流量控制的，所以UDP很有可能会出现缓存溢出</description>
    </item>
    
    <item>
      <title>TCP 拥塞控制</title>
      <link>https://wushaoqiang.github.io/posts/tcp-congestion-control/</link>
      <pubDate>Mon, 22 Apr 2019 13:11:08 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/tcp-congestion-control/</guid>
      <description> TCP必须使用端到端拥塞控制而不是网络辅助的拥塞控制
TCP所采用的方法是让每一个发送方根据所感知到的网络拥塞程度来限制其能向连接发送流量的速率
三个问题 我们如何知道网络开始拥塞？
我们如何限制发送方发送速率
当发送方感受到拥塞时，用什么算法去限制其发送速率
如何知道网络拥塞 TCP是不会有一种特殊的包叫“我拥塞啦”
接收到Ack 没有拥塞，可以提速
没接收到Ack 可能拥塞，降速
如何限制发送方速率 改变cwnd
当一切顺利，cwnd增加；丢包，cwnd减少
我们发送方被限制在min(rwnd,cwnd)
LastByteSent - LastByteAcked &amp;lt;= cwnd
rwnd和cwnd是不同的，前者是表示接收方的buffer还有多少能用，后者是改变在网络上的容量
用什么算法来限制速度 我们希望TCP能在不发生拥塞情况上利用最大的带宽
所以发送方速率有点像三角波，上上下下，因为要尽可能利用带宽又不要制造拥塞
慢启动 在包被收到的情况下 cwnd每次是之前的两倍1,2,4,8,16...，直到大于或等于阈值，切换到拥塞避免
在包没有被收到的情况下 三次冗余Ack 进入快速恢复
超时 阈值=cwnd/2
把cwnd变为1
阈值(threhold) 记录上一次拥塞时一半的cwnd
拥塞避免 在包被接收到的情况下 线性增长，每次在所有分片的Ack被接收到的情况下(一个RTT)，增加一个MSS
在包没有被接收到的情况下 三次冗余Ack 进入快速恢复
超时 切换到慢启动
快速恢复 每个冗余的Ack对cwnd增加一个MSS，当丢失报文段的Ack最终回到时，再减少一个MSS
进入拥塞避免状态
出现超时，进入慢启动
出现丢包，cwnd设置为1，阈值设置为cwnd的一半
总结一下 三次冗余ACK  阈值设置为cwnd/2
 cwnd设置为阈值(有快速恢复的情况下)
  超时  阈值设置为cwnd/2
 cwnd设置为1(MSS)
  </description>
    </item>
    
    <item>
      <title>TCP 连接 --三次握手和四次挥手</title>
      <link>https://wushaoqiang.github.io/posts/tcp-connect/</link>
      <pubDate>Mon, 22 Apr 2019 12:52:03 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/tcp-connect/</guid>
      <description> 首先这里所说的握手，是进程之间的握手
三次握手 简单来说就是
A --&amp;gt; B 不承载有效负荷 B --&amp;gt; A 不承载有效负荷 A --&amp;gt; B 可以承载有效负荷  再细致点说就是
 客户端应用程序发起一个TCP连接
 发送报文里有SYN
 收到来自服务器端的SYN&amp;amp;ACK
 再次向服务器端发送ACK
  这里面总共有3次报文，所以为三次握手
最大报文段长度&amp;amp;最大传输单元 最大报文段长度(MSS):一般为1460
最大传输单元(MTU):一般为1500
之说以说一般，是因为一般来说TCP/IP的首部字段加起来是40字节
1500-40=1460
清除认识 当进程通过套接字把数据给到TCP的时候，数据就和进程没关系了，已经全权交给TCP了
为什么不是两次握手？ 这是书本上的一个问题
在我理解，握手其实是为了双方知道对方的初始序列号
 客户端给服务器端发送初始序列号
 服务器端收到了客户端的初始序列号，并且发送服务器端的初始序列号
  如果客户端不产生第三次握手，那么服务器端不知道客户端到底拿到了初始序列号没
 客户端看到回复后就知道服务器端拿到了自己的初始序列号，于是也和服务器端说明，已经拿到它的初始序列号了  四次挥手  客户端应用程序发起关闭连接
 发送报文里包含FIN
 服务器端发送一个ACK表示接收到了
 服务器端再次发一个FIN
 客户端给服务器端发一个ACK
 等待一会，资源就释放了
  </description>
    </item>
    
    <item>
      <title>TCP --报文</title>
      <link>https://wushaoqiang.github.io/posts/tcp-message-field/</link>
      <pubDate>Mon, 22 Apr 2019 12:14:31 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/tcp-message-field/</guid>
      <description> 之间写过一个关于《计算机网络(原书第六版)：自顶向下方法》的一部分笔记，当时没继续写下去是因为觉得一个篇幅太多了，决定分开写，这样可能可以更加详细点，也算是第二次的复习吧
这篇主要讲报文
先看看报文的格式
首先，TCP是运输层的协议，IP是网络层的协议，一般运输层协议会确定端口号，网络层协议则确定IP地址
 源/目的端口号
 序号/确认号：是用来双方实现可靠传输的(下面详细讲)
 接收窗口字段：用于流量控制(可能会在别的篇幅讲)
 首部长度：由于有选项这个字段，使得TCP的首部长度是可以变化的，不过通常就是20字节
 标志字段/紧急指针：标志字段包括确认字段有效、建立和拆除连接、紧急数据。紧急指针指向紧急数据
  序号/确认号 一条TCP连接的双发均可随机地选择初始序号，可能是0和4294967295之间的任意值
我们假设初始序号为0
A --&amp;gt; B Seq=42,ACK=79,data=1 B --&amp;gt; A Seq=79,ACK=43,data=2 A --&amp;gt; B Seq=43,ACK=80,data=3 ...  在我理解
序号是标识我要发送给对方的数据
确认号是标识我需要对方发送给我的数据
所以上面场景就是
A给B发序号为42的数据，并且向B要序号为79的数据 B收到了A的数据，并且返回A所要的序号为79的数据，并且B还想要A序号为43的数据 以此类推...  </description>
    </item>
    
    <item>
      <title>Leetcode 20</title>
      <link>https://wushaoqiang.github.io/posts/leetcode-20/</link>
      <pubDate>Mon, 22 Apr 2019 00:46:01 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/leetcode-20/</guid>
      <description>题目 给定一个只包括 &#39;(&#39;，&#39;)&#39;，&#39;{&#39;，&#39;}&#39;，&#39;[&#39;，&#39;]&#39; 的字符串，判断字符串是否有效。 有效字符串需满足： 左括号必须用相同类型的右括号闭合。 左括号必须以正确的顺序闭合。 注意空字符串可被认为是有效字符串。 示例 1: 输入: &amp;quot;()&amp;quot; 输出: true 示例 2: 输入: &amp;quot;()[]{}&amp;quot; 输出: true 示例 3: 输入: &amp;quot;(]&amp;quot; 输出: false 示例 4: 输入: &amp;quot;([)]&amp;quot; 输出: false 示例 5: 输入: &amp;quot;{[]}&amp;quot; 输出: true  我的解答 笔者在做这道题的时候想的稍微复杂了点，用了递归的方法做，但速度什么的非常慢，所以不值得参考，只能说一路摸坑吧
var ( relation = map[string]string{&amp;quot;(&amp;quot;: &amp;quot;)&amp;quot;, &amp;quot;[&amp;quot;: &amp;quot;]&amp;quot;, &amp;quot;{&amp;quot;: &amp;quot;}&amp;quot;} ) func isValid(s string) bool { if len(s) == 0 { return true } if (len(s)+2)%2 != 0 { return false } if len(s) == 2 { return string(s[1]) == relation[string(s[0])] } // l := len(s) for { idx := getLastIndex(s) if idx == -1 { return false } if !</description>
    </item>
    
    <item>
      <title>Leetcode 14</title>
      <link>https://wushaoqiang.github.io/posts/leetcode-14/</link>
      <pubDate>Mon, 22 Apr 2019 00:45:56 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/leetcode-14/</guid>
      <description>题目 编写一个函数来查找字符串数组中的最长公共前缀。 如果不存在公共前缀，返回空字符串 &amp;quot;&amp;quot;。 示例 1: 输入: [&amp;quot;flower&amp;quot;,&amp;quot;flow&amp;quot;,&amp;quot;flight&amp;quot;] 输出: &amp;quot;fl&amp;quot; 示例 2: 输入: [&amp;quot;dog&amp;quot;,&amp;quot;racecar&amp;quot;,&amp;quot;car&amp;quot;] 输出: &amp;quot;&amp;quot; 解释: 输入不存在公共前缀。 说明: 所有输入只包含小写字母 a-z 。  我的解答 func longestCommonPrefix(strs []string) string { if len(strs) == 0 { return &amp;quot;&amp;quot; } if len(strs) == 1 { return strs[0] } shortestLen := len(strs[0]) for _, str := range strs { if len(str) &amp;lt; shortestLen { shortestLen = len(str) } } var finalStr string for i := 0; i &amp;lt; shortestLen; i++ { tmp := strs[0][i] for j := 1; j &amp;lt; len(strs); j++ { if tmp !</description>
    </item>
    
    <item>
      <title>Leetcode 13</title>
      <link>https://wushaoqiang.github.io/posts/leetcode-13/</link>
      <pubDate>Mon, 22 Apr 2019 00:45:53 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/leetcode-13/</guid>
      <description>题目 罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。 字符 数值 I 1 V 5 X 10 L 50 C 100 D 500 M 1000 例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做 XXVII, 即为 XX + V + II 。 通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况： I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。 X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。 给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。 示例 1: 输入: &amp;quot;III&amp;quot; 输出: 3 示例 2: 输入: &amp;quot;IV&amp;quot; 输出: 4 示例 3: 输入: &amp;quot;IX&amp;quot; 输出: 9 示例 4: 输入: &amp;quot;LVIII&amp;quot; 输出: 58 解释: L = 50, V= 5, III = 3.</description>
    </item>
    
    <item>
      <title>Leetcode 9</title>
      <link>https://wushaoqiang.github.io/posts/leetcode-9/</link>
      <pubDate>Mon, 22 Apr 2019 00:45:41 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/leetcode-9/</guid>
      <description>题目 判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。 示例 1: 输入: 121 输出: true 示例 2: 输入: -121 输出: false 解释: 从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。 示例 3: 输入: 10 输出: false 解释: 从右向左读, 为 01 。因此它不是一个回文数。 进阶: 你能不将整数转为字符串来解决这个问题吗？  我的解答 func isPalindrome(x int) bool { str := strconv.Itoa(x) for i := 0; i &amp;lt; len(str)/2; i++ { if str[i] != str[len(str)-1-i] { return false } } return true }  转换为字符串进行比较就简单很多了,直接头尾比较，时间复杂度为O(N/2),N为字符串长度</description>
    </item>
    
    <item>
      <title>Leetcode 1</title>
      <link>https://wushaoqiang.github.io/posts/leetcode-1/</link>
      <pubDate>Mon, 22 Apr 2019 00:19:11 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/leetcode-1/</guid>
      <description>题目 给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。
你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。
示例:
给定 nums = [2, 7, 11, 15], target = 9 因为 nums[0] + nums[1] = 2 + 7 = 9 所以返回 [0, 1]  我的解答 func twoSum(nums []int, target int) []int { myMap := make(map[int]int) for idx,num := range nums{ myMap[num] = idx } for idx,num := range nums{ tmp := target - num if pos,exist := myMap[tmp]; exist{ if idx &amp;gt; pos{ return []int{pos,idx} } else if idx &amp;lt; pos{ return []int{idx,pos} }else{ continue } } } return nil }  方法是通过map来达到快速查找，而不像暴力法需要每次都遍历整个数组</description>
    </item>
    
    <item>
      <title>Leetcode 7</title>
      <link>https://wushaoqiang.github.io/posts/leetcode-7/</link>
      <pubDate>Mon, 22 Apr 2019 00:19:11 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/leetcode-7/</guid>
      <description>题目 给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。 示例 1: 输入: 123 输出: 321 示例 2: 输入: -123 输出: -321 示例 3: 输入: 120 输出: 21 注意: 假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为 [−2^31, 2^31 − 1]。请根据这个假设，如果反转后整数溢出那么就返回 0。  我的解答 func reverse(x int) int { var rev int for x != 0 { lastNum := x % 10 x = x / 10 if rev &amp;gt; math.MaxInt32/10 || rev == math.MaxInt32/10 &amp;amp;&amp;amp; lastNum &amp;gt; 7 { return 0 } if rev &amp;lt; math.</description>
    </item>
    
    <item>
      <title>Leetcode 开篇</title>
      <link>https://wushaoqiang.github.io/posts/leetcode-before-start/</link>
      <pubDate>Mon, 22 Apr 2019 00:00:37 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/leetcode-before-start/</guid>
      <description> 不积跬步无以至千里，不积小流无以成江海
 作为Leetcode的开篇作，在这里希望自己能够坚持每天code一两道题(视难度而定)
以后博客应该是以这样的方式呈现
### 题目 ### 我的解答 ### 最优解答 ### 难疑点&amp;amp;核心  </description>
    </item>
    
    <item>
      <title>Golang Pipeline</title>
      <link>https://wushaoqiang.github.io/posts/golang-pipeline/</link>
      <pubDate>Sun, 21 Apr 2019 10:59:13 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/golang-pipeline/</guid>
      <description>根据官网博客学习Pipeline
什么是Pipeline 管道其实就是一系列的Channel连接起来
 通过channel(可能不止一个)来接收数据
 处理数据
 用Channel向下传递数据(也可能不止一个)
  代码演示 package main import ( &amp;quot;fmt&amp;quot; &amp;quot;sync&amp;quot; ) func main() { // Set up a done channel that&#39;s shared by the whole pipeline, // and close that channel when this pipeline exits, as a signal // for all the goroutines we started to exit. done := make(chan struct{}) defer close(done) in := gen(done, 2, 3) // Distribute the sq work across two goroutines that both read from in.</description>
    </item>
    
    <item>
      <title>Golang make vs new</title>
      <link>https://wushaoqiang.github.io/posts/golang-makevsnew/</link>
      <pubDate>Sun, 21 Apr 2019 00:30:06 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/golang-makevsnew/</guid>
      <description>make和new的对象  make只能对slice、map、channel作用，比如不能make(int)
 new可以对任何类型作用
  make和new的返回值  make返回主体
 new也是返回指针，比如new(int)，返回一个int的指针，这个指针的内容是0
  初始化 两者都会初始化为“0”值
总结 所以我觉得它们最大的区别还是返回值的区别，以及作用对象</description>
    </item>
    
    <item>
      <title>Golang Map</title>
      <link>https://wushaoqiang.github.io/posts/golang-map/</link>
      <pubDate>Sat, 20 Apr 2019 20:03:42 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/golang-map/</guid>
      <description>Construct: m:=map[key]value{}
 Insert: m[k] = v
 Lookup: v = m[k]
 Delete: delete(m,k)
 lterate: for k,v := range m
 Size: len(m)
  Key不能为 maps,slices,funcs. 因为它们不可比较
Map底层 map header
len lg(#buckets) bucket array hash seed  流程  接收到一个key
 对key进行hash
 通过hash找到是哪一个bucket
 取hash前8bit作为extra(作为快速检查)
 找到bucket的内存(对不同的类型，大小会有不同)
  扩容  新创建一个两倍的空间
 复制entries到新的bucket，但是这里的复制是递增式的，因为如果一次性将很大的数据复制到一块内存，它会很耗费时间，但是这种方法就代表着，在扩容的时候，查找会变得慢了，因为要查找两块内存空间。这也决定了我们不能直接用指针指向map的某一个value，因为这个value可能扩容后就不在那了
 用新的bucket
  和其它Map比较  Go map不能用指针指向单个value
 迭代的时候，go map是可以修改的</description>
    </item>
    
    <item>
      <title>Golang Channel</title>
      <link>https://wushaoqiang.github.io/posts/golang-channel/</link>
      <pubDate>Sat, 20 Apr 2019 17:19:20 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/golang-channel/</guid>
      <description>这里就不再赘述重要性了
Channel特性  goroutine-safe
 两个goroutine之间传递数据
 FIFO
 cause goroutine to block and unblock
  What is the inside of channel  mutex
 send-index and recieve index
 buf
  Create a channel ch := make(chan int,3) //buffered chan ch := make(chan int) //sync chan  ch is a pointer
How it work Send  When it is going to send data to the channel, it will acquire the lock because it is going to modify.</description>
    </item>
    
    <item>
      <title>Golang Interface</title>
      <link>https://wushaoqiang.github.io/posts/golang-interface/</link>
      <pubDate>Sat, 20 Apr 2019 13:36:59 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/golang-interface/</guid>
      <description>在说接口之前，我们先说一下类型，类型在Go语言里面可以大致分为
 concrete type(具体类型,int,string&amp;hellip;)
 abstract type(抽象类型 io.Writer,io.Reader&amp;hellip;)
  具体类型我们知道它到底长什么样子，比如说int64，我们知道它在底层有8个字节
抽象类型我们不知道或者说我们不关注它长什么样，但我们知道它的用处，比如io.Writer是用来写的
具体化谈Interface 举个非常简单的例子，我们在读文件的时候，可能会这样做
func main() { f, err := os.Open(&amp;quot;abc.txt&amp;quot;) if err != nil { fmt.Println(err) } byte, _ := ioutil.ReadAll(f) fmt.Println(string(byte)) }  看一下ioutil.ReadAll()
func ReadAll(r io.Reader) ([]byte, error) { return readAll(r, bytes.MinRead) }  这里需要传入的是一个io.Reader接口，为什么*File类型传入一样可以呢
这里io.Reader是一个接口，接口里面只要一个函数
type Reader interface { Read(p []byte) (n int, err error) }  而*File里面也实现了这个接口的函数
func (f *File) Read(b []byte) (n int, err error) { if err := f.</description>
    </item>
    
    <item>
      <title>Golang Tips</title>
      <link>https://wushaoqiang.github.io/posts/golang-tips/</link>
      <pubDate>Thu, 18 Apr 2019 22:56:20 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/golang-tips/</guid>
      <description>关于select case runtime.GOMAXPROCS(1) int_chan := make(chan int, 1) string_chan := make(chan string, 1) int_chan &amp;lt;- 1 string_chan &amp;lt;- &amp;quot;hello&amp;quot; select { case value := &amp;lt;-string_chan: fmt.Println(value) case value := &amp;lt;-int_chan: panic(value) }  上面代码两个case都满足，会伪随机的执行一个
关于defer func DeferCalc() { a := 1 b := 2 defer calc(&amp;quot;1&amp;quot;, a, calc(&amp;quot;10&amp;quot;, a, b)) a = 0 defer calc(&amp;quot;2&amp;quot;, a, calc(&amp;quot;20&amp;quot;, a, b)) b = 1 time.Sleep(1 * time.Second) } func calc(index string, a, b int) int { ret := a + b fmt.</description>
    </item>
    
    <item>
      <title>Algorithm Sort</title>
      <link>https://wushaoqiang.github.io/posts/algorithm-sort/</link>
      <pubDate>Mon, 15 Apr 2019 20:03:27 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/algorithm-sort/</guid>
      <description>排序时间复杂度 堆排序 参考dreamcatcher-cx博客
最好最坏的平均时间复杂度都为O(NlogN)
代码 func HeapSortUp(a []int) []int { for i := len(a)/2 - 1; i &amp;gt;= 0; i-- { adjustHeapUp(a, i, len(a)) } for j := len(a) - 1; j &amp;gt; 0; j-- { a[0], a[j] = a[j], a[0] adjustHeapUp(a, 0, j) } return a } func adjustHeapUp(a []int, i int, length int) { tmp := a[i] for k := 2*i + 1; k &amp;lt; length; k = 2*k + 1 { if k+1 &amp;lt; length &amp;amp;&amp;amp; a[k+1] &amp;gt; a[k] { k++ } if a[k] &amp;gt; tmp { a[i] = a[k] i = k } else { break } } a[i] = tmp }  思路  先将数组变换为一个大顶堆</description>
    </item>
    
    <item>
      <title>Golang Gin</title>
      <link>https://wushaoqiang.github.io/posts/golang-gin/</link>
      <pubDate>Sun, 14 Apr 2019 23:12:41 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/golang-gin/</guid>
      <description> 中间件 在Gin的中间件可以这样定义，这是Gin定义的中间件的接口
func JWT() gin.HandlerFunc { return func(c *gin.Context){ //这个就和我们平时编写的路由函数一样了 } }  然后利用Use()函数注册进去
gin函数 //这三步和gin.Default()返回的Engine一样,之说gin.Default()会有一个输出消息 debugPrintWARNINGDefault() r := gin.New() r.Use(gin.Logger()) r.Use(gin.Recovery()) gin.SetMode(setting.RunMode)  分组 apiv1 := r.Group(&amp;quot;/api/v1&amp;quot;)  gin.HandlerFunc func GetTags(c *gin.Context){ }  Context方法 </description>
    </item>
    
    <item>
      <title>Golang Validation</title>
      <link>https://wushaoqiang.github.io/posts/golang-validation/</link>
      <pubDate>Sun, 14 Apr 2019 14:43:43 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/golang-validation/</guid>
      <description>Validation项目地址
创建 valid := validation.Validation{}  Validation方法 valid是创建过的对象
 valid.Required(name,&amp;quot;name&amp;quot;)：检验变量不能为空，字符串不能为&amp;quot;&amp;quot;,后面的&amp;quot;name&amp;quot;是用来标识而已
 valid.MaxSize(name,100,&amp;quot;name&amp;quot;)：最大长度
 valid.Range(state,0,1,&amp;quot;state&amp;quot;)：范围
 valid.HasErrors()：这个会返回布尔值，是否有不符合限定的内容
 valid.Errors：这个是一个Error数组，其中Error是这个包自带的，并不是标准库的error
 valid.Min(id,1,&amp;quot;id&amp;quot;)：id最小为1
  以上这些都返回*Result
Result方法 我们拿上面一个返回*Result对象做例子
 valid.Required(name,&amp;quot;name&amp;quot;).Message(&amp;quot;name不能为空&amp;quot;)  当加了Message后，发生错误返回*Error对象，Error.key就是name Error.Message就是上面的信息</description>
    </item>
    
    <item>
      <title>Golang Build blog with gin</title>
      <link>https://wushaoqiang.github.io/posts/golang-blog/</link>
      <pubDate>Sun, 14 Apr 2019 13:47:15 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/golang-blog/</guid>
      <description> Package  ini &amp;mdash;配置文件的读取
 com &amp;mdash;功能性
 validation &amp;mdash;做验证
 jwt-go &amp;mdash;Token
 endless &amp;mdash;服务器热启动
 swag &amp;mdash;API文档
  </description>
    </item>
    
    <item>
      <title>Golang标准库--os</title>
      <link>https://wushaoqiang.github.io/posts/golangstd-os/</link>
      <pubDate>Fri, 12 Apr 2019 20:24:48 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/golangstd-os/</guid>
      <description>Open与OpenFile的区别 笔者在某天遇到一个情况，用Open打开文件并且想写入发生了错误
bad file descriptor  检查过后发现Open在底层是调用了OpenFile，并且默认是只读的形式
// Open opens the named file for reading. If successful, methods on // the returned file can be used for reading; the associated file // descriptor has mode O_RDONLY. // If there is an error, it will be of type *PathError. func Open(name string) (*File, error) { return OpenFile(name, O_RDONLY, 0) }  所以要是想要自己定义打开的文件限制的话，就用OpenFile吧
// Flags to OpenFile wrapping those of the underlying system.</description>
    </item>
    
    <item>
      <title>Golang Path Problem</title>
      <link>https://wushaoqiang.github.io/posts/golang-path-problem/</link>
      <pubDate>Fri, 12 Apr 2019 17:28:21 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/golang-path-problem/</guid>
      <description>笔者在学习的路上遇到了一些关于路径的奇怪问题，想着这个问题都埋了这么久了，赶紧出来总结一下，以防下次再出现这类型错误
直接用相对路径 在os.Open()直接输入相对路径，这个相对路径决定于你的工作目录，如果工作目录发生改变，就不行了
filepath.Abs() filepath.Abs()是根据当前工作目录返回的绝对路径，这个和上面的不同在于，这个可以打开工作目录之前的文件，而上面的只能打开后面的文件
所谓前后是值文件夹的前后
所以写在程序里面，你在这个目录执行成功了，你退一个目录就不行了，因为这个时候工作路径改变了
笔者感觉这种方法不安全，或者我们写应用的时候指定要在某某目录执行，我有见过类似的项目
同一目录下，package都为main，不能调用 如果我们有两个文件，package都为main，比如是这样的
-main.go | -file.go  main.go想调用file.go的函数，会返回未定义的错误
有两种解决方法
 go install Or go build 转换为二进制文件执行
 go run *.go Or go run main.go file.go 这个表达意思一样的，把包含的文件都包含进去
  解决相对路径的最稳的方法 来自外国友人icza</description>
    </item>
    
    <item>
      <title>Nice Sentences</title>
      <link>https://wushaoqiang.github.io/posts/nice-sentences/</link>
      <pubDate>Fri, 12 Apr 2019 16:13:54 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/nice-sentences/</guid>
      <description> Don&amp;rsquo;t assume that you are right, just because nobody has proved you wrong
The bigger the interface, the weaker the abstraction &amp;ndash;Rob Pike
 </description>
    </item>
    
    <item>
      <title>Opinion</title>
      <link>https://wushaoqiang.github.io/posts/opinion/</link>
      <pubDate>Fri, 12 Apr 2019 16:13:32 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/opinion/</guid>
      <description> 关于在百度搜索问题 笔者在很早就体会到一点，百度搜出来的东西，理论价值真的不高
我开发遇到Bug第一时间去的都是google，基本第一页搞定我的问题
我在安装东西，工具最基本的使用，我会百度，因为这些东西肯定一大堆人在写
这也让我开始反思，写博客的人，应该以一种什么样的心态去写呢？
下面我总结出了两个点
 理论性较强的文章，应该多权威性的网站或者论坛(比如stackoverflow这类型的)，对比大家的意见，再结合自己对这些的想法和理解，写出一篇有深度的文章，而不仅仅停留在发现问题&amp;ndash;解决问题&amp;ndash;完事
 工具类型的文章，为了让自己能够在忘记怎么使用某一个工具时翻阅，属于一种笔记类型，不算文章
  </description>
    </item>
    
    <item>
      <title>Golang Log</title>
      <link>https://wushaoqiang.github.io/posts/golang-log/</link>
      <pubDate>Fri, 12 Apr 2019 01:34:09 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/golang-log/</guid>
      <description>笔者上面总结了一下网上关于错误处理和异常处理的资料，发现不知道什么时候要记录一个信息，什么时候不应该，再去找找别人的经验，总结到这篇博客。当然，笔者对标准库的log的接口表示有点少，而且输出的信息看起来有点累(虽然很多人喜欢标准库的log，但这里不讨论这个)，我将尝试着用用第三方库
我们做后台开发，无论有什么语言，都有相应的一套日志记录系统，并且日志记录的信息可能是一些小小的问题，也可能是一些大问题，这个时候就要分级处理了，很多人(包括我之前)都对分级这个界限划分的认识模糊，不知道什么时候该用什么级别的信息
在很多时候，log给我们提供的级别种类非常多，例如info、warning、debug、error等等，其实我对这些有些难以区分
在一些论坛上，大家也为这些发表意见，都有各自的道理，我把我觉得有道理的记录下来，以后我就会按照这样的一套标准(并非所有人的标准)来实现我的日志记录
先讲标准，在来简单分析一下第三方库的使用
warning  Nobody needs a warning log level
 警告是什么意思？出错了吗，还是没出错，不知道，有点模棱两可的感觉
所以要么是正常的信息输出(INFO)，要么就是错误
其实笔者后来觉得，warning可以在下面情况使用
 对，是出错了，但是经过我们的错误处理，在合适的尝试次数中成功了，这样我们可以给出警告，告诉开发者，这里曾经出过错  fatal 首先，在Go里面，Fatal是会调用os.Exit(1)的
这代表着什么样的结果(灾难)呢
 在其它线程的defer没有得到调用(比如一个文件的关闭在defer里，这样这个文件就未关闭，程序就挂了)
 缓冲区没有刷新(flush)，我们都知道，缓冲区要刷新，数据才能真正流入到我们想它到达的地方
 临时文件或者文件夹不会被移除(程序可能会生成临时文件，这是我们在结果中不想要的东西)
   It is commonly accepted that libraries should not use panic, but if calling log.Fatal has the same effect, surely this should also be outlawed.
 网上看到别人这样说，称panic,fatal应该属于违规操作
stackoverflow上赞同较多的答案说
 You should assume that a panic will be immediately fatal, for the entire program, or at the very least for the current goroutine.</description>
    </item>
    
    <item>
      <title>Golang Errandpanic</title>
      <link>https://wushaoqiang.github.io/posts/golang-errandpanic/</link>
      <pubDate>Thu, 11 Apr 2019 21:28:42 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/golang-errandpanic/</guid>
      <description>笔者在自己做一个小项目的时候，从0开始写呀写呀写，忽然发现代码里充满了错误处理，异常处理，乱七八糟，心情非常不好，所以是时候学习一下这方面的知识了，于是在网上搜索别的博主的总结
本文参考了张伯雨的博客 飞雪无情的博客 外国友人的博客
直观理解 虽然我一开始也知道错误和异常是两码事，但我处理起来就把它们当成一码事了，这是不对的，我们先从直观上去判断什么是错误，什么是异常
错误是我们意料之中的，比如我们在做一个Get请求，我们知道这个操作是有可能发生错误的(比如超时等)，意料之中的事情
异常是我们意料之外的事情，比如空指针、数组越界等，程序在编译阶段是无法辨认出数组越界，或者空指针的
 but unable to check mistakes like an out-of-bounds array, access or nil pointer deference which require checks at run time
 defer 说到异常就要提一下defer，它是一个关键字，用于延迟函数的执行，我们常见的是
... defer file1.Close() defer file2.Close() ...  当一个函数触发panic，或者正常的return，总之它所在的函数执行完毕了，这个时候就轮到defer的函数了
并且它是按照一个栈的形式来执行，也就是先进后出，在上面的例子中，file2会比file1先执行Close()
如果是panic，那么这个panic将会一直被传递上去，直到最后一个defer执行完毕
同样的功能，不同的设计 比如说，许多标准库里的函数，会有两种设计
 一般设计，如果输入有误，则返回错误
 异常设计，如果输入有误，直接抛出异常
  怎么看都觉得第二种好恐怖啊，动不动就抛出异常
其实不然，我们在编写程序的时候，有些时候是硬编码的，也就是说这个部分是很大概率不会出错的，比如说我们在调用template标准库时，我们写好的网页(H5)，一般来说到上线的时候都是固定死了的,所以在读取模板的时候基本不会出错，这个时候就不用再写错误处理了
凡事要有规则 异常处理的作用域
 空指针引用
 下标越界
 除数为0
 不应该出现的分支，比如我们在switch的时候，没有一个符合，就会到default分支
 输入不应该引起函数错误
  错误处理正确姿势 1.失败原因只有一个时，不用error 比如只是一些简单的判断，这个时候输出bool会更好</description>
    </item>
    
    <item>
      <title>Golang Crawler</title>
      <link>https://wushaoqiang.github.io/posts/golang-crawler/</link>
      <pubDate>Thu, 11 Apr 2019 17:35:02 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/golang-crawler/</guid>
      <description>笔者最近用了几天时间用Golang写一个爬虫并且做数据分析，先记录一下用了哪些包，方便后面总结
goquery --处理HTML标签 viper --读取配置文件 go-echarts --图表显示 gorm --Mysql数据库 golang-proxy --代理IP pkg/errors --更好追踪错误 logrus --美化log lfhook --为了生成log本地文件，与logrus配合使用  过程中遇到的错误(不分顺序)
 first path segment in URL cannot contain colon 这里把IP地址当做协议了，但是程序一样能运行，只要在IP地址前面加上//即可，就像//127.0.0.1:1080
 invalid memory address or nil pointer dereference 在我把IP替换成代理后，出现了这个情况，初步估计是resp.Body搞的鬼，在后面我多尝试几次后，也成功过。我在这里的做法是将函数重新调用(递归)，设置好递归的最大次数，如果超过这个次数就终止，或者使用下面的错误处理
  defer func () { if resp != nil { resp.Body.Close() } }()  单元测试 func TestCrawler(t *testing.T) { // keywords := []string{&amp;quot;golang&amp;quot;, &amp;quot;java&amp;quot;} keywords := &amp;quot;golang,java&amp;quot; refresh := &amp;quot;on&amp;quot; value := url.</description>
    </item>
    
    <item>
      <title>Golang Handle</title>
      <link>https://wushaoqiang.github.io/posts/golang-handle/</link>
      <pubDate>Thu, 11 Apr 2019 11:14:34 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/golang-handle/</guid>
      <description>本文主要解释Golang中http-handler几个容易混淆的概念
HandleFunc 源代码
在源码文件(net/http/server.go)中定义了一个默认的路由管理器(Mux)，我们如果直接调用
http.HandleFunc(...)  其实就用了默认的路由管理器，然后通过这个默认的路由器来调用路由管理器的方法
当然我们也可以自己定义一个路由管理器，然后通过这个对象来调用这些方法,和调用默认Mux不同的是
myMux.HandleFunc(...)  来看一下源码的这两个函数，验证上面所说的。
// HandleFunc registers the handler function for the given pattern // in the DefaultServeMux. // The documentation for ServeMux explains how patterns are matched. func HandleFunc(pattern string, handler func(ResponseWriter, *Request)) { DefaultServeMux.HandleFunc(pattern, handler) }  利用DefaultServeMux来调用HandleFunc()方法
// HandleFunc registers the handler function for the given pattern. func (mux *ServeMux) HandleFunc(pattern string, handler func(ResponseWriter, *Request)) { if handler == nil { panic(&amp;quot;http: nil handler&amp;quot;) } mux.</description>
    </item>
    
    <item>
      <title>Golang goquery</title>
      <link>https://wushaoqiang.github.io/posts/golang-goquery/</link>
      <pubDate>Mon, 08 Apr 2019 23:10:14 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/golang-goquery/</guid>
      <description>goquery是一个开源的库，针对解析HTML
今天在做爬虫的时候用到了一些功能，记录下来方便查阅
创建Document对象 doc, err := goquery.NewDocumentFromReader(resp.Body) if err != nil { log.Fatalf(&amp;quot;go query Error %s\n&amp;quot;, err) }  doc对象就包含了我们要解析的HTML主体
一般我们这样用，Find()里面的字符串就是我们要填写的规则
doc.Find(&amp;quot;div&amp;quot;).Each(func(i int, s *goquery.Selection) { fmt.Println(i,s.Text()) })  规则 我们可以根据HTML的源码分析对应的属性id，class等等
 div#id #id是某个div的id属性，筛选出此id的div标签
 div.class .class 同理，是class属性
 div[class],div[lang] 这个也是属性的筛选
 div&amp;gt;p div嵌套的p标签，这里规定只有一级标签，一级以后的p标签不会被筛选出来
 div p div嵌套的p标签，这里无论第几级都会被筛选出来
  属性可以和嵌套一起使用，例如div.class&amp;gt;p&amp;gt;li
Size num := doc.Find(&amp;quot;ul&amp;gt;li&amp;gt;div.job-primary&amp;quot;).Size()  取出标签内的属性 doc.Find(&amp;quot;ul&amp;gt;li&amp;gt;div.job-primary&amp;gt;div&amp;gt;h3&amp;gt;a&amp;quot;).Each(func(i int, s *goquery.Selection) { detail := s.Get(0).Attr[0].Val // fmt.Println(i, nextPage) jobs[i].Detail = detail })  我在这里踩过一个坑</description>
    </item>
    
    <item>
      <title>Golangstd Request</title>
      <link>https://wushaoqiang.github.io/posts/golangstd-request/</link>
      <pubDate>Mon, 08 Apr 2019 11:37:38 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/golangstd-request/</guid>
      <description>最近笔者看了一些源代码，也找了一些Web示例跟着学习，这次是Go源代码的request.go的学习总结
我们知道，在处理Web后端的时候，都会有两个参数http.ResponseWriter和*http.Request
所以Request是我们处理用户请求的接口，学习这个对Web开发也相当重要
Request结构体 type Request struct { Method string URL *url.URL Proto string // &amp;quot;HTTP/1.0&amp;quot; ProtoMajor int // 1 ProtoMinor int // 0 Header Header Body io.ReadCloser GetBody func() (io.ReadCloser, error) ContentLength int64 TransferEncoding []string Close bool Host string Form url.Values PostForm url.Values MultipartForm *multipart.Form Trailer Header RemoteAddr string RequestURI string TLS *tls.ConnectionState Cancel &amp;lt;-chan struct{} Response *Response ctx context.Context }  下面详细介绍每个字段的意义
Method 这就是一个请求的方法(如GET、POST)
但是Go的HTTP客户端不支持发送方法为CONNECT的请求
URL  // URL specifies either the URI being requested (for server // requests) or the URL to access (for client requests).</description>
    </item>
    
    <item>
      <title>Golang Gorm</title>
      <link>https://wushaoqiang.github.io/posts/golang-gorm/</link>
      <pubDate>Fri, 05 Apr 2019 20:37:11 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/golang-gorm/</guid>
      <description>连接数据库 Mysql db, err := gorm.Open(&amp;quot;mysql&amp;quot;, &amp;quot;root:123456@tcp/test?charset=utf8&amp;amp;parseTime=True&amp;quot;) if err != nil { panic(&amp;quot;连接数据库失败&amp;quot;) } defer db.Close() db.SingularTable(true)  选定好数据库后一般会配上
db.SingularTable(true)  如果不调用这个函数，当在数据库加入某个表单的时候，名字会自动加一个s
比如db.CreateTable(&amp;amp;Product{})，在数据库表单里面会得到一个名字为products
所以一般都会加上这个函数
创建Table db.CreateTable(&amp;amp;Product{})  创建多个table
db.CreateTable(&amp;amp;Product{},&amp;amp;User{})  删除Table 关于删除，有两个
db.DropTableIfExist(interface{}) db.DropTable(interface{})  这里可以传入字符串，也可以传入一个结构体
接着上面的例子
db.DropTableIfExist(&amp;quot;product&amp;quot;) db.DropTableIfExist(&amp;amp;Product{})  删除Column 删除Column是要指定Table，所以不能这样
db.DropColumn(&amp;quot;created_at&amp;quot;)  要定位Table，则需要
db.Model(&amp;amp;Product).DropColumn(&amp;quot;created_at&amp;quot;)  创建数据 db.Create(&amp;amp;Product{Code: &amp;quot;L1213&amp;quot;, Price: 1002})  查询数据 // 最后一个符合条件，默认id最后的那个 // Get last record, order by primary key db.Last(&amp;amp;user) //// SELECT * FROM users ORDER BY id DESC LIMIT 1; // 将所有符合条件的返回，这里要传一个结构体数组 // Get all records db.</description>
    </item>
    
    <item>
      <title>Golang Viper</title>
      <link>https://wushaoqiang.github.io/posts/golang-viper/</link>
      <pubDate>Fri, 05 Apr 2019 17:41:18 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/golang-viper/</guid>
      <description>Github
 Viper is a complete configuration solution for Go applications
 这是一个帮组我们读取配置文件的包，总结一些方法，方便以后使用
Reading Config Files  a single Viper instance only supports a single configuration file
 一个Viper对象只能对应一个配置文件，是一个一一对应的映射关系
但是我们在搜索配置文件的时候，可以设置多个路径，如果没有设置路径，则当前程序的目录上寻找，所以我们要设置好路径
这是Github上的一个例子
viper.SetConfigName(&amp;quot;config&amp;quot;) // name of config file (without extension) viper.AddConfigPath(&amp;quot;/etc/appname/&amp;quot;) // path to look for the config file in viper.AddConfigPath(&amp;quot;$HOME/.appname&amp;quot;) // call multiple times to add many search paths viper.AddConfigPath(&amp;quot;.&amp;quot;) // optionally look for config in the working directory err := viper.</description>
    </item>
    
    <item>
      <title>Learn Gitflow</title>
      <link>https://wushaoqiang.github.io/posts/learn-gitflow/</link>
      <pubDate>Wed, 03 Apr 2019 23:27:50 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/learn-gitflow/</guid>
      <description>gitflow是一种规范，适合大项目开发
Github上开源了一个遵循这样规范的一个Git工具gitflow
初始化一个git git flow init  然后会提醒一系列创建操作，类似
Which branch should be used for bringing forth production releases? Branch name for production releases: [master] Which branch should be used for integration of the &amp;quot;next release&amp;quot;? Branch name for &amp;quot;next release&amp;quot; development: [develop] How to name your supporting branch prefixes? Feature branches? [feature/] Bugfix branches? [bugfix/] Release branches? [release/] Hotfix branches? [hotfix/] Support branches? [support/] Version tag prefix? [] Hooks and filters directory?</description>
    </item>
    
    <item>
      <title>Golang Mega</title>
      <link>https://wushaoqiang.github.io/posts/golang-mega/</link>
      <pubDate>Mon, 01 Apr 2019 15:12:46 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/golang-mega/</guid>
      <description>不积跬步无以至千里，不积小流无以成江海
 本文是博主在学习基础记录的笔记
2019-04-01到2019-04-04，后面会自己DIY一些内容上去(想做成一个小小的技术论坛)
先来总体看一下整个项目的目录吧
. ├── cmd │ └── db_init │ └── main.go ├── config │ └── g.go ├── config.yml ├── controller │ ├── g.go │ ├── home.go │ ├── middle.go │ └── utils.go ├── main.go ├── model │ ├── g.go │ ├── post.go │ ├── user.go │ └── utils.go ├── templates │ ├── 404.html │ ├── _base.html │ ├── content │ │ ├── explore.html │ │ ├── index.</description>
    </item>
    
    <item>
      <title>Questions Network</title>
      <link>https://wushaoqiang.github.io/posts/questions-network/</link>
      <pubDate>Tue, 26 Mar 2019 17:27:44 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/questions-network/</guid>
      <description>这篇文章是要记录在学习网络基础相关知识的时候遇到的问题与解答
IP Q: 为什么我电脑的IP(172.29.15.243)可以访问外面的网络
A: 我们知道某些专用网络的地址在外部是访问不到的，比如学校内部网不可以直接从外部访问，要通过VPN。我们之所以能够用专用网络分配给我们的地址访问外部网络，是因为我们在访问因特网时，IP地址会被NAT转换。
Session 在mega项目里遇到一个问题
首先，我访问服务器，服务器将会返回一个Session给我，那么我在这个网页游走都可以用这个Session，没毛病
现在我Logout，这个时候服务器调用函数将Session的期限变为-1，也就是将Session过期
这个时候我把之前服务器给我的Session自己存起来，用Postman构造一个请求，并且附上这个Session(其实是通过Cookie传)，这个时候服务器不会因为将Session期限改为-1而不认识这个Session
所以这个现象表明所谓的清除只是服务器给浏览器发送的Cookie期限设置为-1，然后浏览器看到Cookie已经过期了，因此就不用了
这样也就验证了，一个用户在服务器上只有一个Session id？
resp.Body resp, err := http.DefaultClient.Do(req) if err != nil { log.Fatalf(&amp;quot;Do Error %s\n&amp;quot;, err) } defer resp.Body.Close() body, err := ioutil.ReadAll(resp.Body) if err != nil { log.Fatalf(&amp;quot;ReadAll Error %s\n&amp;quot;, err) } // fmt.Println(string(body)) file, err := os.Create(path + keyword + &amp;quot;.html&amp;quot;) if err != nil { log.Fatalf(&amp;quot;Create File Error %s\n&amp;quot;, err) } defer file.Close() _, err = file.</description>
    </item>
    
    <item>
      <title>Golang标准库--http</title>
      <link>https://wushaoqiang.github.io/posts/golangstd-net-http/</link>
      <pubDate>Tue, 19 Mar 2019 20:52:05 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/golangstd-net-http/</guid>
      <description>这篇文章是为了探索Golang中net/http包的实现，笔者暂时只会把主要脉络摸清，具体某些实现逻辑暂不考究，是一篇比较基础的源码阅读文章。
Package http doc.go 先来看看官方对这个包的一个解释
这里说到，这个包是为HTTP提供客户端和服务器端的实现的。
这里还举了一些方法的例子
// Copyright 2011 The Go Authors. All rights reserved. // Use of this source code is governed by a BSD-style // license that can be found in the LICENSE file. /* Package http provides HTTP client and server implementations. Get, Head, Post, and PostForm make HTTP (or HTTPS) requests: resp, err := http.Get(&amp;quot;http://example.com/&amp;quot;) ... resp, err := http.Post(&amp;quot;http://example.com/upload&amp;quot;, &amp;quot;image/jpeg&amp;quot;, &amp;amp;buf) ... resp, err := http.</description>
    </item>
    
    <item>
      <title>一些名词的定义</title>
      <link>https://wushaoqiang.github.io/posts/definition/</link>
      <pubDate>Tue, 19 Mar 2019 20:07:44 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/definition/</guid>
      <description>这里是为了记录一些常用名词的定义，大多参照百度百科和Wiki
句柄 句柄是一种特殊的智能指针 。当一个应用程序要引用其他系统（如数据库、操作系统）所管理的内存块或对象时，就要使用句柄
在Golang里面，我们使用函数打开一个文件得到的就是一个文件句柄(打开的文件就是操作系统所管理的内存块)
在Golang里面，我们使用数据库的驱动连接数据库时，返回的也是一个句柄，这个返回值只是一个对象，并不是一个连接
Redis  redis是一个key-value存储系统。和Memcached类似，它支持存储的value类型相对更多，包括string(字符串)、list(链表)、set(集合)、zset(sorted set &amp;ndash;有序集合)和hash（哈希类型）。这些数据类型都支持push/pop、add/remove及取交集并集和差集及更丰富的操作，而且这些操作都是原子性的。在此基础上，redis支持各种不同方式的排序。与memcached一样，为了保证效率，数据都是缓存在内存中。区别的是redis会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件，并且在此基础上实现了master-slave(主从)同步。
 TLS  传输层安全性协议（英语：Transport Layer Security，缩写作TLS），及其前身安全套接层（Secure Sockets Layer，缩写作SSL）是一种安全协议，目的是为互联网通信提供安全及数据完整性保障。
安全传输层协议（TLS）用于在两个通信应用程序之间提供保密性和数据完整性。 该协议由两层组成： TLS 记录协议（TLS Record）和 TLS 握手协议（TLS Handshake）。
 Cookie&amp;amp;Session Cookie Cookie是客户端保持状态
Cookie的内容主要包括：名字，值，过期时间，路径和域
若不设置过期时间，则表示这个cookie的生命期为浏览器会话期间，关闭浏览器窗口，cookie就消失。这种生命期为浏览器会话期的cookie被称为会话cookie
Session Session是服务器端保持状态
一个用户在服务器上拥有唯一的一个session Id
如果一个用户不断在请求同一个东西或者行为异常(爬虫？)，则可以对这个用户进行相应操作
Session能够记录用户的动作，比如淘宝能够记录你购物车有多少东西
Difference 我们拿淘宝作例子
我们登录淘宝不用账号密码的时候用的就是Cookie
但是我们在挑选商品加入购物车，淘宝的服务器也在记录我们的动作信息(比如添加商品)，这个时候用的是Session
所以我们可以用Session来跟踪用户的动作。
安全性 Session会比Cookie安全，因为Cookie可能会被欺骗(Cookie在一定程度上就算是你的用户名和密码，被人获取后，别人就可以用你的身份来做事了)</description>
    </item>
    
    <item>
      <title>Golang Exercism</title>
      <link>https://wushaoqiang.github.io/posts/golang-exercism/</link>
      <pubDate>Sun, 17 Mar 2019 02:15:05 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/golang-exercism/</guid>
      <description>Exercism &amp;ndash; Bob 我的方法：(总之非常愚蠢就是了)
func Hey(remark string) string { // Write some code here to pass the test suite. // Then remove all the stock comments. // They&#39;re here to help you get started but they only clutter a finished solution. // If you leave them in, reviewers may protest! if strings.EqualFold(remark, &amp;quot;&amp;quot;) { return &amp;quot;Fine. Be that way!&amp;quot; } whitespace := true for _, item := range []byte(remark) { if !</description>
    </item>
    
    <item>
      <title>Mysql学习笔记</title>
      <link>https://wushaoqiang.github.io/posts/mysql-basic/</link>
      <pubDate>Sun, 17 Mar 2019 02:14:18 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/mysql-basic/</guid>
      <description>安装 sudo apt-get install mysql-server mysql-client
查询是否安装了： sudo netstat -tap grep mysql
安装成功
tcp 0 0 localhost:mysql 0.0.0.0:* LISTEN 31238/mysqld  整个安装过程没有叫输入密码
登录 打开debian.cnf文件： sudo nano /etc/mysql/debian.cnf
# Automatically generated for Debian scripts. DO NOT TOUCH! [client] host = localhost user = debian-sys-maint password = x7McPCywm2p7SsnZ socket = /var/run/mysqld/mysqld.sock [mysql_upgrade] host = localhost user = debian-sys-maint password = x7McPCywm2p7SsnZ socket = /var/run/mysqld/mysqld.sock  这里面有一个叫debian-sys-maint的user
登录debian-sys-maint： mysql -u debian-sys-maint -p</description>
    </item>
    
    <item>
      <title>Go圣经读书笔记</title>
      <link>https://wushaoqiang.github.io/posts/golang-bible/</link>
      <pubDate>Sun, 17 Mar 2019 02:13:08 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/golang-bible/</guid>
      <description>第一章 入门 命令行参数 os.Args变量是一个字符串的切片，并且它的第一个元素是命令本身的名字
func main() { var s, sep string for i := 0; i &amp;lt; len(os.Args); i++ { s += sep + os.Args[i] sep = &amp;quot; &amp;quot; } fmt.Println(s) }  运行go run main.go 123
输出/tmp/go-build115927302/b001/exe/main 123
查找重复的行  input := bufio.NewScanner(os.stdin) ~ func NewScanner(r io.Reader) *Scanner  返回一个从r读取的Scanner
 func (s *Scanner) Scan() bool  逐行扫描，当scan停止的时候，或者是到了读取的终点，又或者是发生了错误，这里都会返回false
 func (s *Scanner) Text() string  返回scanner所在行的文本
counts := make(map[string]int) input := bufio.</description>
    </item>
    
    <item>
      <title>Go语言实战</title>
      <link>https://wushaoqiang.github.io/posts/golang-inaction/</link>
      <pubDate>Sun, 17 Mar 2019 02:11:56 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/golang-inaction/</guid>
      <description>Go语言优点：
 Go语言可以说是夹在C/C++和Python这两类语言之间，即提供了较高的性能，又使得开发更加迅速了。
 Go语言内置并发机制，对并发有着更好的性能
 Go语言自带垃圾回收器
 goroutine使用的内存比线程要少，所以常常能够成千上万个goroutine并发
  第六章 并发 概念  进程：当运行一个应用程序时，操作系统会为这个应用程序启动一个进程，可以将这个进程看作一个包含了应用程序在运行中需要用到和维护的各种资源 线程：一个线程是一个空间，这个空间会被操作系统调度来运行函数中所写的代码，线程会被调度到CPU上运行。 每个逻辑处理器绑定在一个线程上 逻辑处理器可以调度goroutine 并发：某一个事情的停止，另一个事情就开始(单线程) 并行：同时开始做(多线程)  goroutine 一个创建goroutine的示例 package main import ( &amp;quot;fmt&amp;quot; &amp;quot;runtime&amp;quot; &amp;quot;sync&amp;quot; ) // main is the entry point for all Go programs. func main() { // Allocate 1 logical processor for the scheduler to use. runtime.GOMAXPROCS(1) // wg is used to wait for the program to finish. // Add a count of two, one for each goroutine.</description>
    </item>
    
    <item>
      <title>Go语言高级编程</title>
      <link>https://wushaoqiang.github.io/posts/golang-highlevel/</link>
      <pubDate>Sun, 17 Mar 2019 02:09:45 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/golang-highlevel/</guid>
      <description>感谢 在文章开头感谢两位作者:柴树杉和曹春晖
这篇文章是开源的，欢迎大家去阅读
本篇博客是笔者对这篇文章的理解，引用的图片也是来自原文，如有侵权请告知！
第一章 基础 1.3 数组、字符串和切片  Go语言的数组是一种值类型，虽然数组的元素可以被修改，但是数组本身的赋值和函数传参都是以整体复制的方式处理的
 Go语言字符串底层数据也是对应的字节数组，但是字符串的只读属性禁止了在程序中对底层字节数组的元素的修改字符串赋值只是复制了数据地址和对应的长度，而不会导致底层数据的复制
 切片头含有底层数据的指针，所以它的赋值也不会导致底层数据的复制
  字符串  字符串的元素不可修改，是一个只读的字节数组
 字符串虽然不是切片，但是支持切片操作
type StringHeader struct { Data uintptr Len int }  字符串结构由两个信息组成：第一个是字符串指向的底层字节数组，第二个是字符串的字节的长度。
  切片 type SliceHeader struct { Data uintptr Len int Cap int }  a = append(a, 0) // 切片扩展1个空间 copy(a[i+1:], a[i:]) // a[i:]向后移动1个位置 a[i] = x // 设置新添加的元素  copy将a[i:]直接搬到了a[i+1:]这个时候就可以在a[i]插入
这种做法可以减少中间创建的临时切片
copy append可以完成切片的添加 删除 插入操作</description>
    </item>
    
    <item>
      <title>Golang--Leetcode</title>
      <link>https://wushaoqiang.github.io/posts/golang-leetcode/</link>
      <pubDate>Sun, 17 Mar 2019 02:07:37 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/golang-leetcode/</guid>
      <description>此文章为做题时发现的不足
 Go语言中的结构体直接赋值是==值传递==，如果要用引用传递，需要这样struct1 := &amp;amp;struct2，也就是要使用取地址符号。但是如果本来struct2就是一个指针，那么就可以直接赋值了。 go func addTwoNumbers(l1 *ListNode, l2 *ListNode) *ListNode { Head := ListNode{} curr := &amp;amp;Head  &amp;mdash;-  给定一个字符串，找出其中不含有重复字符的最长子串的长度方法 - 穷举法：
func lengthOfLongestSubstring(s string) int { var max = 0 for i := 0; i &amp;lt; len(s); i++ { m := make(map[string]bool) for j := i; j &amp;lt; len(s); j++ { if _, ok := m[s[j:j+1]]; !ok { m[s[j:j+1]] = true if j == len(s)-1 { if max &amp;lt; j-i+1 { max = j - i + 1 } } } else { if max &amp;lt; j-i { max = j - i } break } } } return max }   另一个方法： ```go func lengthOfLongestSubstring(s string) int { var max = 0 i := 0 m := make(map[string]int) for j := 0; j &amp;lt; len(s); j++ {  	if _, ok := m[s[j:j+1]]; ok {</description>
    </item>
    
    <item>
      <title>Golang标准库--Unicode</title>
      <link>https://wushaoqiang.github.io/posts/golangstd-unicode/</link>
      <pubDate>Sun, 17 Mar 2019 02:06:01 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/golangstd-unicode/</guid>
      <description>unicode package utf8 utf8.go 这里就不详细分析源码了，只说函数的作用
&amp;mdash; FullRune(p []byte) bool  FullRune报告p中的字节是否以一个rune的完整UTF-8编码开始。
 无效的编码被认为是完整的rune，因为它将转换为宽度为1的错误符文rune。
&amp;mdash; FullRuneInString(s string) bool 和FullRune一样，只是传入了字符串
&amp;mdash; DecodeRune(p []byte) (r rune, size int) 这个函数将切片p中第一个rune返回，并且返回这个rune的大小。
如果p是空的，那么会返回RuneError,0
如果切片中的编码是无效的，那么会返回RuneError,1,对应上一个函数，当编码无效时依然返回true
&amp;mdash; DecodeRuneInString(s string) (r rune, size int) 同上，只是参数变成了字符串
&amp;mdash; func DecodeLastRune(p []byte) (r rune, size int) 只是从后面开始了，功能一样。
&amp;mdash; DecodeLastRuneInString(s string) (r rune, size int) 如上，参数换了字符串
&amp;mdash; RuneLen(r rune) int 返回一个rune的长度，也就是其大小
&amp;mdash; EncodeRune(p []byte, r rune) int 这个就是将rune写入到byte切片上
&amp;mdash; RuneCount(p []byte) int 返回整个切片里面rune的个数</description>
    </item>
    
    <item>
      <title>Golang标准库--String</title>
      <link>https://wushaoqiang.github.io/posts/golangstd-string/</link>
      <pubDate>Sun, 17 Mar 2019 02:04:07 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/golangstd-string/</guid>
      <description>目录 strings builder.go Builder 结构体 noescape(p unsafe.Pointer) unsafe.Pointer &amp;amp; copyCheck() (b *Builder) String() string &amp;amp; (b *Builder) Len() int &amp;amp; (b *Builder) Reset() (b *Builder) Grow(n int) 关于Write的方法 reader.go Reader 结构体 (r *Reader) Len() int &amp;amp; (r *Reader) Size() int64 关于读的方法 (r *Reader) UnreadRune() error (r *Reader) Seek(offset int64, whence int) (int64, error) strings.go  strings builder.go Builder 相当于bytes里面的buffer，并且方法也差不多。但是buffer更加全面
&amp;mdash; 结构体 // A Builder is used to efficiently build a string using Write methods.</description>
    </item>
    
    <item>
      <title>Golang标准库--Bytes</title>
      <link>https://wushaoqiang.github.io/posts/golangstd-bytes/</link>
      <pubDate>Sun, 17 Mar 2019 02:03:03 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/golangstd-bytes/</guid>
      <description>目录 bytes buffer.go Buffer 结构体 const of readOp (b *Buffer) Bytes() []byte (b *Buffer) String() string (b *Buffer) empty() bool (b *Buffer) Len() int (b *Buffer) Cap() int (b *Buffer) Truncate(n int) (b *Buffer) Reset() (b *Buffer) tryGrowByReslice(n int) (int, bool) (b *Buffer) grow(n int) int (b *Buffer) Grow(n int) (b *Buffer) Write(p []byte) (n int, err error) (b *Buffer) WriteString(s string) (n int, err error) makeSlice(n int) []byte (b *Buffer) WriteTo(w io.</description>
    </item>
    
    <item>
      <title>Golang标准库--Bufio</title>
      <link>https://wushaoqiang.github.io/posts/golangstd-bufio/</link>
      <pubDate>Sun, 17 Mar 2019 01:59:52 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/golangstd-bufio/</guid>
      <description>目录 bufio bufio.go 常量 Reader 结构体 常量 NewReaderSize(rd io.Reader, size int) *Reader NewReader(rd io.Reader) *Reader (r *Reader) Size() int (b *Reader) Reset(r io.Reader) &amp;amp; (b *Reader) reset(buf []byte, r io.Reader) (b *Reader) fill() (b *Reader) Peek(n int) ([]byte, error) (b *Reader) Discard(n int) (discarded int, err error) (b *Reader) Read(p []byte) (n int, err error) (b *Reader) ReadByte() (byte, error) (b *Reader) UnreadByte() (b *Reader) ReadRune() (r rune, size int, err error) (b *Reader) UnreadRune() error (b *Reader) Buffered() int (b *Reader) ReadSlice(delim byte) (line []byte, err error) (b *Reader) ReadLine() (line []byte, isPrefix bool, err error) (b *Reader) ReadBytes(delim byte) ([]byte, error) (b *Reader) ReadString(delim byte) (string, error) (b *Reader) WriteTo(w io.</description>
    </item>
    
    <item>
      <title>网络协议基础</title>
      <link>https://wushaoqiang.github.io/posts/internet-protocal/</link>
      <pubDate>Sun, 17 Mar 2019 01:58:00 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/internet-protocal/</guid>
      <description>OSI模型把网络通信的工作分为7层，分别是物理层、数据链路层、网络层、传输层、会话层、表示层和应用层
一直觉得自己的基础很不牢固，事实也确实是这样，希望自己能够系统的总结好计算机网络这本书
二、应用层 Web、电子邮件、DNS和对等文件分发等
2.1 应用层协议原理 2.1.1 网络应用程序体系结构 应用程序体系结构
 客户-服务器体系结构
 对等体系结构(P2P)
  现在大多数应用都是以客户-服务器体系结构
P2P面临的挑战
 下载比上传多很多
 安全性
 用户是否能自愿提供带宽、存储和计算资源
  最近比较火的一个名词区块链就是倡导去中心化的网络，也就是P2P
2.1.2 进程通信 在同一个端系统上(可以理解为同一部电脑)，进程间通信的规则由端系统上的操作系统决定
在不同端系统上，通过跨越计算机网络交换报文来相互通信
2.1.2.1 客户和服务器进程 发起通信的进程就是客户
等待联系的进程是服务器
2.1.2.2 进程与计算机网络之间的接口 进程通过一个称为套接字的软件接口向网络发送报文和从网络接收报文
这个套接字就好比如一个房子的大门，发送或者接收都要先开门
而这里把进程比作房子，运输层协议(TCP等)比作两个房子的路
所以套接字是应用层和运输层的接口，也叫应用程序编程接口(API)
2.1.2.3 进程寻址 主机由IP地址标识
指定的进程由端口号标识
2.1.3 可供应用程序使用的运输服务 根据运输层所提供的服务来决定用哪种运输层协议
2.1.3.1 可靠数据传输 当一个运输协议提供这种服务时，发送进程只要将其数据传递进套接字，就可以完全相信该数据将能无差错地到达接收进程
有些能够容忍数据丢失的应用可以不使用可靠数据传输
2.1.3.2 吞吐量 吞吐量就是发送进程能够向接收进程交付比特的速率
具有吞吐量要求的应用被称为带宽敏感应用
否则就称为弹性应用
2.1.3.3 定时 对于实时要求较高的应用
2.1.3.4 安全性 防止数据以某种方式在两个进程之间被观察到
安全包括
 机密性
 完整性
 端点鉴别</description>
    </item>
    
    <item>
      <title>Web框架</title>
      <link>https://wushaoqiang.github.io/posts/web-strcuture/</link>
      <pubDate>Sun, 17 Mar 2019 01:53:57 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/web-strcuture/</guid>
      <description>这篇文章是参考人世间博主写的一篇文章，这里哪里作为自己了解Gin框架的例子，笔者想在这做初步了解后再去深入了解源码，到时候再写一篇博客来说说Gin源码。
Gin 路由常用方法 func (group *RouterGroup) POST(relativePath string, handlers ...HandlerFunc) IRoutes func (group *RouterGroup) GET(relativePath string, handlers ...HandlerFunc) IRoutes type HandlerFunc func(*Context)  可以看出路由需要的参数是
 相对路径
 处理函数
  这里面是Gin自己定义的一个HandlerFunc，和标准库里面的有所不同，这里的gin.*Context包含了标准库里的ResponseWriter和*http.Request还有一些其它
介绍一些函数 // Query()	是匹配url上的参数，匹配不到就返回空字符串 // DefaultQuery() 也是匹配，如果匹配不到就用默认值 // 127.0.0.1:8000/post?id=111&amp;amp;page=222 // 如果用curl，则需要在&amp;amp;前面加\ id := c.Query(&amp;quot;id&amp;quot;) page := c.DefaultQuery(&amp;quot;page&amp;quot;, &amp;quot;0&amp;quot;) //这个是在表单上获取信息，通过POST方法发送过来的数据 name := c.PostForm(&amp;quot;name&amp;quot;) message := c.PostForm(&amp;quot;message&amp;quot;)  一个完整的路由 router.GET(&amp;quot;/welcome&amp;quot;, func(c *gin.Context) { firstname := c.DefaultQuery(&amp;quot;firstname&amp;quot;, &amp;quot;Guest&amp;quot;) lastname := c.Query(&amp;quot;lastname&amp;quot;) c.</description>
    </item>
    
    <item>
      <title>Linux命令笔记</title>
      <link>https://wushaoqiang.github.io/posts/linux-note/</link>
      <pubDate>Sun, 17 Mar 2019 01:52:15 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/linux-note/</guid>
      <description>Command 这里只是笔者对Linux常用命令的笔记，方便自己查询
ifconfig 查看网络连接
lsof -i:8000 查看端口8000占用情况
kill -9 PID 把某个PID的进程结束了
mkdir -p /1/2/3/4 可以一次创建多层文件夹
pkill -f &amp;lt;name&amp;gt; 可以直接kill掉一个已知名字的进程
把脚本放进/etc/init.d/里面就可以自启动
chown user:group &amp;lt;file&amp;gt; 改变文件持有
磁盘 du -hsc &amp;lt;path&amp;gt; 查看路径占用磁盘大小
ncdu 更友好的查看磁盘占用情况的一个命令，需要安装
df -h查看磁盘占用情况
别名 alias &amp;lt;name&amp;gt;=&amp;quot;&amp;lt;command&amp;gt;&amp;quot; 用别名调用命令(适用于长命令)，如果需要持久化的话，需要写入.bashrc
查找文件 find &amp;lt;path&amp;gt; -name &amp;quot;*.log&amp;quot; 寻找在路径里面结尾为.log的文件，同理，想要查找一类文件可以用这个命令
find &amp;lt;path&amp;gt; ! -name &amp;quot;*.log&amp;quot; 与上面刚好相反
find -mtime &amp;lt;number&amp;gt;这个命令还可以根据修改时间
匹配 grep -r &amp;quot;error&amp;quot; &amp;lt;path or file&amp;gt; 会打印出所有含有error的字段
查看CPU&amp;amp;内存占用情况 top 这个命令对界面不太友好
htop 这个对阅读更加友好
update 能够看到电脑持续开机时间
查看Linux发行版本 cat /proc/version or lsb_release -a</description>
    </item>
    
    <item>
      <title>Hugo建博客</title>
      <link>https://wushaoqiang.github.io/posts/learn-hugo/</link>
      <pubDate>Sat, 16 Mar 2019 22:33:20 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/learn-hugo/</guid>
      <description>笔者用的是Hugo来搭建个人博客，表示Hugo实在太强，而且可扩展性很高，这也代表文档也很长。。。
所以笔者收录一些比较常用的作为笔记，也希望能够帮到别人
以下命令都是以我自己建博客的为例
创建一个网站 hugo new site blog 这个命令会在目录里创建一个新的blog目录
这个blog目录包含以下：
 archetypes/ content/ data/ layouts/ static/ themes/ config.toml  archetypes/ 这里一开始会有一个default文件，后面再讲有什么用，先看看文件
--- title: &amp;quot;{{ replace .Name &amp;quot;-&amp;quot; &amp;quot; &amp;quot; | title }}&amp;quot; date: {{ .Date }} draft: true ---  content/ 这里就是博客的主要内容的根目录，我们创建的博客文章就应该放在这个文件夹里(不是直接)
创建一个博客文章hugo new posts/learn-hugo.md，创建完后会发现文件在content/posts/learn-hugo.md
打开文件看一下，可以发现创建的新文件里面是有内容的
--- title: &amp;quot;Learn Hugo&amp;quot; date: 2019-03-16T22:33:20+08:00 draft: true ---  这就和我们上面说到的archetypes/default.md有关，这里可以自动填充一些信息，方便我们写博客
theme/ 这里是放置博客主题的文件夹，Hugo有很多开源的主题，可以去官网找找看，笔者用的是飞雪无情这位博主开源出来的Maupassant，笔者刚开始也按照这位博主的配置方法来配置博客，等后面对Hugo的配置了解更加深入时，再尝试配置。Maupassant的仓库地址，大家还可以顺手点个星，表示支持
具体如何安装也很简单，可以参照github的使用方法
config.toml 这个文件是配置我们的一些博客信息以及Hugo的配置
## 这个是我们主页的地址 baseURL = &amp;quot;https://wushaoqiang.github.io&amp;quot; languageCode = &amp;quot;en-us&amp;quot; ## 博客的标题(不是某篇文章，是整个博客) title = &amp;quot;Gavin&#39;s Blog&amp;quot; ## 这里就是设定你要的主题，而且主题必须要下载到theme/目录 theme = &amp;quot;maupassant&amp;quot; ## 保持分类的原始名字（false会做转小写处理） preserveTaxonomyNames = true ## 是否禁止URL Path转小写 disablePathToLower = true ## 这个会配置每一篇文章最后面的Copyright的作者名字 ## © 2019 Gavin&#39;s Blog By Gavin [author] name = &amp;quot;Gavin&amp;quot; [params] author = &amp;quot;Gavin&amp;quot; ## 这是一个副标题，在主标题的下方 subtitle = &amp;quot;Gopher，后端开发，网络基础，WEB协议、架构、存储、缓冲、安全，学习笔记&amp;quot; keywords = &amp;quot;Golang,Gavin,Blog&amp;quot; ## 这个是对阅读量的计数 busuanzi = true ## 这个是为了开评论区 [params.</description>
    </item>
    
    <item>
      <title>笔者</title>
      <link>https://wushaoqiang.github.io/about/</link>
      <pubDate>Sat, 16 Mar 2019 20:29:05 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/about/</guid>
      <description>笔者现在还是一个在校大三学生，正在为成为一名后端开发工程师而努力着，同时也是以太坊的初级爱好者。因为喜欢分享自己的学习成果而喜欢上了写博客，希望自己将来也能够写出一本书，并且开源出来。
 Github : https://github.com/wushaoqiang Email : 592350960@qq.com  </description>
    </item>
    
    <item>
      <title>Git用法总结</title>
      <link>https://wushaoqiang.github.io/posts/learn-git/</link>
      <pubDate>Fri, 15 Mar 2019 18:02:59 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/learn-git/</guid>
      <description>这篇博客是笔者总结学习git的过程，不是一篇专业性很强的文章，主要是笔记
主要参考廖雪峰的博客学习
笔者之前对Git有错误的理解(因为之前没学过，也只是听过)，总以为Github就是Git，其实Github是Git出来后才被创建的，为开源项目免费提供Git存储。
无Github,纯属本地的Git &amp;mdash; 那么什么是Git呢？ Git是目前世界上最先进的分布式版本控制系统
分布式：Git和其它集中式版本控制系统最大的区别，Git也可以有一个24小时开机的服务器来充当中央服务器，但这个服务器仅仅是为了让大家方便交换各自修改的。
版本控制：因为我们的代码要不断的完善，所以就有版本之分啦。
就算是我们自己在电脑上开发，也可以为自己代码创建版本库，用来记录修改和方便管理。
&amp;mdash; 创建版本库 在想要创建版本库的文件夹里面，输入命令
git init  就可以看到文件夹里面多了一个隐藏的文件夹.git
添加文件到我们新建的版本库里面用
//将某一个文件添加进缓冲区 git add &amp;lt;file&amp;gt; //将.git文件夹 所在的文件 里所有的文件添加进缓冲区 //所以不管你是在某一个子文件夹用这个命令，执行效果是一样的 git add -A //这个就是将缓冲区的提交到版本库里，并且携带提交信息 //(强烈推荐要写message，这样可以提醒那个时候修改了什么) git commit -m &amp;lt;message&amp;gt;  我们可以把代码所在区域分成
 工作区 缓冲区 当前分支  理解这几个工作区域会有助于理解命令的作用。
工作区：我们自己电脑编辑代码的地方
缓冲区：就是我们把修改过的文件放到一个区域装着，如果后面我又对这个文件做修改了，就可以继续往里面添加(同文件覆盖)
当前分支：就是我们使用commit后将缓冲区的文件提交上去的地方
&amp;mdash; 查看状态 git status  这个命令会告诉我们哪些被修改过的文件被添加到了缓冲去，哪些被修改的文件没有。
On branch master Your branch is behind &#39;origin/master&#39; by 1 commit, and can be fast-forwarded. (use &amp;quot;git pull&amp;quot; to update your local branch) Untracked files (use &amp;quot;git add &amp;lt;file&amp;gt;.</description>
    </item>
    
    <item>
      <title>Go琐碎笔记</title>
      <link>https://wushaoqiang.github.io/posts/learningGo/</link>
      <pubDate>Thu, 14 Mar 2019 16:10:59 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/learningGo/</guid>
      <description>在test文件要是以_test.go结尾，或者是在文件开头加上// +build (tag) 其中tag是自己定的，然后测试的时候在Terminal输入
2019.2.16 go test -tags tagname
构造数组可以先 make([]int,0)
然后 再使用函数：func append(slice []Type, elems ...Type) []Type
unicode.IsLetter(r rune) bool是判断是否为字母，而不是ASCII
res, ok := map[...] 中的ok变量可以用来判断key是否存在
[]rune可以直接转换为字符串string([]rune)
2019.2.17 谨记！ ： 切片和Map在函数传递都是指针传递(引用)
func normalize(cleartext string) string { var b strings.Builder for _, r := range cleartext { if unicode.IsLetter(r) || unicode.IsDigit(r) { b.WriteRune(unicode.ToLower(r)) } } return b.String() }  b.WriteRune(unicode.ToLower(r)) :可以用这种方式代替append()
norm = fmt.Sprintf(&amp;quot;%-[1]*s&amp;quot;, c*r, norm): 其实就是将出c*r代入到[1]*形成的在右侧填充空格
|类型 |默认值 | |int | 0 | |string|“” | | bool | false |  定义一个常量：const name type = value value是必须要有的 枚举：Go没有枚举，用const构造，有两种方法(参考这里的)</description>
    </item>
    
    <item>
      <title>归档</title>
      <link>https://wushaoqiang.github.io/archives/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://wushaoqiang.github.io/archives/</guid>
      <description></description>
    </item>
    
  </channel>
</rss>