<!doctype html>
<html lang="en-us">
<head>

    <meta charset="utf-8">
    <meta name="generator" content="Hugo 0.40.1" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <title>Go语言高级编程 | Gavin&#39;s Blog</title>
    <meta property="og:title" content="Go语言高级编程 - Gavin&#39;s Blog">
    <meta property="og:type" content="article">
        
    <meta property="article:published_time" content="2019-03-17T02:09:45&#43;08:00">
        
        
    <meta property="article:modified_time" content="2019-03-17T02:09:45&#43;08:00">
        
    <meta name="Keywords" content="Golang,Gavin,Blog">
    <meta name="description" content="Go语言高级编程">
        
    <meta name="author" content="Gavin">
    <meta property="og:url" content="https://wushaoqiang.github.io/posts/golang-highlevel/">
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">

    <link rel="stylesheet" href="/css/normalize.css">
    
        <link rel="stylesheet" href="/css/prism.css">
    
    <link rel="stylesheet" href="/css/style.css">
    <script type="text/javascript" src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script>

    


    
    
</head>

<body>
<header id="header" class="clearfix">
    <div class="container">
        <div class="col-group">
            <div class="site-name ">
                
                    <a id="logo" href="https://wushaoqiang.github.io">
                        Gavin&#39;s Blog
                    </a>
                
                <p class="description">Gopher，后端开发，网络基础，WEB协议、架构、存储、缓冲、安全，学习笔记</p>
            </div>
            <div>
                <nav id="nav-menu" class="clearfix">
                    <a class="" href="https://wushaoqiang.github.io">首页</a>
                    
                    <a  href="https://wushaoqiang.github.io/archives/" title="归档">归档</a>
                    
                    <a  href="https://wushaoqiang.github.io/about/" title="关于">关于</a>
                    
                </nav>
            </div>
        </div>
    </div>
</header>


<div id="body">
    <div class="container">
        <div class="col-group">

            <div class="col-8" id="main">
                <div class="res-cons">
                    <article class="post">
                        <header>
                            <h1 class="post-title">Go语言高级编程</h1>
                        </header>
                        <date class="post-meta meta-date">
                            2019年3月17日
                        </date>
                        
                        <div class="post-meta">
                            <span>|</span>
                            
                                <span class="meta-category"><a href="https://wushaoqiang.github.io/categories/Golang">Golang</a></span>
                            
                        </div>
                        
                        
                        <div class="post-meta">
                            <span id="busuanzi_container_page_pv">|<span id="busuanzi_value_page_pv"></span><span> 阅读</span></span>
                        </div>
                        
                        <div class="post-content">
                            

<h1 id="感谢">感谢</h1>

<p>在文章开头感谢两位作者:<a href="https://github.com/chai2010">柴树杉</a>和<a href="https://github.com/cch123">曹春晖</a></p>

<p>这篇文章是开源的，欢迎大家去<a href="https://chai2010.cn/advanced-go-programming-book/">阅读</a></p>

<p>本篇博客是笔者对这篇文章的理解，引用的图片也是来自原文，如有侵权请告知！</p>

<h1 id="第一章-基础">第一章 基础</h1>

<h2 id="1-3-数组-字符串和切片">1.3 数组、字符串和切片</h2>

<ul>
<li><p>Go语言的数组是一种值类型，虽然数组的元素可以被修改，但是数组本身的赋值和函数传参都是以整体复制的方式处理的</p></li>

<li><p>Go语言字符串底层数据也是对应的字节数组，但是字符串的只读属性禁止了在程序中对底层字节数组的元素的修改<strong>字符串赋值只是复制了数据地址和对应的长度，而不会导致底层数据的复制</strong></p></li>

<li><p>切片头含有底层数据的指针，所以它的赋值也不会导致底层数据的复制</p></li>
</ul>

<h3 id="字符串">字符串</h3>

<ul>
<li><p>字符串的元素不可修改，是一个只读的字节数组</p></li>

<li><p>字符串虽然不是切片，但是支持切片操作</p>

<pre><code>type StringHeader struct {
Data uintptr
Len  int
}
</code></pre>

<p>字符串结构由两个信息组成：第一个是字符串指向的底层字节数组，第二个是字符串的字节的长度。</p></li>
</ul>

<h3 id="切片">切片</h3>

<pre><code>type SliceHeader struct {
    Data uintptr
    Len  int
    Cap  int
}
</code></pre>

<pre><code class="language-go">a = append(a, 0)     // 切片扩展1个空间
copy(a[i+1:], a[i:]) // a[i:]向后移动1个位置
a[i] = x             // 设置新添加的元素
</code></pre>

<p><code>copy</code>将<code>a[i:]</code>直接搬到了<code>a[i+1:]</code>这个时候就可以在<code>a[i]</code>插入</p>

<p>这种做法可以减少中间创建的临时切片</p>

<p><strong>copy append可以完成切片的添加 删除 插入操作</strong></p>

<p>切片操作并不会复制底层的数据。底层的数组会被保存在内存中，直到它不再被引用。但是有时候可能会因为一个小的内存引用而导致底层整个数组处于被使用的状态，这会<strong>延迟自动内存回收器对底层数组的回收</strong>。所以我们在这种情况可以新建一个内存空间，存储数据，这样就可以让底层的数组被回收。</p>

<hr />

<h2 id="1-4-函数-方法和接口">1.4 函数、方法和接口</h2>

<p>当匿名函数引用了外部作用域的变量时就成了闭包函数</p>

<p><strong>Go语言执行顺序</strong>
<img src="https://chai2010.cn/advanced-go-programming-book/images/ch1-11-init.ditaa.png" alt="执行顺序" /></p>

<blockquote>
<p>要注意的是，在main.main函数执行之前所有代码都运行在同一个goroutine，也就是程序的主系统线程中。因此，如果某个init函数内部用go关键字启动了新的goroutine的话，新的goroutine只有在进入main.main函数之后才可能被执行到。</p>
</blockquote>

<p>也就是说，要等到其它的<code>init</code>都执行完了才会执行其它非主线程的goroutine的<code>init</code></p>

<h3 id="函数">函数</h3>

<ul>
<li><p>函数主要有具名和匿名之分</p></li>

<li><p>闭包对捕获的外部变量并不是传值方式访问，而是以引用的方式访问</p></li>
</ul>

<p>最重要的一点是要明白Go语言中指针不再是固定不变的了（因此不能随意将指针保持到数值变量中，Go语言的地址也不能随意保存到不在GC控制的环境中</p>

<p>不用关心Go语言中函数栈和堆的问题，编译器和运行时会帮我们搞定；同样不要假设变量在内存中的位置是固定不变的，指针随时可能会变化，特别是在你不期望它变化的时候。</p>

<h3 id="接口">接口</h3>

<p>Go语言中接口类型的独特之处在于它是满足隐式实现的鸭子类型</p>

<p>所谓鸭子类型说的是：只要走起路来像鸭子、叫起来也像鸭子，那么就可以把它当作鸭子。</p>

<h2 id="1-5-面向并发的内存模型">1.5 面向并发的内存模型</h2>

<p>Go语言的Goroutine之间是共享内存的。</p>

<h3 id="goroutine和系统线程">goroutine和系统线程</h3>

<p>问题</p>

<blockquote>
<p>固定了栈的大小导致了两个问题：一是对于很多只需要很小的栈空间的线程来说是一个巨大的浪费，二是对于少数需要巨大栈空间的线程来说又面临栈溢出的风险。</p>
</blockquote>

<p>Go的解决方案</p>

<blockquote>
<p>一个Goroutine会以一个很小的栈启动（可能是2KB或4KB），当遇到深度递归导致当前栈空间不足时，Goroutine会根据需要动态地伸缩栈的大小（主流实现中栈的最大值可达到1GB）。因为启动的代价很小，所以我们可以轻易地启动成千上万个Goroutine。</p>
</blockquote>

<h3 id="顺序一致性模型">顺序一致性模型</h3>

<blockquote>
<p>在Go语言中，同一个Goroutine线程内部，顺序一致性内存模型是得到保证的。但是不同的Goroutine之间，并不满足顺序一致性内存模型，需要通过明确定义的同步事件来作为同步的参考。如果两个事件不可排序，那么就说这两个事件是并发的。为了最大化并行，Go语言的编译器和处理器在不影响上述规定的前提下可能会对执行语句重新排序（CPU也会对一些指令进行乱序执行）。</p>
</blockquote>

<p>这也就是为什么之前我在main函数里看到的goroutine顺序并非执行出来的goroutine顺序</p>

<blockquote>
<p>因此，如果在一个Goroutine中顺序执行a = 1; b = 2;两个语句，虽然在当前的Goroutine中可以认为a = 1;语句先于b = 2;语句执行，但是在另一个Goroutine中b = 2;语句可能会先于a = 1;语句执行，甚至在另一个Goroutine中无法看到它们的变化（可能始终在寄存器中）。也就是说在另一个Goroutine看来, a = 1; b = 2;两个语句的执行顺序是不确定的</p>
</blockquote>

<p>我们可以通过<code>Lock() Unlock()</code>或者无缓冲通道解决这个问题</p>

<p>也就是说如果我们在创建goroutine的时候，需要保持某些特定的顺序，我们需要将它们同步起来。</p>

<h3 id="goroutine的创建">goroutine的创建</h3>

<pre><code class="language-go">var a string

func f() {
    print(a)
}

func hello() {
    a = &quot;hello, world&quot;
    go f()
}
</code></pre>

<p>go语句会在当前Goroutine对应函数返回前创建新的Goroutine。但是新创建Goroutine对应的f()的执行事件和hello函数返回的事件则是不可排序的，也就是并发的。</p>

<blockquote>
<p>调用hello可能会在将来的某一时刻打印&rdquo;hello, world&rdquo;，也很可能是在hello函数执行完成后才打印。</p>
</blockquote>

<h3 id="基于channel的通信">基于Channel的通信</h3>

<ul>
<li>在同一个Goroutine上执行2个操作很容易导致死锁</li>
</ul>

<h3 id="不靠谱的同步">不靠谱的同步</h3>

<p>根据线程内顺序一致性，结合Channel或sync同步事件的可排序性来推导，最终完成各个线程各段代码的偏序关系排序。如果两个事件无法根据此规则来排序，那么它们就是并发的，也就是执行先后顺序不可靠的。</p>

<p>解决同步问题的思路是相同的：使用显式的同步。</p>

<h2 id="1-6-常见的并发模式">1.6 常见的并发模式</h2>

<p>Go语言将其并发编程哲学化为一句口号：</p>

<blockquote>
<p>Do not communicate by sharing memory; instead, share memory by communicating.</p>

<p>不要通过共享内存来通信，而应通过通信来共享内存。</p>
</blockquote>

<h3 id="并发版本的hello-world">并发版本的Hello world</h3>

<pre><code class="language-go">func main() {
    var mu sync.Mutex

    go func(){
        fmt.Println(&quot;你好, 世界&quot;)
        mu.Lock()
    }()

    mu.Unlock()
}
</code></pre>

<p>根据文档，我们不能直接对一个未加锁状态的<code>sync.Mutex</code>进行解锁，这会导致运行时异常。上面程序中有两个goroutine，所以不知道哪个会先运行完，如果main函数先运行了mu.Unlock()，就会出错</p>

<p>修复后的代码：</p>

<pre><code class="language-go">func main() {
    var mu sync.Mutex

    mu.Lock()
    go func(){
        fmt.Println(&quot;你好, 世界&quot;)
        mu.Unlock()
    }()

    mu.Lock()
}
</code></pre>

<p>修改后，main函数的第二个<code>Lock()</code>会在另一个goroutine没有执行<code>Unlock()</code>之前发生阻塞。</p>

<p>当然还能用通道去控制</p>

<h3 id="生产者消费者模型">生产者消费者模型</h3>

<blockquote>
<p>并发编程中最常见的例子就是生产者消费者模式，该模式主要通过平衡生产线程和消费线程的工作能力来提高程序的整体处理数据的速度。简单地说，就是生产者生产一些数据，然后放到成果队列中，同时消费者从成果队列中来取这些数据。这样就让生产消费变成了异步的两个过程。当成果队列中没有数据时，消费者就进入饥饿的等待中；而当成果队列中数据已满时，生产者则面临因产品挤压导致CPU被剥夺的下岗问题。</p>
</blockquote>

<pre><code class="language-go">// 生产者: 生成 factor 整数倍的序列
func Producer(factor int, out chan&lt;- int) {
    for i := 0; ; i++ {
        out &lt;- i*factor
    }
}

// 消费者
func Consumer(in &lt;-chan int) {
    for v := range in {
        fmt.Println(v)
    }
}

func main() {
    ch := make(chan int, 64) // 成果队列

    go Producer(3, ch) // 生成 3 的倍数的序列
    go Producer(5, ch) // 生成 5 的倍数的序列
    go Consumer(ch)    // 消费 生成的队列

    // Ctrl+C 退出
    sig := make(chan os.Signal, 1)
    signal.Notify(sig, syscall.SIGINT, syscall.SIGTERM)
    fmt.Printf(&quot;quit (%v)\n&quot;, &lt;-sig)
}
</code></pre>

<p>两个生产者生产出数据给消费者使用</p>

<h3 id="发布订阅模型">发布订阅模型</h3>

<pre><code class="language-go">package pubsub

import (
	&quot;sync&quot;
	&quot;time&quot;
)

type (
	subscriber chan interface{}         // 订阅者为一个管道
	topicFunc  func(v interface{}) bool // 主题为一个过滤器
)

// 发布者对象
type Publisher struct {
	m           sync.RWMutex             // 读写锁
	buffer      int                      // 订阅队列的缓存大小
	timeout     time.Duration            // 发布超时时间
	subscribers map[subscriber]topicFunc // 订阅者信息
}

// 构建一个发布者对象, 可以设置发布超时时间和缓存队列的长度
func NewPublisher(publishTimeout time.Duration, buffer int) *Publisher {
	return &amp;Publisher{
		buffer:      buffer,
		timeout:     publishTimeout,
		subscribers: make(map[subscriber]topicFunc),
	}
}

// 添加一个新的订阅者，订阅全部主题
func (p *Publisher) Subscribe() chan interface{} {
	return p.SubscribeTopic(nil)
}

// 添加一个新的订阅者，订阅过滤器筛选后的主题
func (p *Publisher) SubscribeTopic(topic topicFunc) chan interface{} {
	ch := make(chan interface{}, p.buffer)
	p.m.Lock()
	p.subscribers[ch] = topic
	p.m.Unlock()
	return ch
}

// 退出订阅
func (p *Publisher) Evict(sub chan interface{}) {
	p.m.Lock()
	defer p.m.Unlock()

	delete(p.subscribers, sub)
	close(sub)
}

// 发布一个主题
func (p *Publisher) Publish(v interface{}) {
	p.m.RLock()
	defer p.m.RUnlock()

	var wg sync.WaitGroup
	for sub, topic := range p.subscribers {
		wg.Add(1)
		go p.sendTopic(sub, topic, v, &amp;wg)
	}
	wg.Wait()
}

// 关闭发布者对象，同时关闭所有的订阅者管道。
func (p *Publisher) Close() {
	p.m.Lock()
	defer p.m.Unlock()

	for sub := range p.subscribers {
		delete(p.subscribers, sub)
		close(sub)
	}
}

// 发送主题，可以容忍一定的超时
func (p *Publisher) sendTopic(
	sub subscriber, topic topicFunc, v interface{}, wg *sync.WaitGroup,
) {
	defer wg.Done()
	if topic != nil &amp;&amp; !topic(v) {
		return
	}

	select {
	case sub &lt;- v:
	case &lt;-time.After(p.timeout):
	}
}
</code></pre>

<p>首先：</p>

<ul>
<li><p>一个发布者对应着多个订阅者</p></li>

<li><p>每个订阅者是一个通道，用来接收信息的</p></li>

<li><p>发布者中用map记录着订阅者想要订阅的相关内容是什么</p></li>
</ul>

<p>所以主程序里面先生成一个发布者，通过发布者返回相应内容的订阅者(只能接收这个发布者的信息)，这个时候发布者开始发布信息，通过遍历订阅者(因为订阅者是个通道，所以可以遍历通道里缓冲的信息)得到相应发布者发出来的信息</p>

<h3 id="控制并发数">控制并发数</h3>

<p>没看懂</p>

<h3 id="素数筛">素数筛</h3>

<p>生产自然序列数</p>

<pre><code class="language-go">// 返回生成自然数序列的管道: 2, 3, 4, ...
func GenerateNatural() chan int {
    ch := make(chan int)
    go func() {
        for i := 2; ; i++ {
            ch &lt;- i
        }
    }()
    return ch
}
</code></pre>

<p>素数筛</p>

<pre><code class="language-go">// 管道过滤器: 删除能被素数整除的数
func PrimeFilter(in &lt;-chan int, prime int) chan int {
    out := make(chan int)
    go func() {
        for {
            if i := &lt;-in; i%prime != 0 {
                out &lt;- i
            }
        }
    }()
    return out
}
</code></pre>

<p>主函数</p>

<pre><code class="language-go">func main() {
    ch := GenerateNatural() // 自然数序列: 2, 3, 4, ...
    for i := 0; i &lt; 100; i++ {
        prime := &lt;-ch // 新出现的素数
        fmt.Printf(&quot;%v: %v\n&quot;, i+1, prime)
        ch = PrimeFilter(ch, prime) // 基于新素数构造的过滤器
    }
}
</code></pre>

<p>但这里的自然数序列通道只用到了一次。。，然后就被赋值为素数通道了</p>

<h3 id="并发的安全退出">并发的安全退出</h3>

<ul>
<li>当有多个管道均可操作时，select会随机选择一个管道。</li>
</ul>

<p>例如：</p>

<pre><code class="language-go">func main() {
    ch := make(chan int)
    go func() {
        for {
            select {
            case ch &lt;- 0:
            case ch &lt;- 1:
            }
        }
    }()

    for v := range ch {
        fmt.Println(v)
    }
}
</code></pre>

<ul>
<li>我们通过select和default分支可以很容易实现一个Goroutine的退出控制:</li>
</ul>

<pre><code class="language-go">func worker(cannel chan bool) {
    for {
        select {
        default:
            fmt.Println(&quot;hello&quot;)
            // 正常工作
        case &lt;-cannel:
            // 退出
        }
    }
}

func main() {
    cannel := make(chan bool)
    go worker(cannel)

    time.Sleep(time.Second)
    cannel &lt;- true
}
</code></pre>

<p>但是如果我有多个goroutine，会导致每个goroutine都要专门配置一个通道来退出goroutine，开销巨大。</p>

<p>我们可以通过关闭通道来达到一个通道控制多个goroutine的关闭，像这样</p>

<pre><code class="language-go">func worker(cannel chan bool) {
    for {
        select {
        default:
            fmt.Println(&quot;hello&quot;)
            // 正常工作
        case &lt;-cannel:
            // 退出
        }
    }
}

func main() {
    cancel := make(chan bool)

    for i := 0; i &lt; 10; i++ {
        go worker(cancel)
    }

    time.Sleep(time.Second)
    close(cancel)
}
</code></pre>

<p>但是这里的main函数并不会等待全部goroutine都清理完，所以清理工作不能保证被完成，所以我们还要main函数会等待goroutine清理完毕才能退出，于是：</p>

<pre><code class="language-go">func worker(wg *sync.WaitGroup, cannel chan bool) {
    defer wg.Done()

    for {
        select {
        default:
            fmt.Println(&quot;hello&quot;)
        case &lt;-cannel:
            return
        }
    }
}

func main() {
    cancel := make(chan bool)

    var wg sync.WaitGroup
    for i := 0; i &lt; 10; i++ {
        wg.Add(1)
        go worker(&amp;wg, cancel)
    }

    time.Sleep(time.Second)
    close(cancel)
    wg.Wait()
}
</code></pre>

<h3 id="context包">Context包</h3>

<p>在Go1.7发布时，标准库增加了一个context包，用来简化对于处理单个请求的多个Goroutine之间与请求域的数据、超时和退出等操作</p>

<pre><code class="language-go">func worker(ctx context.Context, wg *sync.WaitGroup) error {
    defer wg.Done()

    for {
        select {
        default:
            fmt.Println(&quot;hello&quot;)
        case &lt;-ctx.Done():
            return ctx.Err()
        }
    }
}

func main() {
    ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)

    var wg sync.WaitGroup
    for i := 0; i &lt; 10; i++ {
        wg.Add(1)
        go worker(ctx, &amp;wg)
    }

    time.Sleep(time.Second)
    cancel()

    wg.Wait()
}
</code></pre>

<p>当执行cancel()或者超过设置时间的时候，会从通道ctx.Done接收到值。</p>

<h2 id="1-7-错误和异常">1.7 错误和异常</h2>

<p>在Go语言中，错误被认为是一种可以预期的结果；而异常则是一种非预期的结果</p>

<p>Go语言推荐使用recover函数将内部异常转为错误处理，这使得用户可以真正的关心业务相关的错误处理。</p>

<p>捕获异常不是最终的目的。如果异常不可预测，直接输出异常信息是最好的处理方式。</p>

<h3 id="错误处理策略">错误处理策略</h3>

<p>为了提高系统的稳定性，Web框架一般会通过recover来防御性地捕获所有处理流程中可能产生的异常，然后将异常转为普通的错误返回。</p>

<p>下面这个就是加上JSON解析器出异常的时候，可以用recover捕获，然后以一个普通错误返回给用户</p>

<pre><code class="language-go">func ParseJSON(input string) (s *Syntax, err error) {
    defer func() {
        if p := recover(); p != nil {
            err = fmt.Errorf(&quot;JSON: internal error: %v&quot;, p)
        }
    }()
    // ...parser...
}
</code></pre>

<p>Go语言库的实现习惯: 即使在包内部使用了panic，但是在导出函数时会被转化为明确的错误值。</p>

<h3 id="获取错误的上下文">获取错误的上下文</h3>

<p>有时候为了方便上层用户理解；底层实现者会将底层的错误重新包装为新的错误类型返回给用户</p>

<p>但是包装了错误也会丢失原始的错误，所以</p>

<blockquote>
<p>为了记录这种错误类型在包装的变迁过程中的信息，我们一般会定义一个辅助的WrapError函数，用于包装原始的错误，同时保留完整的原始错误类型。为了问题定位的方便，同时也为了能记录错误发生时的函数调用状态，我们很多时候希望在出现致命错误的时候保存完整的函数调用信息。同时，为了支持RPC等跨网络的传输，我们可能要需要将错误序列化为类似JSON格式的数据，然后再从这些数据中将错误解码恢出来。</p>
</blockquote>

<p>可以定义自己的错误包：</p>

<pre><code class="language-go">type Error interface {
    Caller() []CallerInfo
    Wraped() []error
    Code() int
    error

    private()
}

type CallerInfo struct {
    FuncName string
    FileName string
    FileLine int
}
</code></pre>

<p>其实就是定义一个自己的结构体，既可以2层包装，又可以将底层错误存起来。
上面代码不完整，只是提供一个思路</p>

<p>Go语言中大部分函数的代码结构几乎相同，首先是一系列的初始检查，用于防止错误发生，之后是函数的实际逻辑。像</p>

<pre><code class="language-go">f, err := os.Open(&quot;filename.ext&quot;)
if err != nil {
    // 失败的情形, 马上返回错误
}
</code></pre>

<h3 id="剖析异常">剖析异常</h3>

<p>错误例子</p>

<pre><code class="language-go">func main() {
    if r := recover(); r != nil {
        log.Fatal(r)
    }

    panic(123)

    if r := recover(); r != nil {
        log.Fatal(r)
    }
}
</code></pre>

<blockquote>
<p>上面程序中两个recover调用都不能捕获任何异常。在第一个recover调用执行时，函数必然是在正常的非异常执行流程中，这时候recover调用将返回nil。发生异常时，第二个recover调用将没有机会被执行到，因为panic调用会导致函数马上执行已经注册defer的函数后返回。</p>
</blockquote>

<p>其实recover函数调用有着更严格的要求：我们必须在defer函数中直接调用recover。如果defer中调用的是recover函数的包装函数的话，异常的捕获工作将失败！</p>

<p>又一个错误示例：</p>

<pre><code class="language-go">func main() {
    defer func() {
        // 无法捕获异常
        if r := MyRecover(); r != nil {
            fmt.Println(r)
        }
    }()
    panic(1)
}

func MyRecover() interface{} {
    log.Println(&quot;trace...&quot;)
    return recover()
}
</code></pre>

<p>如果defer语句直接调用recover函数，依然不能正常捕获异常：</p>

<pre><code class="language-go">func main() {
    // 无法捕获异常
    defer recover()
    panic(1)
}
</code></pre>

<p>必须要和有异常的栈帧只隔一个栈帧，recover函数才能正常捕获异常。换言之，recover函数捕获的是祖父一级调用函数栈帧的异常（刚好可以跨越一层defer函数）！</p>

<p>所以一般是这样的：</p>

<pre><code class="language-go">func foo() (err error) {
    defer func() {
        if r := recover(); r != nil {
            switch x := r.(type) {
            case string:
                err = errors.New(x)
            case error:
                err = x
            default:
                err = fmt.Errorf(&quot;Unknown panic: %v&quot;, r)
            }
        }
    }()

    panic(&quot;TODO&quot;)
}
</code></pre>

<h1 id="第二章-cgo编程-先跳过">第二章 CGO编程(先跳过)</h1>

<blockquote>
<p>Go语言通过自带的一个叫CGO的工具来支持C语言函数调用，同时我们可以用Go语言导出C动态库接口给其它语言使用</p>
</blockquote>

<h2 id="2-1-快速入门">2.1 快速入门</h2>

<h3 id="最简cgo程序">最简CGO程序</h3>

<p>真实的CGO程序一般都比较复杂</p>

<pre><code class="language-go">package main

import &quot;C&quot;

func main() {
    println(&quot;hello cgo&quot;)
}
</code></pre>

<blockquote>
<p>代码通过import &ldquo;C&rdquo;语句启用CGO特性，主函数只是通过Go内置的println函数输出字符串，其中并没有任何和CGO相关的代码。虽然没有调用CGO的相关函数，但是go build命令会在编译和链接阶段启动gcc编译器，这已经是一个完整的CGO程序了。</p>
</blockquote>

<h1 id="第三章-汇编语言-先跳过">第三章 汇编语言(先跳过)</h1>

<h1 id="第四章-rpc和protobuf">第四章 RPC和Protobuf</h1>

<blockquote>
<p>RPC是远程过程调用的缩写（Remote Procedure Call），通俗地说就是调用远处的一个函数。</p>

<p>Protobuf因为支持多种不同的语言（甚至不支持的语言也可以扩展支持），其本身特性也非常方便描述服务的接口（也就是方法列表），因此非常适合作为RPC世界的接口交流语言</p>
</blockquote>

<h2 id="4-1-rpc入门">4.1 RPC入门</h2>

<p>RPC是远程过程调用的简称，是分布式系统中不同节点间流行的通信方式。</p>

<p>‘好激动，马上就要学分布式了&rsquo;</p>

<p>Go语言的标准库也提供了一个简单的RPC实现</p>

<h3 id="rpc版-hello-world">RPC版&rdquo;Hello World&rdquo;</h3>

<p>Go语言的RPC规则：方法只能有两个可序列化的参数，其中第二个参数是指针类型，并且返回一个error类型，同时必须是公开的方法。</p>

<p>所以构造一个Hello World程序是这样的：</p>

<pre><code class="language-go">type HelloService struct{}

func (p *HelloService) Hello(request string, reply *string) error {
	*reply = &quot;hello&quot; + request
	return nil
}
</code></pre>

<p>然后我们要在服务器端注册RPC函数，监听他人(想要调用这个RPC接口的)。</p>

<pre><code class="language-go">func main() {
    rpc.RegisterName(&quot;HelloService&quot;, new(HelloService))

    listener, err := net.Listen(&quot;tcp&quot;, &quot;:1234&quot;)
    if err != nil {
        log.Fatal(&quot;ListenTCP error:&quot;, err)
    }

    conn, err := listener.Accept()
    if err != nil {
        log.Fatal(&quot;Accept error:&quot;, err)
    }

    rpc.ServeConn(conn)
}
</code></pre>

<p>客户端要发起请求(Dial)：</p>

<pre><code class="language-go">func main() {
	client, err := rpc.Dial(&quot;tcp&quot;, &quot;localhost:1234&quot;)
	if err != nil {
		log.Fatal(&quot;dialing:&quot;, err)
	}

	var reply string
	err = client.Call(&quot;HelloService.Hello&quot;, &quot;hello&quot;, &amp;reply)
	if err != nil {
		log.Fatal(err)
	}

	fmt.Println(reply)
}
</code></pre>

<p>所以client传过去的参数一定要符合server那边函数的定义，不然会发生错误，也就是说要提前了解RPC函数的声明。但是我们也可以包装好，方便用户调用，后面会写到</p>

<p>我们也可以看见，RPC是通过TCP来连接的。</p>

<h3 id="更安全的rpc接口">更安全的RPC接口</h3>

<blockquote>
<p>在涉及RPC的应用中，作为开发人员一般至少有三种角色：首选是服务端实现RPC方法的开发人员，其次是客户端调用RPC方法的人员，最后也是最重要的是制定服务端和客户端RPC接口规范的设计人员。在前面的例子中我们为了简化将以上几种角色的工作全部放到了一起，虽然看似实现简单，但是不利于后期的维护和工作的切割。</p>
</blockquote>

<p>对上面代码进行了修改后分别是
接口代码：</p>

<pre><code class="language-go">package common

import &quot;net/rpc&quot;

const HelloServiceName = &quot;path/to/pkg.HelloService&quot;

type HelloServiceInterface = interface {
	Hello(request string, reply *string) error
}

func RegisterHelloService(svc HelloServiceInterface) error {
	return rpc.RegisterName(HelloServiceName, svc)
}

type HelloServiceClient struct {
	*rpc.Client
}

// var _ HelloServiceInterface = (*HelloServiceClient)(nil)

func DialHelloService(network, address string) (*HelloServiceClient, error) {
	c, err := rpc.Dial(network, address)
	if err != nil {
		return nil, err
	}
	return &amp;HelloServiceClient{Client: c}, nil
}

func (p *HelloServiceClient) Hello(request string, reply *string) error {
	return p.Client.Call(HelloServiceName+&quot;.Hello&quot;, request, reply)
}
</code></pre>

<p>从上往下</p>

<ul>
<li><p><code>HelloServiceName</code>是为了区分名字而写的，并不是真正用来做路径。</p></li>

<li><p>Client接口是为了Client使用起来难度会降低，不容易出现不匹配类型的错误</p></li>

<li><p>Hello函数也是为了包装</p></li>
</ul>

<p>Client代码</p>

<pre><code class="language-go">func main() {
	client, err := common.DialHelloService(&quot;tcp&quot;, &quot;localhost:1234&quot;)
	if err != nil {
		log.Fatal(&quot;dialing:&quot;, err)
	}

	var reply string
	err = client.Hello(&quot;hello&quot;, &amp;reply)
	if err != nil {
		log.Fatal(err)
	}
	fmt.Println(reply)
}
</code></pre>

<ul>
<li>这里就不直接用DIal连接服务器了，因为我们以及包装好了，这里返回一个接口代码里面的Client接口类型，用来调用这个接口的方法</li>
<li>客户端整体操作会免去了输入字符串不匹配的麻烦事</li>
</ul>

<p>服务器端代码</p>

<pre><code class="language-go">type HelloService struct{}

func (p *HelloService) Hello(request string, reply *string) error {
	*reply = &quot;hello:&quot; + request
	return nil
}

func main() {
	common.RegisterHelloService(new(HelloService))

	listener, err := net.Listen(&quot;tcp&quot;, &quot;:1234&quot;)
	if err != nil {
		log.Fatal(&quot;ListenTCP error:&quot;, err)
	}

	for {
		conn, err := listener.Accept()
		if err != nil {
			log.Fatal(&quot;Accept error:&quot;, err)
		}

		go rpc.ServeConn(conn)
	}
}
</code></pre>

<ul>
<li>结构体实现了接口，因此可以用这个结构体去注册接口RPC</li>
<li>其它操作都差不多，监听，接收，启动goroutine对RPC进行反应</li>
</ul>

<h3 id="跨语言的rpc">跨语言的RPC</h3>

<p>Go语言的RPC框架有两个比较有特色的设计：一个是RPC数据打包时可以通过插件实现自定义的编码和解码；另一个是RPC建立在抽象的io.ReadWriteCloser接口之上的，我们可以将RPC架设在不同的通讯协议之上</p>

<p>服务器代码</p>

<pre><code class="language-go">func main() {
    rpc.RegisterName(&quot;HelloService&quot;, new(HelloService))

    listener, err := net.Listen(&quot;tcp&quot;, &quot;:1234&quot;)
    if err != nil {
        log.Fatal(&quot;ListenTCP error:&quot;, err)
    }

    for {
        conn, err := listener.Accept()
        if err != nil {
            log.Fatal(&quot;Accept error:&quot;, err)
        }

        go rpc.ServeCodec(jsonrpc.NewServerCodec(conn))
    }
}
</code></pre>

<p>客户端代码：</p>

<pre><code class="language-go">func main() {
    conn, err := net.Dial(&quot;tcp&quot;, &quot;localhost:1234&quot;)
    if err != nil {
        log.Fatal(&quot;net.Dial:&quot;, err)
    }

    client := rpc.NewClientWithCodec(jsonrpc.NewClientCodec(conn))

    var reply string
    err = client.Call(&quot;HelloService.Hello&quot;, &quot;hello&quot;, &amp;reply)
    if err != nil {
        log.Fatal(err)
    }

    fmt.Println(reply)
}
</code></pre>

<p>两个代码中与之前最大的不同就是使用json编解码器</p>

<hr />

<p>请求格式</p>

<pre><code class="language-json">type clientRequest struct {
    Method string         `json:&quot;method&quot;`
    Params [1]interface{} `json:&quot;params&quot;`
    Id     uint64         `json:&quot;id&quot;`
}

type serverRequest struct {
    Method string           `json:&quot;method&quot;`
    Params *json.RawMessage `json:&quot;params&quot;`
    Id     *json.RawMessage `json:&quot;id&quot;`
}
</code></pre>

<p>响应格式</p>

<pre><code class="language-json">type clientResponse struct {
    Id     uint64           `json:&quot;id&quot;`
    Result *json.RawMessage `json:&quot;result&quot;`
    Error  interface{}      `json:&quot;error&quot;`
}

type serverResponse struct {
    Id     *json.RawMessage `json:&quot;id&quot;`
    Result interface{}      `json:&quot;result&quot;`
    Error  interface{}      `json:&quot;error&quot;`
}
</code></pre>

<p>总的来说呢，服务器端和客户端都用了JSON编解码器来实现传输过程中使用JSON格式发送和接收。</p>

<p>做了两个试验</p>

<ol>
<li><p>开启了客户端，用<code>nc -l 1234</code>启动一个TCP服务，然后执行客户端的代码发现<code>nc</code>所启动的服务器端接收了客户端代码所发送的东西<code>{&quot;method&quot;:&quot;HelloService.Hello&quot;,&quot;params&quot;:[&quot;hello&quot;],&quot;id&quot;:0}</code>对应上面的客户端请求格式</p></li>

<li><p>开启了服务器端，然后执行<code>echo -e '{&quot;method&quot;:&quot;HelloService.Hello&quot;,&quot;params&quot;:[&quot;hello&quot;],&quot;id&quot;:1}' | nc localhost 1234</code>也就是模拟一个客户端去发送一个符合格式的JSON到服务器端，服务器端正确解析后返回<code>{&quot;id&quot;:1,&quot;result&quot;:&quot;hello:hello&quot;,&quot;error&quot;:null}</code>也是符合服务器响应的格式的，而且所对应的Result也是正确的</p></li>
</ol>

<h3 id="http上的rpc">Http上的RPC</h3>

<p>因为Go语言的鸭子接口，我们可以用处理函数中基于http.ResponseWriter和http.Request类型的参数构造一个io.ReadWriteCloser类型的conn通道，然后就跟之前在Accept返回的类型一样了(是一个io.ReadWriteCloser类型)</p>

<pre><code class="language-go">func main() {
    rpc.RegisterName(&quot;HelloService&quot;, new(HelloService))

    http.HandleFunc(&quot;/jsonrpc&quot;, func(w http.ResponseWriter, r *http.Request) {
        var conn io.ReadWriteCloser = struct {
            io.Writer
            io.ReadCloser
        }{
            ReadCloser: r.Body,
            Writer:     w,
        }

        rpc.ServeRequest(jsonrpc.NewServerCodec(conn))
    })

    http.ListenAndServe(&quot;:1234&quot;, nil)
}
</code></pre>

<p>主要在于构造出这个<code>io.ReadWriteCloser</code>类型对象</p>

<h2 id="4-2-protobuf">4.2 Protobuf</h2>

<p>Protobuf作为接口规范的描述语言，可以作为设计安全的跨语言PRC接口的基础工具</p>

<h1 id="第五章-go和web">第五章 Go和Web</h1>

<h2 id="web开发简介">Web开发简介</h2>

<p>Go的Web框架大致可以分为这么两类：</p>

<ul>
<li><p>Router框架</p></li>

<li><p>MVC类框架</p></li>
</ul>

<p>开源界有这么几种框架</p>

<ul>
<li><p>第一种是对httpRouter进行简单的封装，然后提供定制的中间件和一些简单的小工具集成比如gin，主打轻量，易学，高性能。</p></li>

<li><p>第二种是借鉴其它语言的编程风格的一些MVC类框架，例如beego</p></li>

<li><p>还有一些框架功能更为强大，除了数据库schema设计，大部分代码直接生成，例如goa。</p></li>
</ul>

<p><strong>RESTful</strong> 是一种软件架构风格、设计风格，而不是标准，只是提供了一组设计原则和约束条件。它主要用于客户端和服务器交互类的软件。基于这个风格设计的软件可以更简洁，更有层次，更易于实现缓存等机制。</p>

<h2 id="router-请求路由">router 请求路由</h2>

<h3 id="httprouter">httprouter</h3>

<p>较流行的开源go Web框架大多使用httprouter，或是基于httprouter的变种对路由进行支持</p>

<blockquote>
<p>因为httprouter中使用的是显式匹配，所以在设计路由的时候需要规避一些会导致路由冲突的情况</p>
</blockquote>

<p>例如</p>

<pre><code>conflict:(冲突)
GET /user/info/:name
GET /user/:id

no conflict:(不冲突)
GET /user/info/:name
POST /user/:id
</code></pre>

<p>因为冲突那部分，方法相同，而且<code>:id</code>不确定，它可能会和上面普通字符串的路由冲突，所以在初始化阶段就会panic</p>

<p>wildcard参数是指<code>:id</code>这种形式</p>

<p>路由中的参数数目不能超过255</p>

<p>除支持路径中的wildcard参数之外，httprouter还可以支持*号来进行通配，不过*号开头的参数只能放在路由的结尾</p>

<blockquote>
<p>除了正常情况下的路由支持，httprouter也支持对一些特殊情况下的回调函数进行定制，例如404的时候：</p>
</blockquote>

<pre><code class="language-go">r := httprouter.New()
r.NotFound = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
    w.Write([]byte(&quot;oh no, not found&quot;))
})
</code></pre>

<blockquote>
<p>或者内部panic的时候：</p>
</blockquote>

<pre><code class="language-go">r.PanicHandler = func(w http.ResponseWriter, r *http.Request, c interface{}) {
    log.Printf(&quot;Recovering from panic, Reason: %#v&quot;, c.(error))
    w.WriteHeader(http.StatusInternalServerError)
    w.Write([]byte(c.(error).Error()))
}
</code></pre>

<h3 id="原理">原理</h3>

<p>字典树：</p>

<p><img src="https://chai2010.cn/advanced-go-programming-book/images/ch6-02-trie.png" alt="字典树" /></p>

<p>利用深度优先搜索</p>

<blockquote>
<p>普通的字典树有一个比较明显的缺点，就是每个字母都需要建立一个孩子节点，这样会导致字典树的层数比较深</p>
</blockquote>

<p><strong>压缩字典树</strong></p>

<p><a href="https://chai2010.cn/advanced-go-programming-book/images/ch6-02-radix.png">压缩字典树</a></p>

<p>压缩字典树的好处当然是更加省空间，以及效率更高。但有一点要注意，同一层不可能有同名出现，比如要加<code>/local</code>到这个压缩字典树，那么它就跟<code>/user</code>同级。</p>

<h3 id="压缩字典树创建过程">压缩字典树创建过程</h3>

<p>使用的是这样的数据结构</p>

<pre><code class="language-go">type Router struct {
    // ...
    trees map[string]*node
    // ...
}
</code></pre>

<p>当中的key是请求方法，如GET POST等
所以每一种方法对应的都是一棵独立的压缩字典树，不会相互共享数据</p>

<p>内部的节点类型是<code>*httprouter.node</code></p>

<pre><code>path: 当前节点对应的路径中的字符串

wildChild: 子节点是否为参数节点，即 wildcard node，或者说 :id 这种类型的节点

nType: 当前节点类型，有四个枚举值: 分别为 static/root/param/catchAll。
    static                   // 非根节点的普通字符串节点
    root                     // 根节点
    param                    // 参数节点，例如 :id
    catchAll                 // 通配符节点，例如 *anyway

indices：子节点索引，当子节点为非参数类型，即本节点的wildChild为false时，会将每个子节点的首字母放在该索引数组。说是数组，实际上是个string。
</code></pre>

<p>在路由本身只有字符串的情况下，不会发生任何冲突。只有当路由中含有wildcard（类似 :id）或者catchAll的情况下才可能冲突</p>

<h2 id="5-3-中间件">5.3 中间件</h2>

<p>对现在流行的Web框架中的中间件(middleware)技术原理进行分析，并介绍如何使用中间件技术将业务和非业务代码功能进行<strong>解耦</strong>。</p>

<p>给一个典型的Web服务：</p>

<pre><code class="language-go">package main

func hello(wr http.ResponseWriter, r *http.Request) {
    wr.Write([]byte(&quot;hello&quot;))
}

func main() {
    http.HandleFunc(&quot;/&quot;, hello)
    err := http.ListenAndServe(&quot;:8080&quot;, nil)
    ...
}
</code></pre>

<p>其中<code>hello</code>是一个handlerFunc，而这个函数类型实现了handler的接口。
然后HandleFunc是创建路由的</p>

<p>对于HandleFunc的定义：</p>

<pre><code class="language-go">func HandleFunc(pattern string, handler func(ResponseWriter, *Request)) {
    DefaultServeMux.HandleFunc(pattern, handler)
}

// 调用

func (mux *ServeMux) HandleFunc(pattern string, handler func(ResponseWriter, *Request)) {
    mux.Handle(pattern, HandlerFunc(handler))
}
</code></pre>

<h3 id="使用中间件剥离非业务逻辑">使用中间件剥离非业务逻辑</h3>

<p>可以传入一个handler返回一个handler</p>

<pre><code class="language-go">func hello(wr http.ResponseWriter, r *http.Request) {
    wr.Write([]byte(&quot;hello&quot;))
}

func timeMiddleware(next http.Handler) http.Handler {
    return http.HandlerFunc(func(wr http.ResponseWriter, r *http.Request) {
        timeStart := time.Now()

        // next handler
        next.ServeHTTP(wr, r)

        timeElapsed := time.Since(timeStart)
        logger.Println(timeElapsed)
    })
}

func main() {
    http.Handle(&quot;/&quot;, timeMiddleware(http.HandlerFunc(hello)))
    err := http.ListenAndServe(&quot;:8080&quot;, nil)
    ...
}
</code></pre>

<p>这样就可以编写非业务代码的同时 不用修改业务代码里面的东西</p>

<h3 id="更优雅的中间件写法">更优雅的中间件写法</h3>

<pre><code class="language-go">type middleware func(http.Handler) http.Handler

type Router struct {
    middlewareChain [] middleware
    mux map[string] http.Handler
}

func NewRouter() *Router{
    return &amp;Router{}
}

func (r *Router) Use(m middleware) {
    r.middlewareChain = append(r.middlewareChain, m)
}

func (r *Router) Add(route string, h http.Handler) {
    var mergedHandler = h

    for i := len(r.middlewareChain) - 1; i &gt;= 0; i-- {
        mergedHandler = r.middlewareChain[i](mergedHandler)
    }

    r.mux[route] = mergedHandler
}
</code></pre>

<p>这里的话需要在外部再遍历<code>r.mux</code>来注册路由</p>

<p>注意代码中的middleware数组遍历顺序，和用户希望的调用顺序应该是&rdquo;相反&rdquo;的</p>

<blockquote>
<p>异步的另外一种含义是计算机多线程的异步处理。与同步处理相对，异步处理不用阻塞当前线程来等待处理完成，而是允许后续操作，直至其它线程将处理完成，并回调通知此线程。</p>

<p>但此处需要明确的是:异步与多线程与并行不是同一个概念.</p>
</blockquote>

<h2 id="5-4-请求校验">5.4 请求校验</h2>

<p>需要进行字段校验的情况有很多，Web系统的Form或JSON提交只是一个典型的例子。</p>

<h3 id="重构校验函数">重构校验函数</h3>

<pre><code class="language-go">type RegisterReq struct {
    Username       string   `json:&quot;username&quot;`
    PasswordNew    string   `json:&quot;password_new&quot;`
    PasswordRepeat string   `json:&quot;password_repeat&quot;`
    Email          string   `json:&quot;email&quot;`
}

func register(req RegisterReq) error{
    if len(req.Username) &gt; 0 {
        if len(req.PasswordNew) &gt; 0 &amp;&amp; len(req.PasswordRepeat) &gt; 0 {
            if req.PasswordNew == req.PasswordRepeat {
                if emailFormatValid(req.Email) {
                    createUser()
                    return nil
                } else {
                    return errors.New(&quot;invalid email&quot;)
                }
            } else {
                return errors.New(&quot;password and reinput must be the same&quot;)
            }
        } else {
            return errors.New(&quot;password and password reinput must be longer than 0&quot;)
        }
    } else {
        return errors.New(&quot;length of username cannot be 0&quot;)
    }
}
</code></pre>

<p>优化后的代码：</p>

<pre><code class="language-go">func register(req RegisterReq) error{
    if len(req.Username) == 0 {
        return errors.New(&quot;length of username cannot be 0&quot;)
    }

    if len(req.PasswordNew) == 0 || len(req.PasswordRepeat) == 0 {
        return errors.New(&quot;password and password reinput must be longer than 0&quot;)
    }

    if req.PasswordNew != req.PasswordRepeat {
        return errors.New(&quot;password and reinput must be the same&quot;)
    }

    if emailFormatValid(req.Email) {
        return errors.New(&quot;invalid email&quot;)
    }

    createUser()
    return nil
}
</code></pre>

<p>虽然看起来是舒服了，但是还是要为每一个http请求都去写这么一套差不多的validate()函数</p>

<h3 id="用validator解放劳动力">用validator解放劳动力</h3>

<p>一个新的validator库：</p>

<p><a href="https://github.com/go-playground/validator">新的vaildator库</a></p>

<h3 id="原理-1">原理</h3>

<p>从结构上来看，每一个结构体都可以看成是一棵树</p>

<p>假设结构体</p>

<pre><code class="language-go">type Nested struct {
    Email string `validate:&quot;email&quot;`
}
type T struct {
    Age    int `validate:&quot;eq=10&quot;`
    Nested Nested
}
</code></pre>

<p>所对应的就是
<a href="https://chai2010.cn/advanced-go-programming-book/images/ch6-04-validate-struct-tree.png">图片</a></p>

<pre><code class="language-go">package main

import (
    &quot;fmt&quot;
    &quot;reflect&quot;
    &quot;regexp&quot;
    &quot;strconv&quot;
    &quot;strings&quot;
)

type Nested struct {
    Email string `validate:&quot;email&quot;`
}
type T struct {
    Age    int `validate:&quot;eq=10&quot;`
    Nested Nested
}

func validateEmail(input string) bool {
    if pass, _ := regexp.MatchString(
        `^([\w\.\_]{2,10})@(\w{1,}).([a-z]{2,4})$`, input,
    ); pass {
        return true
    }
    return false
}

func validate(v interface{}) (bool, string) {
    validateResult := true
    errmsg := &quot;success&quot;
    vt := reflect.TypeOf(v)
    vv := reflect.ValueOf(v)
    for i := 0; i &lt; vv.NumField(); i++ {
        fieldVal := vv.Field(i)
        tagContent := vt.Field(i).Tag.Get(&quot;validate&quot;)
        k := fieldVal.Kind()

        switch k {
        case reflect.Int:
            val := fieldVal.Int()
            tagValStr := strings.Split(tagContent, &quot;=&quot;)
            tagVal, _ := strconv.ParseInt(tagValStr[1], 10, 64)
            if val != tagVal {
                errmsg = &quot;validate int failed, tag is: &quot;+ strconv.FormatInt(
                    tagVal, 10,
                )
                validateResult = false
            }
        case reflect.String:
            val := fieldVal.String()
            tagValStr := tagContent
            switch tagValStr {
            case &quot;email&quot;:
                nestedResult := validateEmail(val)
                if nestedResult == false {
                    errmsg = &quot;validate mail failed, field val is: &quot;+ val
                    validateResult = false
                }
            }
        case reflect.Struct:
            // 如果有内嵌的 struct，那么深度优先遍历
            // 就是一个递归过程
            valInter := fieldVal.Interface()
            nestedResult, msg := validate(valInter)
            if nestedResult == false {
                validateResult = false
                errmsg = msg
            }
        }
    }
    return validateResult, errmsg
}

func main() {
    var a = T{Age: 10, Nested: Nested{Email: &quot;abc@abc.com&quot;}}

    validateResult, errmsg := validate(a)
    fmt.Println(validateResult, errmsg)
}
</code></pre>

<p>这个程序就用了深度优先搜索，进行对结构体的校验。</p>

<h2 id="5-5-database和数据库打交道">5.5 Database和数据库打交道</h2>

<h3 id="从database-sql讲起">从database/sql讲起</h3>

<p>==这个在之前的博客有讲过==</p>

<blockquote>
<p>官方的db库提供的功能这么简单，我们每次去数据库里读取内容岂不是都要去写这么一套差不多的代码？或者如果我们的对象是结构体，把sql.Rows绑定到对象的工作就会变得更加得重复而无聊。</p>
</blockquote>

<h3 id="提高生产效率的orm和sql-builder">提高生产效率的ORM和SQL Builder</h3>

<blockquote>
<p>为常见的ORM实际上做的是从db到程序的类或结构体这样的映射。</p>
</blockquote>

<p>我们可以先来看看其它的程序语言里的ORM写起来是怎么样的感觉：</p>

<pre><code>&gt;&gt;&gt; from blog.models import Blog
&gt;&gt;&gt; b = Blog(name='Beatles Blog', tagline='All the latest Beatles news.')
&gt;&gt;&gt; b.save()
</code></pre>

<p>完全没有数据库的痕迹，没错ORM的目的就是屏蔽掉DB层，实际上很多语言的ORM只要把你的类或结构体定义好，再用特定的语法将结构体之间的一对一或者一对多关系表达出来。那么任务就完成了。</p>

<blockquote>
<p>相比ORM来说，SQL Builder在SQL和项目可维护性之间取得了比较好的平衡。</p>

<p>另外在一些本来也不需要DBA介入的场景内，使用SQL Builder也是可以的，例如你要做一套运维系统，且将MySQL当作了系统中的一个组件，系统的QPS不高，查询不复杂等等。</p>
</blockquote>

<h3 id="脆弱的数据库">脆弱的数据库</h3>

<p>无论是ORM还是SQL Builder都有一个致命的缺点，就是没有办法进行系统上线的事前sql审核。</p>

<h2 id="5-6-ratelimit-服务流量限制">5.6 Ratelimit 服务流量限制</h2>

<blockquote>
<p>计算机程序可依据其瓶颈分为磁盘IO瓶颈型，CPU计算瓶颈型，网络带宽瓶颈型，分布式场景下有时候也会外部系统而导致自身瓶颈。</p>

<p>不管我们的服务瓶颈在哪里，最终要做的事情都是一样的，那就是流量限制。</p>
</blockquote>

<h3 id="常见的流量限制手段">常见的流量限制手段</h3>

<p>流量限制的手段有很多，最常见的：漏桶、令牌桶两种：</p>

<ul>
<li>漏桶是指我们有一个一直装满了水的桶，每过固定的一段时间即向外漏一滴水。如果你接到了这滴水，那么你就可以继续服务请求，如果没有接到，那么就需要等待下一滴水。</li>
<li>令牌桶则是指匀速向桶中添加令牌，服务请求时需要从桶中获取令牌，令牌的数目可以按照需要消耗的资源进行相应的调整。如果没有令牌，可以选择等待，或者放弃。</li>
</ul>

<blockquote>
<p>两种方法看起来很像，不过还是有区别的。漏桶流出的速率固定，而令牌桶只要在桶中有令牌，那就可以拿。也就是说令牌桶是允许一定程度的并发的，比如同一个时刻，有100个用户请求，只要令牌桶中有100个令牌，那么这100个请求全都会放过去。令牌桶在桶中没有令牌的情况下也会退化为漏桶模型。</p>
</blockquote>

<p>比如<code>github.com/juju/ratelimit</code>提供了几种不同特色的令牌桶填充方式：</p>

<pre><code class="language-go">func NewBucket(fillInterval time.Duration, capacity int64) *Bucket
func NewBucketWithQuantum(fillInterval time.Duration, capacity, quantum int64) *Bucket
func NewBucketWithRate(rate float64, capacity int64) *Bucket

func (tb *Bucket) Take(count int64) time.Duration {}
func (tb *Bucket) TakeAvailable(count int64) int64 {}
func (tb *Bucket) TakeMaxDuration(count int64, maxWait time.Duration) (
    time.Duration, bool,
) {}
func (tb *Bucket) Wait(count int64) {}
func (tb *Bucket) WaitMaxDuration(count int64, maxWait time.Duration) bool {}
</code></pre>

<p>这个库不支持令牌桶预热，且无法修改初始的令牌容量，所以可能个别极端情况下的需求无法满足</p>

<h3 id="原理-2">原理</h3>

<p>从功能上来看，令牌桶模型实际上就是对全局计数的加减法操作过程，但使用计数需要我们自己加读写锁</p>

<p>可以用buffered channel来完成简单的加令牌取令牌操作：</p>

<pre><code class="language-go">package main

import (
    &quot;fmt&quot;
    &quot;time&quot;
)

func main() {
    var fillInterval = time.Millisecond * 10
    var capacity = 100
    var tokenBucket = make(chan struct{}, capacity)

    fillToken := func() {
        ticker := time.NewTicker(fillInterval)
        for {
            select {
            case &lt;-ticker.C:
                select {
                case tokenBucket &lt;- struct{}{}:
                default:
                }
                fmt.Println(&quot;current token cnt:&quot;, len(tokenBucket), time.Now())
            }
        }
    }

    go fillToken()
    time.Sleep(time.Hour)
}

</code></pre>

<p>==那劳心费力地像本小节前面向channel里填充token的操作，理论上是没有必要的。==</p>

<p>只要在每次Take的时候，再对令牌桶中的token数进行简单计算，就可以得到正确的令牌数。</p>

<blockquote>
<p>我们来思考一下，令牌桶每隔一段固定的时间向桶中放令牌，如果我们记下上一次放令牌的时间为 t1，和当时的令牌数k1，放令牌的时间间隔为ti，每次向令牌桶中放x个令牌，令牌桶容量为cap。现在如果有人来调用TakeAvailable来取n个令牌，我们将这个时刻记为t2。在t2时刻，令牌桶中理论上应该有多少令牌呢？伪代码如下：</p>

<pre><code>cur = k1 + ((t2 - t1)/ti) * x
cur = cur &gt; cap ? cap : cur
</code></pre>
</blockquote>

<h3 id="服务瓶颈和-qos">服务瓶颈和 QoS</h3>

<blockquote>
<p>虽然性能指标很重要，但对用户提供服务时还应考虑服务整体的QoS。QoS全称是Quality of Service，顾名思义是服务质量。</p>
</blockquote>

<h2 id="5-7-layout-常见大型-web-项目分层">5.7 layout 常见大型 Web 项目分层</h2>

<p>流行的Web框架大多数是MVC框架</p>

<ul>
<li><p>控制器（Controller）- 负责转发请求，对请求进行处理。</p></li>

<li><p>视图（View） - 界面设计人员进行图形界面设计。</p></li>

<li><p>模型（Model） - 程序员编写程序应有的功能（实现算法等等）、数据库专家进行数据管理和数据库设计（可以实现具体的功能）。</p></li>
</ul>

<p>对于复杂的项目，一个C和一个M层显然是不够用的，现在比较流行的纯后端API模块一般采用下述划分方法：</p>

<ul>
<li><p>Controller，与上述类似，服务入口，负责处理路由，参数校验，请求转发。</p></li>

<li><p>Logic/Service，逻辑（服务）层，一般是业务逻辑的入口，可以认为从这里开始，所有的请求参数一定是合法的。业务逻辑和业务流程也都在这一层中。常见的设计中会将该层称为 Business Rules。</p></li>

<li><p>DAO/Repository，这一层主要负责和数据、存储打交道。将下层存储以更简单的函数、接口形式暴露给 Logic 层来使用。负责数据的持久化工作。</p></li>
</ul>

<p><img src="https://chai2010.cn/advanced-go-programming-book/images/ch6-08-controller-logic-dao.png" alt="图片" /></p>

<blockquote>
<p>本章前面讲到的thrift、gRPC和http并不是一定只选择其中一种，有时我们需要支持其中的两种，比如同一个接口，我们既需要效率较高的thrift，也需要方便debug的http入口</p>
</blockquote>

<p>除了CLD之外，还需要一个单独的protocol层，负责处理各种交互协议的细节</p>

<p><img src="https://chai2010.cn/advanced-go-programming-book/images/ch6-08-control-flow.png" alt="图片" /></p>

<blockquote>
<p>协议细节处理这一层实际上有大量重复劳动，每一个接口在协议这一层的处理，无非是把数据从协议特定的结构体(例如http.Request，thrift的被包装过了) 读出来，再绑定到我们协议无关的结构体上，再把这个结构体映射到Controller入口的结构体上，这些代码实际上长得都差不多。</p>
</blockquote>

<h2 id="5-8-接口和表驱动开发">5.8 接口和表驱动开发</h2>

<h3 id="业务系统的发展过程">业务系统的发展过程</h3>

<blockquote>
<p>互联网公司只要可以活过三年，工程方面面临的首要问题就是代码膨胀。系统的代码膨胀之后，可以将系统中与业务本身流程无关的部分做拆解和异步化。什么算是业务无关呢，比如一些统计、反作弊、营销发券、价格计算、用户状态更新等等需求。这些需求往往依赖于主流程的数据，但又只是挂在主流程上的旁支，自成体系。</p>
</blockquote>

<h3 id="使用函数封装业务流程">使用函数封装业务流程</h3>

<blockquote>
<p>最基本的封装过程，我们把相似的行为放在一起，然后打包成一个一个的函数</p>
</blockquote>

<h3 id="使用接口来做抽象">使用接口来做抽象</h3>

<blockquote>
<p>业务发展的早期，是不适宜引入接口（interface）的，很多时候业务流程变化很大，过早引入接口会使业务系统本身增加很多不必要的分层，从而导致每次修改几乎都要全盘否定之前的工作。</p>
</blockquote>

<h2 id="未完待续">未完待续</h2>

                        </div>

                        


                        

<div class="post-archive">
    <h2>See Also</h2>
    <ul class="listing">
        
        <li><a href="/posts/golang-leetcode/">Golang--Leetcode</a></li>
        
        <li><a href="/posts/golangstd-unicode/">Golang标准库--Unicode</a></li>
        
        <li><a href="/posts/golangstd-string/">Golang标准库--String</a></li>
        
        <li><a href="/posts/golangstd-bytes/">Golang标准库--Bytes</a></li>
        
        <li><a href="/posts/golangstd-bufio/">Golang标准库--Bufio</a></li>
        
    </ul>
</div>


                        <div class="post-meta meta-tags">
                            
                            <ul class="clearfix">
                                
                                <li><a href="https://wushaoqiang.github.io/tags/Golang">Golang</a></li>
                                
                                <li><a href="https://wushaoqiang.github.io/tags/%E5%9F%BA%E7%A1%80">基础</a></li>
                                
                            </ul>
                            
                        </div>
                    </article>
                    
    

    
    
    <div class="post bg-white">
      <script src="https://utteranc.es/client.js"
            repo= "wushaoqiang/blogcomment"
            issue-term="pathname"
            theme="github-light"
            crossorigin="anonymous"
            async>
      </script>
    </div>
    
                </div>
            </div>
            <div id="secondary">
    <section class="widget">
        <form id="search" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank" _lpchecked="1">
      
      <input type="text" name="q" maxlength="20" placeholder="Search">
      <input type="hidden" name="sitesearch" value="https://wushaoqiang.github.io">
      <button type="submit" class="submit icon-search"></button>
</form>
    </section>
    
    <section class="widget">
        <h3 class="widget-title">最近文章</h3>
<ul class="widget-list">
    
    <li>
        <a href="https://wushaoqiang.github.io/posts/leetcode/leetcode-617/" title="Leetcode 617">Leetcode 617</a>
    </li>
    
    <li>
        <a href="https://wushaoqiang.github.io/posts/leetcode-606/" title="Leetcode 606">Leetcode 606</a>
    </li>
    
    <li>
        <a href="https://wushaoqiang.github.io/posts/leetcode-572/" title="Leetcode 572">Leetcode 572</a>
    </li>
    
    <li>
        <a href="https://wushaoqiang.github.io/posts/leetcode-563/" title="Leetcode 563">Leetcode 563</a>
    </li>
    
    <li>
        <a href="https://wushaoqiang.github.io/posts/leetcode-543/" title="Leetcode 543">Leetcode 543</a>
    </li>
    
    <li>
        <a href="https://wushaoqiang.github.io/posts/leetcode-538/" title="Leetcode 538">Leetcode 538</a>
    </li>
    
    <li>
        <a href="https://wushaoqiang.github.io/posts/leetcode-530/" title="Leetcode 530">Leetcode 530</a>
    </li>
    
    <li>
        <a href="https://wushaoqiang.github.io/posts/leetcode-501/" title="Leetcode 501">Leetcode 501</a>
    </li>
    
    <li>
        <a href="https://wushaoqiang.github.io/posts/leetcode-437/" title="Leetcode 437">Leetcode 437</a>
    </li>
    
    <li>
        <a href="https://wushaoqiang.github.io/posts/leetcode-414/" title="Leetcode 414">Leetcode 414</a>
    </li>
    
</ul>
    </section>

    

    <section class="widget">
        <h3 class="widget-title">分类</h3>
<ul class="widget-list">
    
    <li>
        <a href="https://wushaoqiang.github.io/categories/Algorithm/">Algorithm(2)</a>
    </li>
    
    <li>
        <a href="https://wushaoqiang.github.io/categories/Definition/">Definition(1)</a>
    </li>
    
    <li>
        <a href="https://wushaoqiang.github.io/categories/Favorite/">Favorite(1)</a>
    </li>
    
    <li>
        <a href="https://wushaoqiang.github.io/categories/Git/">Git(2)</a>
    </li>
    
    <li>
        <a href="https://wushaoqiang.github.io/categories/Golang/">Golang(45)</a>
    </li>
    
    <li>
        <a href="https://wushaoqiang.github.io/categories/Hugo/">Hugo(1)</a>
    </li>
    
    <li>
        <a href="https://wushaoqiang.github.io/categories/Leetcode/">Leetcode(93)</a>
    </li>
    
    <li>
        <a href="https://wushaoqiang.github.io/categories/Linux/">Linux(4)</a>
    </li>
    
    <li>
        <a href="https://wushaoqiang.github.io/categories/Opinion/">Opinion(1)</a>
    </li>
    
    <li>
        <a href="https://wushaoqiang.github.io/categories/Vscode/">Vscode(1)</a>
    </li>
    
    <li>
        <a href="https://wushaoqiang.github.io/categories/protocal/">protocal(1)</a>
    </li>
    
    <li>
        <a href="https://wushaoqiang.github.io/categories/questions/">questions(1)</a>
    </li>
    
    <li>
        <a href="https://wushaoqiang.github.io/categories/%E5%AF%86%E7%A0%81%E5%AD%A6/">密码学(1)</a>
    </li>
    
    <li>
        <a href="https://wushaoqiang.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库(9)</a>
    </li>
    
    <li>
        <a href="https://wushaoqiang.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构(2)</a>
    </li>
    
    <li>
        <a href="https://wushaoqiang.github.io/categories/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/">网络基础(9)</a>
    </li>
    
    <li>
        <a href="https://wushaoqiang.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/">计算机基础(1)</a>
    </li>
    
    <li>
        <a href="https://wushaoqiang.github.io/categories/%E8%B5%84%E6%BA%90/">资源(1)</a>
    </li>
    
</ul>
    </section>

    <section class="widget">
        <h3 class="widget-title">标签</h3>
<div class="tagcloud">
    
    <a href="https://wushaoqiang.github.io/tags/Algorithm/">Algorithm</a>
    
    <a href="https://wushaoqiang.github.io/tags/Beego/">Beego</a>
    
    <a href="https://wushaoqiang.github.io/tags/Blog/">Blog</a>
    
    <a href="https://wushaoqiang.github.io/tags/Channel/">Channel</a>
    
    <a href="https://wushaoqiang.github.io/tags/Command/">Command</a>
    
    <a href="https://wushaoqiang.github.io/tags/Context/">Context</a>
    
    <a href="https://wushaoqiang.github.io/tags/Crawler/">Crawler</a>
    
    <a href="https://wushaoqiang.github.io/tags/DHCP/">DHCP</a>
    
    <a href="https://wushaoqiang.github.io/tags/Definition/">Definition</a>
    
    <a href="https://wushaoqiang.github.io/tags/Easy/">Easy</a>
    
    <a href="https://wushaoqiang.github.io/tags/Effective/">Effective</a>
    
    <a href="https://wushaoqiang.github.io/tags/Exercism/">Exercism</a>
    
    <a href="https://wushaoqiang.github.io/tags/Favorite/">Favorite</a>
    
    <a href="https://wushaoqiang.github.io/tags/GC/">GC</a>
    
    <a href="https://wushaoqiang.github.io/tags/Generic/">Generic</a>
    
    <a href="https://wushaoqiang.github.io/tags/Gin/">Gin</a>
    
    <a href="https://wushaoqiang.github.io/tags/Git/">Git</a>
    
    <a href="https://wushaoqiang.github.io/tags/Golang/">Golang</a>
    
    <a href="https://wushaoqiang.github.io/tags/Gopher/">Gopher</a>
    
    <a href="https://wushaoqiang.github.io/tags/HTTP/">HTTP</a>
    
    <a href="https://wushaoqiang.github.io/tags/Hugo/">Hugo</a>
    
    <a href="https://wushaoqiang.github.io/tags/IP/">IP</a>
    
    <a href="https://wushaoqiang.github.io/tags/Interface/">Interface</a>
    
    <a href="https://wushaoqiang.github.io/tags/Internet/">Internet</a>
    
    <a href="https://wushaoqiang.github.io/tags/LeetCode/">LeetCode</a>
    
    <a href="https://wushaoqiang.github.io/tags/Leetcode/">Leetcode</a>
    
    <a href="https://wushaoqiang.github.io/tags/Linux/">Linux</a>
    
    <a href="https://wushaoqiang.github.io/tags/Log/">Log</a>
    
    <a href="https://wushaoqiang.github.io/tags/Map/">Map</a>
    
    <a href="https://wushaoqiang.github.io/tags/Module/">Module</a>
    
    <a href="https://wushaoqiang.github.io/tags/Mongodb/">Mongodb</a>
    
    <a href="https://wushaoqiang.github.io/tags/NAT/">NAT</a>
    
    <a href="https://wushaoqiang.github.io/tags/NoSQL/">NoSQL</a>
    
    <a href="https://wushaoqiang.github.io/tags/Path/">Path</a>
    
    <a href="https://wushaoqiang.github.io/tags/Pipeline/">Pipeline</a>
    
    <a href="https://wushaoqiang.github.io/tags/SQL/">SQL</a>
    
    <a href="https://wushaoqiang.github.io/tags/Search/">Search</a>
    
    <a href="https://wushaoqiang.github.io/tags/Sentences/">Sentences</a>
    
    <a href="https://wushaoqiang.github.io/tags/Slice/">Slice</a>
    
    <a href="https://wushaoqiang.github.io/tags/Sort/">Sort</a>
    
    <a href="https://wushaoqiang.github.io/tags/TCP/">TCP</a>
    
    <a href="https://wushaoqiang.github.io/tags/UDP/">UDP</a>
    
    <a href="https://wushaoqiang.github.io/tags/Ubuntu/">Ubuntu</a>
    
    <a href="https://wushaoqiang.github.io/tags/Validation/">Validation</a>
    
    <a href="https://wushaoqiang.github.io/tags/Vscode/">Vscode</a>
    
    <a href="https://wushaoqiang.github.io/tags/Web/">Web</a>
    
    <a href="https://wushaoqiang.github.io/tags/gocode/">gocode</a>
    
    <a href="https://wushaoqiang.github.io/tags/goquery/">goquery</a>
    
    <a href="https://wushaoqiang.github.io/tags/gorm/">gorm</a>
    
    <a href="https://wushaoqiang.github.io/tags/handler/">handler</a>
    
    <a href="https://wushaoqiang.github.io/tags/make/">make</a>
    
    <a href="https://wushaoqiang.github.io/tags/mega/">mega</a>
    
    <a href="https://wushaoqiang.github.io/tags/network/">network</a>
    
    <a href="https://wushaoqiang.github.io/tags/new/">new</a>
    
    <a href="https://wushaoqiang.github.io/tags/protocal/">protocal</a>
    
    <a href="https://wushaoqiang.github.io/tags/questions/">questions</a>
    
    <a href="https://wushaoqiang.github.io/tags/viper/">viper</a>
    
    <a href="https://wushaoqiang.github.io/tags/%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5/">依赖注入</a>
    
    <a href="https://wushaoqiang.github.io/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/">内存管理</a>
    
    <a href="https://wushaoqiang.github.io/tags/%E5%8A%A0%E5%AF%86/">加密</a>
    
    <a href="https://wushaoqiang.github.io/tags/%E5%9F%BA%E7%A1%80/">基础</a>
    
    <a href="https://wushaoqiang.github.io/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/">密码学</a>
    
    <a href="https://wushaoqiang.github.io/tags/%E5%B0%8F%E6%8A%80%E5%B7%A7/">小技巧</a>
    
    <a href="https://wushaoqiang.github.io/tags/%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/">异常处理</a>
    
    <a href="https://wushaoqiang.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a>
    
    <a href="https://wushaoqiang.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a>
    
    <a href="https://wushaoqiang.github.io/tags/%E6%A0%87%E5%87%86%E5%BA%93/">标准库</a>
    
    <a href="https://wushaoqiang.github.io/tags/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%8C%85/">第三方包</a>
    
    <a href="https://wushaoqiang.github.io/tags/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/">网络协议</a>
    
    <a href="https://wushaoqiang.github.io/tags/%E7%BD%91%E7%BB%9C%E7%AE%A1%E7%90%86/">网络管理</a>
    
    <a href="https://wushaoqiang.github.io/tags/%E8%A7%82%E7%82%B9/">观点</a>
    
    <a href="https://wushaoqiang.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/">计算机基础</a>
    
    <a href="https://wushaoqiang.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/">计算机系统</a>
    
    <a href="https://wushaoqiang.github.io/tags/%E8%B5%84%E6%BA%90/">资源</a>
    
    <a href="https://wushaoqiang.github.io/tags/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/">进程管理</a>
    
    <a href="https://wushaoqiang.github.io/tags/%E9%85%8D%E7%BD%AE%E9%97%AE%E9%A2%98/">配置问题</a>
    
    <a href="https://wushaoqiang.github.io/tags/%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/">错误处理</a>
    
    <a href="https://wushaoqiang.github.io/tags/%E9%9D%A2%E8%AF%95/">面试</a>
    
</div>
    </section>

    

    <section class="widget">
        <h3 class="widget-title">其它</h3>
        <ul class="widget-list">
            <li><a href="https://wushaoqiang.github.io/index.xml">文章 RSS</a></li>
        </ul>
    </section>
</div>
        </div>
    </div>
</div>
<footer id="footer">
    <div class="container">
        &copy; 2019 <a href="https://wushaoqiang.github.io">Gavin&#39;s Blog By Gavin</a>.
        Powered by <a rel="nofollow noreferer noopener" href="https://gohugo.io" target="_blank">Hugo</a>.
        <a href="https://www.flysnow.org/" target="_blank">Theme</a> based on <a href="https://github.com/rujews/maupassant-hugo" target="_blank">maupassant</a>.
        
    </div>
</footer>


    <script type="text/javascript">
    
    (function(){
        $("pre code").parent().addClass("line-numbers")
    }())

    window.MathJax = {
        tex2jax: {
            inlineMath: [ ['$','$'] ],
            processEscapes: true
        }
    };
    </script>
    <script type="text/javascript" src="/js/prism.js" async="true"></script>
    <script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML' async></script>

<a id="rocket" href="#top"></a>
<script type="text/javascript" src="/js/totop.js?v=0.0.0" async=""></script>



<script type="text/javascript" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script>




</body>
</html>
