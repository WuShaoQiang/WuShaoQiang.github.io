<!doctype html>
<html lang="en-us">
<head>

    <meta charset="utf-8">
    <meta name="generator" content="Hugo 0.40.1" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <title>网络协议基础 | Gavin&#39;s Blog</title>
    <meta property="og:title" content="网络协议基础 - Gavin&#39;s Blog">
    <meta property="og:type" content="article">
        
    <meta property="article:published_time" content="2019-03-17T01:58:00&#43;08:00">
        
        
    <meta property="article:modified_time" content="2019-03-17T01:58:00&#43;08:00">
        
    <meta name="Keywords" content="Golang,Gavin,Blog">
    <meta name="description" content="网络协议基础">
        
    <meta name="author" content="Gavin">
    <meta property="og:url" content="https://wushaoqiang.github.io/posts/computer-network/internet-protocal/">
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">

    <link rel="stylesheet" href="/css/normalize.css">
    
        <link rel="stylesheet" href="/css/prism.css">
    
    <link rel="stylesheet" href="/css/style.css">
    <script type="text/javascript" src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script>

    


    
    
</head>

<body>
<header id="header" class="clearfix">
    <div class="container">
        <div class="col-group">
            <div class="site-name ">
                
                    <a id="logo" href="https://wushaoqiang.github.io">
                        Gavin&#39;s Blog
                    </a>
                
                <p class="description">Gopher，后端开发，网络基础，WEB协议、架构、存储、缓冲、安全，学习笔记</p>
            </div>
            <div>
                <nav id="nav-menu" class="clearfix">
                    <a class="" href="https://wushaoqiang.github.io">首页</a>
                    
                    <a  href="https://wushaoqiang.github.io/archives/" title="归档">归档</a>
                    
                    <a  href="https://wushaoqiang.github.io/about/" title="关于">关于</a>
                    
                </nav>
            </div>
        </div>
    </div>
</header>


<div id="body">
    <div class="container">
        <div class="col-group">

            <div class="col-8" id="main">
                <div class="res-cons">
                    <article class="post">
                        <header>
                            <h1 class="post-title">网络协议基础</h1>
                        </header>
                        <date class="post-meta meta-date">
                            2019年3月17日
                        </date>
                        
                        <div class="post-meta">
                            <span>|</span>
                            
                                <span class="meta-category"><a href="https://wushaoqiang.github.io/categories/protocal">protocal</a></span>
                            
                        </div>
                        
                        
                        <div class="post-meta">
                            <span id="busuanzi_container_page_pv">|<span id="busuanzi_value_page_pv"></span><span> 阅读</span></span>
                        </div>
                        
                        <div class="post-content">
                            

<p>OSI模型把网络通信的工作分为7层，分别是物理层、数据链路层、网络层、传输层、会话层、表示层和应用层</p>

<p>一直觉得自己的基础很不牢固，事实也确实是这样，希望自己能够系统的总结好计算机网络这本书</p>

<h1 id="二-应用层">二、应用层</h1>

<p>Web、电子邮件、DNS和对等文件分发等</p>

<h2 id="2-1-应用层协议原理">2.1 应用层协议原理</h2>

<h3 id="2-1-1-网络应用程序体系结构">2.1.1 网络应用程序体系结构</h3>

<p>应用程序体系结构</p>

<ul>
<li><p>客户-服务器体系结构</p></li>

<li><p>对等体系结构(P2P)</p></li>
</ul>

<p>现在大多数应用都是以客户-服务器体系结构</p>

<p>P2P面临的挑战</p>

<ul>
<li><p>下载比上传多很多</p></li>

<li><p>安全性</p></li>

<li><p>用户是否能自愿提供带宽、存储和计算资源</p></li>
</ul>

<p>最近比较火的一个名词<strong>区块链</strong>就是倡导去中心化的网络，也就是P2P</p>

<h3 id="2-1-2-进程通信">2.1.2 进程通信</h3>

<p>在同一个端系统上(可以理解为同一部电脑)，进程间通信的规则由端系统上的操作系统决定</p>

<p>在不同端系统上，通过跨越计算机网络交换<strong>报文</strong>来相互通信</p>

<h4 id="2-1-2-1-客户和服务器进程">2.1.2.1 客户和服务器进程</h4>

<p>发起通信的进程就是<strong>客户</strong></p>

<p>等待联系的进程是<strong>服务器</strong></p>

<h4 id="2-1-2-2-进程与计算机网络之间的接口">2.1.2.2 进程与计算机网络之间的接口</h4>

<p>进程通过一个称为<strong>套接字</strong>的软件接口向网络发送报文和从网络接收报文</p>

<p>这个套接字就好比如一个房子的大门，发送或者接收都要先开门</p>

<p>而这里把进程比作房子，运输层协议(TCP等)比作两个房子的路</p>

<p>所以套接字是应用层和运输层的接口，也叫<strong>应用程序编程接口(API)</strong></p>

<h4 id="2-1-2-3-进程寻址">2.1.2.3 进程寻址</h4>

<p>主机由<strong>IP地址</strong>标识</p>

<p>指定的进程由<strong>端口号</strong>标识</p>

<h3 id="2-1-3-可供应用程序使用的运输服务">2.1.3 可供应用程序使用的运输服务</h3>

<p>根据运输层所提供的服务来决定用哪种运输层协议</p>

<h4 id="2-1-3-1-可靠数据传输">2.1.3.1 可靠数据传输</h4>

<p>当一个运输协议提供这种服务时，发送进程只要将其数据传递进套接字，就可以完全相信该数据将能无差错地到达接收进程</p>

<p>有些能够容忍数据丢失的应用可以不使用可靠数据传输</p>

<h4 id="2-1-3-2-吞吐量">2.1.3.2 吞吐量</h4>

<p>吞吐量就是发送进程能够向接收进程交付比特的速率</p>

<p>具有吞吐量要求的应用被称为<strong>带宽敏感应用</strong></p>

<p>否则就称为<strong>弹性应用</strong></p>

<h4 id="2-1-3-3-定时">2.1.3.3 定时</h4>

<p>对于实时要求较高的应用</p>

<h4 id="2-1-3-4-安全性">2.1.3.4 安全性</h4>

<p>防止数据以某种方式在两个进程之间被观察到</p>

<p>安全包括</p>

<ul>
<li><p>机密性</p></li>

<li><p>完整性</p></li>

<li><p>端点鉴别</p></li>
</ul>

<h3 id="2-1-4-因特网提供的运输服务">2.1.4 因特网提供的运输服务</h3>

<p>两个传输协议：TCP和UDP</p>

<h4 id="2-1-4-1-tcp服务">2.1.4.1 TCP服务</h4>

<p>TCP服务模型包括<strong>面向连接服务</strong>和<strong>可靠传输服务</strong></p>

<ul>
<li><p>面向连接服务：在应用层数据报文开始流动之前，TCP让客户端和服务器互相交换运输层控制信息(<strong>三次握手</strong>)，握手后TCP连接就在这两个进程建立起来了</p></li>

<li><p>可靠的数据传送服务：按顺序、所有数据</p></li>
</ul>

<p>TCP协议还具有拥塞控制机制，当双方之间的网络出现拥塞，TCP会抑制发送进程。这个机制也试图限制每个TCP连接，使它们公平共享网络带宽。</p>

<p><strong>关于TCP的安全</strong></p>

<p>SSL(安全套接字层)，这是在应用层上实现的，利用现有的库，进程将明文传递给SSL套接字，然后SSL将加密后的数据传递给TCP套接字。</p>

<p>在接收方面恰好是反过来的</p>

<h4 id="2-1-4-2-udp服务">2.1.4.2 UDP服务</h4>

<p>UDP是无连接的，传输是不可靠的，不可靠包括了数据丢失或者是数据到达顺序发生改变</p>

<p>UDP没有包括拥塞控制机制</p>

<p>许多防火墙被设置成阻挡UDP流量</p>

<h3 id="2-1-5-应用层协议">2.1.5 应用层协议</h3>

<p>HTTP、SMTP、FTP、Telnet等</p>

<p>应用层协议定义了：</p>

<ul>
<li><p>报文类型</p></li>

<li><p>报文语法</p></li>

<li><p>字段语义</p></li>

<li><p>如何发送以及如何响应</p></li>
</ul>

<h2 id="2-2-web和http">2.2 Web和HTTP</h2>

<h3 id="2-2-1-http概况">2.2.1 HTTP概况</h3>

<p>HTTP使用TCP作为它的支撑运输层协议，HTTP客户端首先与服务器建立起TCP连接，然后再通过套接字发送报文</p>

<p>客户向套接字发送一个请求报文，该报文就脱离了客户控制并进入TCP的控制</p>

<p>HTTP是一个无状态协议，用80端口</p>

<h3 id="2-2-2-非持续性连接和持续连接">2.2.2 非持续性连接和持续连接</h3>

<p>往返时间(RTT)</p>

<p>请求并接收一个HTML文件所需要的时间估算是： 两个RTT加上服务器传输HTML文件的时间</p>

<p>HTTP默认模式是使用带流水线的持续连接</p>

<p>什么是带流水线呢？ 就是我们一次发送一个数据包，而不是发一个数据包等客户端ACK后再发一个。流水线是为了提高网络传输效率的</p>

<h3 id="2-2-3-http报文格式">2.2.3 HTTP报文格式</h3>

<h4 id="2-2-3-1-请求报文">2.2.3.1 请求报文</h4>

<p>每行由一个回车和换行符结束</p>

<p>最后一行后再附加一个回车换行符</p>

<p>第一行是请求行，后续的叫首部行，空行后有一个实体主体，这个实体主体常用在POST表单上</p>

<p>用表单生成的请求报文不一定要使用POST方法，GET方法也可以，所请求的URL中包括输入时的数据，好比如百度搜索的时候</p>

<pre><code>https://www.baidu.com/s?ie=utf-8&amp;f=8&amp;rsv_bp=1&amp;rsv_idx=1&amp;tn=baidu&amp;wd=%E5%95%8A%E5%95%8A%E5%95%8A&amp;rsv_pq=e7259622000271e7&amp;rsv_t=d3e4h4XBCPAF0jsbR4g2aZu0MLBKvgn6ragrTqNwy6ch5qIEldevd4IoHII&amp;rqlang=cn&amp;rsv_enter=1&amp;rsv_sug3=4&amp;rsv_sug1=1&amp;rsv_sug7=100&amp;rsv_sug2=0&amp;inputT=1089&amp;rsv_sug4=1091
</code></pre>

<p>报文格式已经掌握就不说了</p>

<h4 id="2-2-3-2-响应报文">2.2.3.2 响应报文</h4>

<p>第一行是状态行，后面是首部行，空行，实体体</p>

<p>状态码</p>

<ul>
<li><p>301 Moved Permanently 永久转移，新的URL将会在响应报文的<code>Location</code>字段</p></li>

<li><p>400 Bad Request 请求不能被理解，有可能是服务器并没有实现对应方法</p></li>

<li><p>505 HTTP Version Not Supported HTTP版本不支持、</p></li>
</ul>

<h3 id="2-2-4-用户与服务器的交互-cookie">2.2.4 用户与服务器的交互： cookie</h3>

<p>服务器的响应报文中可能会有：<code>Set-cookie</code></p>

<p>我们的浏览器会帮我们管理cookie，并且在请求网站的时候把对应的Cookie写到请求报文中</p>

<h3 id="2-2-5-web缓存">2.2.5 Web缓存</h3>

<p>为了减少响应时延，因为局域网速度较快，链路宽带成本高，所以我们可以把Web缓存在服务器里，这样就不用每次请求都经过链路网络</p>

<p>但这里存在一个问题就是，网络随时可能被更新，这个时候在缓冲器里面的Web就不适用了。</p>

<h3 id="2-2-6-条件get方法">2.2.6 条件GET方法</h3>

<p>缓存器在存储对象的时候也存储了最后的修改时间。</p>

<p>缓冲器通过发送一个首部行带<code>If-Modified-Since</code>字段到服务器端，检查缓冲器里的Web页面是否要更新</p>

<h2 id="2-3-ftp">2.3 FTP</h2>

<p>21号端口</p>

<p>FTP使用了两个并行的TCP连接来传输文件，一个是控制连接，一个是数据连接</p>

<p>控制连接贯穿了整个用户会话期间</p>

<p>但是会话中的每一次文件传输都需要建立一个新的数据连接(即数据连接是非连续的)</p>

<p>FTP必须在整个会话期间保留用户的状态，因此大大限制了FTP同时维持的会话总数</p>

<h2 id="2-4-因特网中的电子邮件">2.4 因特网中的电子邮件</h2>

<p>25号端口</p>

<p>因特网电子邮件系统可以分为</p>

<ul>
<li><p>用户代理</p></li>

<li><p>邮件服务器</p></li>

<li><p>简单邮件传输协议</p></li>
</ul>

<p>用户A &mdash;-&gt; 用户A所在的邮件服务器 &mdash;-&gt; 用户B所在的邮件服务器 &mdash;-&gt; 用户B</p>

<p>但是现在基本都是基于Web的电子邮件</p>

<p>所以整个流程变成了 HTTP &mdash;&gt; SMTP &mdash;&gt; HTTP</p>

<p>只是邮件服务器之间还是用SMTP协议来传输</p>

<h2 id="2-5-dns-因特网的目录服务">2.5 DNS：因特网的目录服务</h2>

<h3 id="2-5-1-dns提供的服务">2.5.1 DNS提供的服务</h3>

<p>主机名(Host)到IP地址的转换</p>

<p>DNS是一个由分层的DNS服务器实现的分布式数据库</p>

<p>这也是一个协议：一个使得主机能够查询分布式数据库的应用层协议</p>

<p>DNS协议运行在<strong>UDP</strong>之上，用的是53号端口</p>

<p>主机别名：为了比<strong>规范主机名</strong>更容易记忆，可以通过DNS来获得主机别名对应的规范主机名以及主机的IP</p>

<p>邮件服务器别名：允许一个公司的邮件服务器和Web服务器使用相同的主机名</p>

<p>负载分配：有几个IP不同的服务器共用一个规范主机名，这样就可以通过对数据的分流来分配负载</p>

<h3 id="2-5-2-dns工作机理原理">2.5.2 DNS工作机理原理</h3>

<p>首先DNS是分布式的</p>

<p>DNS服务器使用层级方式组织</p>

<ul>
<li><p>根DNS服务器</p></li>

<li><p>顶级域DNS服务器(TLD服务器)，是来解析最后面的(.com .org等)</p></li>

<li><p>权威DNS服务器</p></li>
</ul>

<p>还有一个不在层级内，但是很重要的本地DNS服务器</p>

<p>一个DNS查询可能需要花很多的时间，所以需要DNS缓存</p>

<p>DNS缓存其实和Web缓存的道理是差不多的，都是尽量将最近的数据存起来，方便用户下次使用时能有较快的响应。</p>

<h3 id="2-5-3-dns记录和报文">2.5.3 DNS记录和报文</h3>

<p>资源记录(RR)提供了主机名到IP地址的映射</p>

<p>资源记录包含下列字段
(Name,Value,Type,TTL)</p>

<p>TTL是该记录的生存时间</p>

<p>Name和Value的值取决于Type</p>

<ul>
<li><p>Type=A则Name是主机名，Value是对应的IP地址</p></li>

<li><p>Type=NS则Name是个域，Value是对应能够获取该域IP地址的权威DNS服务器的主机名</p></li>

<li><p>Type=CNAME则Name是别名，Value是规范主机名</p></li>

<li><p>Type=MX则Value是别名为Name的邮件服务器的规范主机名</p></li>
</ul>

<h4 id="2-5-3-1-dns报文">2.5.3.1 DNS报文</h4>

<p>因为书上写的不怎么详细，找了一个解释的还比较详细的<a href="https://blog.csdn.net/liao152/article/details/45252387">文章</a></p>

<h2 id="2-6-p2p应用">2.6 P2P应用</h2>

<p>BitTorrent、分布式散列表</p>

<h3 id="p2p文件分发">P2P文件分发</h3>

<h4 id="2-6-1-1-p2p体系结构的扩展性">2.6.1。1 P2P体系结构的扩展性</h4>

<p>从书上详细的例子举证</p>

<p>客户-服务器结构的分发时间<strong>下限</strong></p>

<pre><code>D = max{NF/Us,F/dmin}

其中N代表对等方，F是某个文件的大小，Us是上传速度，dmin是下载速度(全部人里最慢的)
</code></pre>

<p>P2P结构的分发时间<strong>下限</strong></p>

<pre><code>D = {F/Us,F/dmin,NF/(Us+u1+u2+...)}
</code></pre>

<p>所以第一种情况是随着客户越多程线性增长</p>

<p>第二中情况则在人数较多的情况下分发时间会相对较小</p>

<h4 id="2-6-2-bittorrent">2.6.2 BitTorrent</h4>

<p>参与一个特定文件分发的所有对等方的集合被称为一个洪流(torrent)</p>

<p>在一个洪流中的对等方彼此下载等长度的文件块(chunk)，典型的块长度为256KB</p>

<p>每个洪流具有一个基础设施结点，称为追踪器(tracker),用来追踪洪流中的对等方</p>

<p>最稀缺优先：目标是均衡每个块在洪流中的副本数量</p>

<p>对换算法：对以最高速率向他提供数据的邻居，给出优先权，这种效果是对等方能够以趋向于找到彼此的协调的速率上传，这就是一报还一报，避免大多数用户搭便车</p>

<h3 id="2-6-2-分布式散列表-dht">2.6.2 分布式散列表(DHT)</h3>

<p>第一种，直接插入数据，要求访问每一个对等方(不现实)</p>

<p>第二种，环形DHT，平均需要发送N/2次报文(不现实)</p>

<p>第三种，具有捷径的环形DHT，每个请求报文均为O(logN)</p>

<p>利用对等方扰动可以维护DHT</p>

<h1 id="三-运输层">三、运输层</h1>

<h2 id="3-1-概述和运输层服务">3.1 概述和运输层服务</h2>

<p>运输层协议为运行在不同主机上的应用进程之间提供了逻辑通信</p>

<p>运输层协议是在端系统中而不是在路由器中实现的</p>

<p>运输层报文段：将从进程收到的报文划分为较小的块，并加上一个运输层首部以生成运输层报文段</p>

<p>数据报：网络层将从运输层得到的报文段封装成网络层分组(数据报)</p>

<p>网络路由器只作用于该数据报的网络层字段</p>

<p>因特网有两种协议：TCP和UDP</p>

<h3 id="3-1-1-运输层和网络层的关系">3.1.1 运输层和网络层的关系</h3>

<p>运输层协议只工作在端系统中：运输层协议将来自应用的进程的报文移动到网络边缘(网络层)</p>

<p>如果网络层协议无法为主机之间的运输层报文段提供时延或带宽保证的话，运输层协议也就无法为进程之间发送的应用程序报文提供时延或带宽保证</p>

<p>UDP(用户数据报协议)，TCP(传输控制协议)</p>

<p>IP的服务模型是尽力而为交付服务，是一种不可靠服务，IP尽最大可能在通信的的<strong>主机</strong>之间交付报文段</p>

<p>UDP和TCP最基本的责任是，将两个端系统之间(主机之间)IP的交付服务扩展为运行在端系统上的两个<strong>进程</strong>之间的交付服务</p>

<p>进程到进程的<strong>数据交付</strong>和<strong>差错检查</strong>是两种<strong>最低限度</strong>的运输层服务，UDP就只能提供这样的服务</p>

<h2 id="3-2-多路复用与多路分解">3.2 多路复用与多路分解</h2>

<p>多路复用与多路分解服务是所有计算机网络都需要的</p>

<p>多路分解：将运输层报文段中的数据交付到正确的套接字的工作</p>

<p>多路复用：从不同套接字中收集数据块，并为每个数据块封装上首部信息从而生成报文段，然后传递到网络层</p>

<p>运输层多路复用要求：</p>

<ol>
<li><p>套接字有唯一标识符</p></li>

<li><p>每个报文段有特殊字段来指示该报文段所要交付到的套接字，并且这些字段分别是<strong>源端口号字段</strong>和<strong>目标端口号字段</strong>(UDP报文段和TCP报文段还有其他一些字段)</p></li>
</ol>

<h3 id="3-2-1-无连接的多路复用与多路分解">3.2.1 无连接的多路复用与多路分解</h3>

<p>通常，应用程序的客户端让运输层自动地分配端口号，而服务器端则分配一个特定的端口号</p>

<p>一个UDP套接字是由一个二元组来全面标识的，该二元组包含一个目的IP地址和一个目的端口号</p>

<p>也就是说只要这两个相同，那么指向的就是同一个套接字</p>

<h3 id="3-2-2-面向连接的多路复用与多路分解">3.2.2 面向连接的多路复用与多路分解</h3>

<p>TCP套接字是由一个四元组(源IP和端口号，目标IP和端口号)</p>

<p>每一个TCP报文到达主机时，都会将这个4个字段用来指向相应的套接字</p>

<h3 id="3-2-3-web服务器与tcp">3.2.3 Web服务器与TCP</h3>

<p>连接套接字与进程之间并非总是有着一对一的关系，事实上，当今高性能的Web服务器只使用一个进程，但是为每个新的客户连接创建一个具有新连接套接字的新线程</p>

<p>所以如果HTTP使用非持续连接模式，那么每一对请求/响应都要创建一个新的套接字并且关闭，会影响服务器性能</p>

<h2 id="3-3-无连接运输-udp">3.3 无连接运输：UDP</h2>

<p>UDP的优点</p>

<ul>
<li><p>关于何时、发送什么数据的应用层控制更为精细(不保证丢包率)</p></li>

<li><p>无需连接建立(减少时延)</p></li>

<li><p>无连接状态(支持更多用户)</p></li>

<li><p>分组首部开销小(UDP首部有8字节，TCP首部有20字节)</p></li>
</ul>

<p>网络管理应用程序通常必须在该网络处于重压状态时运行，而这个时候TCP会被阻塞</p>

<p>UDP中缺乏拥塞控制能够导致UDP发送方和接收方之间的高丢包率，并挤垮TCP会话(想想看，UDP强占TCP的带宽，TCP就没带宽了)</p>

<p>UDP也是可以实现可靠数据传输的，通过在应用程序自身中建立可靠性机制来完成(增加确认与重传机制)，但这样也会令开发人员长时间忙于调试</p>

<h3 id="3-3-1-udp报文结构">3.3.1 UDP报文结构</h3>

<p><img src="http://www.gavinblog.info/posts/image/udp.jpg" alt="UDP报文结构" /></p>

<ul>
<li><p>长度字段：首部加数据的字节数</p></li>

<li><p>校验和：发送方的UDP对报文段中的所有16比特字的和进行反码运算</p></li>
</ul>

<p>所以在接收方中，将所有字段加起来(包括校验和)的结果应该是<code>1111111111111111</code></p>

<p>这样说明UDP必须在端到端的基础上在运输层提供差错检测(端到端原则)</p>

<h2 id="3-4-可靠数据传输原理">3.4 可靠数据传输原理</h2>

<p>我们可将较低层直接视为不可靠的点对点信道，但是我们假设底层信道不会对分组重排序(只是会丢失分组)</p>

<p>而且在这里我们只考虑单向传输，就是一个扮演发送者，一个扮演接收者(这并不代表接收者不会像发送者发送控制信息)</p>

<h3 id="3-4-1-构造可靠数据传输协议">3.4.1 构造可靠数据传输协议</h3>

<p><code>ACK</code>(肯定确认)</p>

<p><code>NAK</code>(否认确认)</p>

<p>停等协议： 发送方将不会发送一块新数据，除非发送方确信接收方已正确接收当前分组</p>

<p>流水线协议：允许发送方发送多个分组而无需等待确认</p>

<p>数据传输协议的要点：检验和、序号、定时器、肯定和否定确认</p>

<p>TCP序号是按字节流中的字节进行计数的，而不是按分组计数</p>

<h3 id="3-4-2-流水线可靠传输协议">3.4.2 流水线可靠传输协议</h3>

<p>流水线技术对可靠数据传输协议可带来如下影响</p>

<ul>
<li><p>必须增加序号范围(之前是一个比特，因为之前确认一个才发一个)</p></li>

<li><p>发送方和接收方需要缓冲(发送方至少能够缓冲那些发送了但还未确认的分组，接收方或许也需要缓存那些以正确接收的分组)</p></li>
</ul>

<p>这两个因素的要求都取决于数据传输协议如何处理丢失、损坏及延时过大的分组，这里有两种方法</p>

<ul>
<li><p>回退N步</p></li>

<li><p>选择重传</p></li>
</ul>

<h3 id="回退n步-gbn">回退N步(GBN)</h3>

<p>GBN协议也常被称为滑动窗口协议</p>

<p>涉及序号的运算必须使用模2^k运算，即序号空间可以看成一个环</p>

<p>GBN发送方必须响应三种类型的事件</p>

<ul>
<li><p>上层的调用(如果窗口已满，要么拒绝接收，要么缓存)</p></li>

<li><p>收到一个ACK(ACK里面有序号n代表n之前和其本身的分组已经被接收到了，这叫<strong>累计确认</strong>)</p></li>

<li><p>超时事件(超时，发送方重传所有已发送但没确认的分组；收到一个ACK会重置定时器,所有分组只有一个定时器)</p></li>
</ul>

<p>这个模式中，接收方不用缓冲乱序的分组，接收方需要维护的唯一信息就是下一个按序接收的分组的序号</p>

<p>GBN包含的技术</p>

<ol>
<li><p>使用序号</p></li>

<li><p>累计确认</p></li>

<li><p>检验和</p></li>

<li><p>超时/重传</p></li>
</ol>

<h3 id="选择重传-sr">选择重传(SR)</h3>

<p>选择重传协议通过让发送方仅重传那些它怀疑在接收方出错的分组</p>

<p><img src="http://www.gavinblog.info/posts/image/SR.jpg" alt="选择重传序号空间" /></p>

<p>发送方三种类型的事件</p>

<ul>
<li><p>从上层接收事件(在满的时候要么拒绝接收，要么缓存起来)</p></li>

<li><p>超时(每个分组需要有自己的逻辑定时器)</p></li>

<li><p>收到ACK(窗口的第一个一定是未被确认的)</p></li>
</ul>

<p>接收方的事件</p>

<ul>
<li><p>序号在窗口内的，会在数据形成连续的时候上传到进程(比如先接收2,3,4 但是缺少了1，这个时候接收到1后就会全部打包上去)</p></li>

<li><p>重新确认： 如果发送方发来一个之前就以及确认过的分组，也要给予ACK(可能是发送方没有收到ACK或者收到晚了)</p></li>

<li><p>其它情况就忽略该分组</p></li>
</ul>

<p>在这里，发送方和接收方的窗口并不总是一致的</p>

<p>窗口长度必须小于或等于序号空间大小的一半(防止前一个循环的分组序号和后一个循环的分组序号重叠了而产生冗余分组，但实际上并不是冗余分组)</p>

<p>确保一个序号不被重新使用，直到发送方”确信“任何先前发送的序号为x的分组都不在网络中为止</p>

<p>在TCP扩展中，最长的分组寿命被假定为大约3分钟</p>

<h2 id="3-5-面向连接的传输-tcp">3.5 面向连接的传输：TCP</h2>

<h3 id="3-5-1-tcp连接">3.5.1 TCP连接</h3>

<p>TCP被称为是面向连接的，并且只在端系统中运行</p>

<p>发送缓存：是在第三次握手初期设置的缓存之一</p>

<p>TCP可从缓存中取出并放入报文段中的数据数量受限于<strong>最大报文段长度(MSS)</strong></p>

<p>最大传输单元(MTU) = MSS + TCP/IP首部长度(一般为40字节)，MSS的典型值为1460字节</p>

<p>要注意的是MSS是指报文段里<strong>应用层数据的最大长度</strong></p>

<p>TCP连接的组成包括：一台主机上的缓存、变量和与进程连接的套接字</p>

<h3 id="3-5-2-tcp报文段结构">3.5.2 TCP报文段结构</h3>

<p><img src="http://www.gavinblog.info/posts/image/tcp.jpg" alt="TCP报文段结构" /></p>

<ul>
<li>首部长度字段： 4比特，由于TCP选项字段的原因，TCP首部的长度是可变的，通常选项字段为空，所以TCP首部的典型长度就是20字节</li>
</ul>

<p>标志字段：</p>

<ol>
<li><p>ACK比特用于指示确认字段中的值是有效的</p></li>

<li><p>RST比特用于告诉对方这边没有上一个发送过来的报文段的套接字(可能是端口没有进程)</p></li>

<li><p>FIN比特用于关闭连接</p></li>

<li><p>SYN比特用于创建连接</p></li>

<li><p>PSH比特指示接收方应立即将数据交给上层</p></li>

<li><p>URG比特用来指示报文段里存在着被发送端上层实体置为”紧急“的数据</p></li>
</ol>

<h4 id="3-5-2-1-序号">3.5.2.1 序号</h4>

<p>序号是建立在传送的字节流之上，而不是建立在传送的报文段的序列之上</p>

<p>一个报文段的序号因此是该报文段首字节的字节流编号</p>

<p>TCP也提供<strong>累计确认</strong></p>

<p>TCP把报文段失序到达该做如何选择这一问题留给了编程人员(在编程中可能底层也已经打包好了)</p>

<ol>
<li><p>接收方立即丢弃失序报文段</p></li>

<li><p>缓存</p></li>
</ol>

<p>事实上，一条TCP连接的双方均可<strong>随机地选择初始序号</strong></p>

<h3 id="3-5-3-往返时间的估计与超时">3.5.3 往返时间的估计与超时</h3>

<h4 id="3-5-3-1-估计往返时间">3.5.3.1 估计往返时间</h4>

<p>EstimatedRTT = (1-α) * EstimatedRTT + α * SampleRTT</p>

<p>其中α参考值是0.125</p>

<p>测量RTT变化</p>

<p>DevRTT = (1-β) * DevRTT + β * |SampleRTT - EstimatedRTT|</p>

<h4 id="3-5-3-2-设置和管理重传超时间隔">3.5.3.2 设置和管理重传超时间隔</h4>

<p>超时间隔应该设置为EstimatedRTT加上一定量的余量</p>

<p>当SampleRTT值波动较大时，这个余量应该大些，否则小些</p>

<p>TimeoutInterval = EstimatedRTT + 4 * DevRTT</p>

<p>推荐的初始TimeoutInterval值为1秒，当出现超时后翻倍。</p>

<p>一个发送方可以具有的未被确认报文段的确切个数是由TCP的流量控制和拥塞机制决定的</p>

<h3 id="3-5-4-可靠数据传输">3.5.4 可靠数据传输</h3>

<p>TCP协议遵循单一计时器的推荐</p>

<p>一旦收到3个冗余ACK，TCP就执行快速重传，即在该报文段的定时器过期之间重传丢失的报文段</p>

<p>TCP的差错恢复机制也许最好被分类为GBN协议与SR协议的混合体</p>

<ul>
<li><p>超时重传</p></li>

<li><p>快速重传(因为接收方在接收到乱序分组的时候只会返回<strong>ACK为rcv_base</strong>的应答，这是由累计确认导致的)</p></li>
</ul>

<h3 id="3-5-5-流量控制">3.5.5 流量控制</h3>

<p>流量控制主要是为了解决接收缓存溢出问题，因此是一个速度匹配服务，TCP主要是让发送方维护一个接收窗口的变量来提供流量控制</p>

<p>rwnd = RecvBuffer - [LastByteRcvd - LastByteRead] 表示空闲空间</p>

<p>发送方通过将未确认的数据量控制在值rwnd内</p>

<p>TCP规范中要求：当主机B的接收方窗口为0时，主机A继续发送只有一个字节数据的报文段，这些报文段将会被接收方确认。最终缓存将开始清空，并且确认报文里将包含一个非0的rwnd值</p>

<p>UDP不提供流量控制，所以如果进程从缓存中读取报文段的速度不够快，那么缓存将会溢出，并且丢失报文段</p>

<h3 id="3-5-6-tcp连接管理">3.5.6 TCP连接管理</h3>

<p>创建一条TCP连接(三次握手)</p>

<p>对于客户端</p>

<ol>
<li><p>发送SYN</p></li>

<li><p>接收SYN&amp;ACK</p></li>

<li><p>发送ACK</p></li>
</ol>

<p>对于服务器端</p>

<ol>
<li><p>接收SYN</p></li>

<li><p>发送SYN&amp;ACK</p></li>

<li><p>接收ACK</p></li>
</ol>

<p>至于更具体的关于报文段内部的信息看图片：</p>

<p><img src="http://www.gavinblog.info/posts/image/hand-shake.jpeg" alt="三次握手" /></p>

<p>为什么两次握手不行，三次握手的目的是为了解决”网络中存在延迟的重复分组“的问题</p>

<p>关闭一条TCP连接(四次挥手)</p>

<p>对于客户端打算关闭连接</p>

<ol>
<li><p>发送特殊报文段(FIN标志位置位)</p></li>

<li><p>接收ACK</p></li>

<li><p>接收一个服务器发送来的终正报文段(FIN标志位置位)</p></li>

<li><p>发送ACK确认</p></li>
</ol>

<p>等待一会后，连接就关闭了</p>

<p>对于服务器就不赘述了</p>

<h2 id="3-6-拥塞控制原理">3.6 拥塞控制原理</h2>

<p>在面临网络拥塞时遏制发送方就是拥塞控制原理</p>

<h3 id="3-6-1-拥塞原因与代价">3.6.1 拥塞原因与代价</h3>

<h3 id="3-6-2-拥塞控制方法">3.6.2 拥塞控制方法</h3>

<p>根据网络层是否为运输层拥塞控制提供了显示帮助</p>

<ul>
<li><p>端口端拥塞控制</p></li>

<li><p>网络辅助的拥塞控制</p></li>
</ul>

<h2 id="3-7-tcp拥塞控制">3.7 TCP拥塞控制</h2>

<p>TCP必须使用端到端拥塞控制而不是使网络辅助的拥塞控制，因为IP层不向端系统提供显式的网络拥塞反馈</p>

<p>TCP拥塞控制机制跟踪一个额外的变量，即<strong>拥塞窗口</strong></p>

<p>发送方就认为在发送方到接收方的路径上出现了拥塞的指示</p>

<p>TCP拥塞控制算法：</p>

<ol>
<li><p>慢启动</p></li>

<li><p>拥塞避免</p></li>

<li><p>快速恢复</p></li>
</ol>

<h3 id="http">HTTP</h3>

<p>http的报文体常见的格式有四种
- application/json
- application/x-www-form-urlencoded (就像url传参数那样)
- application/xml
- multipart/form-data(用于文件传输或者文本)</p>

                        </div>

                        


                        

<div class="post-archive">
    <h2>See Also</h2>
    <ul class="listing">
        
        <li><a href="/posts/web-strcuture/">Web框架</a></li>
        
        <li><a href="/posts/linux/linux-note/">Linux命令笔记</a></li>
        
        <li><a href="/posts/others/learn-hugo/">Hugo建博客</a></li>
        
        <li><a href="/about/">笔者</a></li>
        
        <li><a href="/posts/git/learn-git/">Git用法总结</a></li>
        
    </ul>
</div>


                        <div class="post-meta meta-tags">
                            
                            <ul class="clearfix">
                                
                                <li><a href="https://wushaoqiang.github.io/tags/protocal">protocal</a></li>
                                
                            </ul>
                            
                        </div>
                    </article>
                    
    

    
    
    <div class="post bg-white">
      <script src="https://utteranc.es/client.js"
            repo= "wushaoqiang/blogcomment"
            issue-term="pathname"
            theme="github-light"
            crossorigin="anonymous"
            async>
      </script>
    </div>
    
                </div>
            </div>
            <div id="secondary">
    <section class="widget">
        <form id="search" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank" _lpchecked="1">
      
      <input type="text" name="q" maxlength="20" placeholder="Search">
      <input type="hidden" name="sitesearch" value="https://wushaoqiang.github.io">
      <button type="submit" class="submit icon-search"></button>
</form>
    </section>
    
    <section class="widget">
        <h3 class="widget-title">最近文章</h3>
<ul class="widget-list">
    
    <li>
        <a href="https://wushaoqiang.github.io/posts/front-end/css-flexble/" title="Css Flexble">Css Flexble</a>
    </li>
    
    <li>
        <a href="https://wushaoqiang.github.io/posts/front-end/javascript-data-structure/" title="Javascript Data Structure">Javascript Data Structure</a>
    </li>
    
    <li>
        <a href="https://wushaoqiang.github.io/posts/front-end/javascript-debugging/" title="Javascript Debugging">Javascript Debugging</a>
    </li>
    
    <li>
        <a href="https://wushaoqiang.github.io/posts/front-end/javascript-regexp/" title="Javascript Regexp">Javascript Regexp</a>
    </li>
    
    <li>
        <a href="https://wushaoqiang.github.io/posts/front-end/javascript-ES6/" title="Javascript ES6">Javascript ES6</a>
    </li>
    
    <li>
        <a href="https://wushaoqiang.github.io/posts/front-end/javascript-basic/" title="Javascript Basic">Javascript Basic</a>
    </li>
    
    <li>
        <a href="https://wushaoqiang.github.io/posts/linux/linux-bash-awk/" title="Linux Bash Awk">Linux Bash Awk</a>
    </li>
    
    <li>
        <a href="https://wushaoqiang.github.io/posts/linux/linux-bash-test/" title="Linux Bash Test">Linux Bash Test</a>
    </li>
    
    <li>
        <a href="https://wushaoqiang.github.io/posts/linux/linux-bash-basic-note/" title="Linux Bash Basic Note">Linux Bash Basic Note</a>
    </li>
    
    <li>
        <a href="https://wushaoqiang.github.io/posts/linux/linux-bash/" title="Linux Bash">Linux Bash</a>
    </li>
    
</ul>
    </section>

    

    <section class="widget">
        <h3 class="widget-title">分类</h3>
<ul class="widget-list">
    
    <li>
        <a href="https://wushaoqiang.github.io/categories/Algorithm/">Algorithm(2)</a>
    </li>
    
    <li>
        <a href="https://wushaoqiang.github.io/categories/Definition/">Definition(1)</a>
    </li>
    
    <li>
        <a href="https://wushaoqiang.github.io/categories/Favorite/">Favorite(1)</a>
    </li>
    
    <li>
        <a href="https://wushaoqiang.github.io/categories/Front-end/">Front-end(7)</a>
    </li>
    
    <li>
        <a href="https://wushaoqiang.github.io/categories/Git/">Git(2)</a>
    </li>
    
    <li>
        <a href="https://wushaoqiang.github.io/categories/Golang/">Golang(45)</a>
    </li>
    
    <li>
        <a href="https://wushaoqiang.github.io/categories/Hugo/">Hugo(1)</a>
    </li>
    
    <li>
        <a href="https://wushaoqiang.github.io/categories/Leetcode/">Leetcode(161)</a>
    </li>
    
    <li>
        <a href="https://wushaoqiang.github.io/categories/Linux/">Linux(8)</a>
    </li>
    
    <li>
        <a href="https://wushaoqiang.github.io/categories/Opinion/">Opinion(1)</a>
    </li>
    
    <li>
        <a href="https://wushaoqiang.github.io/categories/Vscode/">Vscode(1)</a>
    </li>
    
    <li>
        <a href="https://wushaoqiang.github.io/categories/protocal/">protocal(1)</a>
    </li>
    
    <li>
        <a href="https://wushaoqiang.github.io/categories/questions/">questions(1)</a>
    </li>
    
    <li>
        <a href="https://wushaoqiang.github.io/categories/%E5%AF%86%E7%A0%81%E5%AD%A6/">密码学(1)</a>
    </li>
    
    <li>
        <a href="https://wushaoqiang.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库(10)</a>
    </li>
    
    <li>
        <a href="https://wushaoqiang.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构(2)</a>
    </li>
    
    <li>
        <a href="https://wushaoqiang.github.io/categories/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/">网络基础(9)</a>
    </li>
    
    <li>
        <a href="https://wushaoqiang.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/">计算机基础(1)</a>
    </li>
    
    <li>
        <a href="https://wushaoqiang.github.io/categories/%E8%B5%84%E6%BA%90/">资源(1)</a>
    </li>
    
</ul>
    </section>

    <section class="widget">
        <h3 class="widget-title">标签</h3>
<div class="tagcloud">
    
    <a href="https://wushaoqiang.github.io/tags/Algorithm/">Algorithm</a>
    
    <a href="https://wushaoqiang.github.io/tags/Array/">Array</a>
    
    <a href="https://wushaoqiang.github.io/tags/Bash/">Bash</a>
    
    <a href="https://wushaoqiang.github.io/tags/Basic/">Basic</a>
    
    <a href="https://wushaoqiang.github.io/tags/Beego/">Beego</a>
    
    <a href="https://wushaoqiang.github.io/tags/Blog/">Blog</a>
    
    <a href="https://wushaoqiang.github.io/tags/CSS/">CSS</a>
    
    <a href="https://wushaoqiang.github.io/tags/Channel/">Channel</a>
    
    <a href="https://wushaoqiang.github.io/tags/Command/">Command</a>
    
    <a href="https://wushaoqiang.github.io/tags/Context/">Context</a>
    
    <a href="https://wushaoqiang.github.io/tags/Crawler/">Crawler</a>
    
    <a href="https://wushaoqiang.github.io/tags/DHCP/">DHCP</a>
    
    <a href="https://wushaoqiang.github.io/tags/Definition/">Definition</a>
    
    <a href="https://wushaoqiang.github.io/tags/Easy/">Easy</a>
    
    <a href="https://wushaoqiang.github.io/tags/Effective/">Effective</a>
    
    <a href="https://wushaoqiang.github.io/tags/Exercism/">Exercism</a>
    
    <a href="https://wushaoqiang.github.io/tags/Favorite/">Favorite</a>
    
    <a href="https://wushaoqiang.github.io/tags/Front-end/">Front-end</a>
    
    <a href="https://wushaoqiang.github.io/tags/GC/">GC</a>
    
    <a href="https://wushaoqiang.github.io/tags/Generic/">Generic</a>
    
    <a href="https://wushaoqiang.github.io/tags/Gin/">Gin</a>
    
    <a href="https://wushaoqiang.github.io/tags/Git/">Git</a>
    
    <a href="https://wushaoqiang.github.io/tags/Golang/">Golang</a>
    
    <a href="https://wushaoqiang.github.io/tags/Gopher/">Gopher</a>
    
    <a href="https://wushaoqiang.github.io/tags/HTML/">HTML</a>
    
    <a href="https://wushaoqiang.github.io/tags/HTTP/">HTTP</a>
    
    <a href="https://wushaoqiang.github.io/tags/Hugo/">Hugo</a>
    
    <a href="https://wushaoqiang.github.io/tags/IP/">IP</a>
    
    <a href="https://wushaoqiang.github.io/tags/Interface/">Interface</a>
    
    <a href="https://wushaoqiang.github.io/tags/Internet/">Internet</a>
    
    <a href="https://wushaoqiang.github.io/tags/JS/">JS</a>
    
    <a href="https://wushaoqiang.github.io/tags/LeetCode/">LeetCode</a>
    
    <a href="https://wushaoqiang.github.io/tags/Leetcode/">Leetcode</a>
    
    <a href="https://wushaoqiang.github.io/tags/Linux/">Linux</a>
    
    <a href="https://wushaoqiang.github.io/tags/Log/">Log</a>
    
    <a href="https://wushaoqiang.github.io/tags/Map/">Map</a>
    
    <a href="https://wushaoqiang.github.io/tags/Module/">Module</a>
    
    <a href="https://wushaoqiang.github.io/tags/Mongodb/">Mongodb</a>
    
    <a href="https://wushaoqiang.github.io/tags/NAT/">NAT</a>
    
    <a href="https://wushaoqiang.github.io/tags/NoSQL/">NoSQL</a>
    
    <a href="https://wushaoqiang.github.io/tags/Path/">Path</a>
    
    <a href="https://wushaoqiang.github.io/tags/Pipeline/">Pipeline</a>
    
    <a href="https://wushaoqiang.github.io/tags/SQL/">SQL</a>
    
    <a href="https://wushaoqiang.github.io/tags/Search/">Search</a>
    
    <a href="https://wushaoqiang.github.io/tags/Sentences/">Sentences</a>
    
    <a href="https://wushaoqiang.github.io/tags/Slice/">Slice</a>
    
    <a href="https://wushaoqiang.github.io/tags/Sort/">Sort</a>
    
    <a href="https://wushaoqiang.github.io/tags/Strings/">Strings</a>
    
    <a href="https://wushaoqiang.github.io/tags/TCP/">TCP</a>
    
    <a href="https://wushaoqiang.github.io/tags/UDP/">UDP</a>
    
    <a href="https://wushaoqiang.github.io/tags/Ubuntu/">Ubuntu</a>
    
    <a href="https://wushaoqiang.github.io/tags/Validation/">Validation</a>
    
    <a href="https://wushaoqiang.github.io/tags/Vscode/">Vscode</a>
    
    <a href="https://wushaoqiang.github.io/tags/Web/">Web</a>
    
    <a href="https://wushaoqiang.github.io/tags/easy/">easy</a>
    
    <a href="https://wushaoqiang.github.io/tags/gocode/">gocode</a>
    
    <a href="https://wushaoqiang.github.io/tags/goquery/">goquery</a>
    
    <a href="https://wushaoqiang.github.io/tags/gorm/">gorm</a>
    
    <a href="https://wushaoqiang.github.io/tags/handler/">handler</a>
    
    <a href="https://wushaoqiang.github.io/tags/make/">make</a>
    
    <a href="https://wushaoqiang.github.io/tags/mega/">mega</a>
    
    <a href="https://wushaoqiang.github.io/tags/network/">network</a>
    
    <a href="https://wushaoqiang.github.io/tags/new/">new</a>
    
    <a href="https://wushaoqiang.github.io/tags/protocal/">protocal</a>
    
    <a href="https://wushaoqiang.github.io/tags/questions/">questions</a>
    
    <a href="https://wushaoqiang.github.io/tags/viper/">viper</a>
    
    <a href="https://wushaoqiang.github.io/tags/%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5/">依赖注入</a>
    
    <a href="https://wushaoqiang.github.io/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/">内存管理</a>
    
    <a href="https://wushaoqiang.github.io/tags/%E5%8A%A0%E5%AF%86/">加密</a>
    
    <a href="https://wushaoqiang.github.io/tags/%E5%9F%BA%E7%A1%80/">基础</a>
    
    <a href="https://wushaoqiang.github.io/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/">密码学</a>
    
    <a href="https://wushaoqiang.github.io/tags/%E5%B0%8F%E6%8A%80%E5%B7%A7/">小技巧</a>
    
    <a href="https://wushaoqiang.github.io/tags/%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/">异常处理</a>
    
    <a href="https://wushaoqiang.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a>
    
    <a href="https://wushaoqiang.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a>
    
    <a href="https://wushaoqiang.github.io/tags/%E6%A0%87%E5%87%86%E5%BA%93/">标准库</a>
    
    <a href="https://wushaoqiang.github.io/tags/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%8C%85/">第三方包</a>
    
    <a href="https://wushaoqiang.github.io/tags/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/">网络协议</a>
    
    <a href="https://wushaoqiang.github.io/tags/%E7%BD%91%E7%BB%9C%E7%AE%A1%E7%90%86/">网络管理</a>
    
    <a href="https://wushaoqiang.github.io/tags/%E8%A7%82%E7%82%B9/">观点</a>
    
    <a href="https://wushaoqiang.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/">计算机基础</a>
    
    <a href="https://wushaoqiang.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/">计算机系统</a>
    
    <a href="https://wushaoqiang.github.io/tags/%E8%B5%84%E6%BA%90/">资源</a>
    
    <a href="https://wushaoqiang.github.io/tags/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/">进程管理</a>
    
    <a href="https://wushaoqiang.github.io/tags/%E9%85%8D%E7%BD%AE%E9%97%AE%E9%A2%98/">配置问题</a>
    
    <a href="https://wushaoqiang.github.io/tags/%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/">错误处理</a>
    
    <a href="https://wushaoqiang.github.io/tags/%E9%9D%A2%E8%AF%95/">面试</a>
    
</div>
    </section>

    

    <section class="widget">
        <h3 class="widget-title">其它</h3>
        <ul class="widget-list">
            <li><a href="https://wushaoqiang.github.io/index.xml">文章 RSS</a></li>
        </ul>
    </section>
</div>
        </div>
    </div>
</div>
<footer id="footer">
    <div class="container">
        &copy; 2019 <a href="https://wushaoqiang.github.io">Gavin&#39;s Blog By Gavin</a>.
        Powered by <a rel="nofollow noreferer noopener" href="https://gohugo.io" target="_blank">Hugo</a>.
        <a href="https://www.flysnow.org/" target="_blank">Theme</a> based on <a href="https://github.com/rujews/maupassant-hugo" target="_blank">maupassant</a>.
        
    </div>
</footer>


    <script type="text/javascript">
    
    (function(){
        $("pre code").parent().addClass("line-numbers")
    }())

    window.MathJax = {
        tex2jax: {
            inlineMath: [ ['$','$'] ],
            processEscapes: true
        }
    };
    </script>
    <script type="text/javascript" src="/js/prism.js" async="true"></script>
    <script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML' async></script>

<a id="rocket" href="#top"></a>
<script type="text/javascript" src="/js/totop.js?v=0.0.0" async=""></script>



<script type="text/javascript" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script>




</body>
</html>
