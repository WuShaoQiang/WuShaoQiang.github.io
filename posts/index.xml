<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on Gavin&#39;s Blog</title>
    <link>https://wushaoqiang.github.io/posts/</link>
    <description>Recent content in Posts on Gavin&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 15 May 2019 20:03:31 +0800</lastBuildDate>
    
	<atom:link href="https://wushaoqiang.github.io/posts/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Leetcode 617</title>
      <link>https://wushaoqiang.github.io/posts/leetcode/leetcode-617/</link>
      <pubDate>Wed, 15 May 2019 20:03:31 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/leetcode/leetcode-617/</guid>
      <description>题目 给定两个二叉树，想象当你将它们中的一个覆盖到另一个上时，两个二叉树的一些节点便会重叠。 你需要将他们合并为一个新的二叉树。合并的规则是如果两个节点重叠，那么将他们的值相加作为节点合并后的新值，否则不为 NULL 的节点将直接作为新二叉树的节点。 示例 1: 输入: Tree 1 Tree 2 1 2 / \ / \ 3 2 1 3 / \ \ 5 4 7 输出: 合并后的树: 3 / \ 4 5 / \ \ 5 4 7 注意: 合并必须从两个树的根节点开始。  我的解答 // 执行用时 : 44 ms, 在Merge Two Binary Trees的Go提交中击败了96.46% 的用户 // 内存消耗 : 8.6 MB, 在Merge Two Binary Trees的Go提交中击败了46.94% 的用户 // 第一个想法就是同时遍历两颗树(非递归做法) func mergeTrees(t1 *TreeNode, t2 *TreeNode) *TreeNode { if t1 == nil { return t2 } if t2 == nil { return t1 } // 都不为nil iteration(t1, t2) return t1 } func iteration(t1 *TreeNode, t2 *TreeNode) { // 如果两棵树对应节点都不为nil,直接在t1上的值改变 t1.</description>
    </item>
    
    <item>
      <title>Leetcode 606</title>
      <link>https://wushaoqiang.github.io/posts/leetcode-606/</link>
      <pubDate>Wed, 15 May 2019 10:41:21 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/leetcode-606/</guid>
      <description>题目 映射关系的空括号对。 示例 1: 输入: 二叉树: [1,2,3,4] 1 / \ 2 3 / 4 输出: &amp;quot;1(2(4))(3)&amp;quot; 解释: 原本将是“1(2(4)())(3())”， 在你省略所有不必要的空括号对之后， 它将是“1(2(4))(3)”。 示例 2: 输入: 二叉树: [1,2,3,null,4] 1 / \ 2 3 \ 4 输出: &amp;quot;1(2()(4))(3)&amp;quot; 解释: 和第一个示例相似， 除了我们不能省略第一个对括号来中断输入和输出之间的一对一映射关系。  我的解答 一个先序遍历的题目(题目都告诉你了),只是加上了一些感觉很难的括号,其实很简单,先看代码
// 执行用时 : 40 ms, 在Construct String from Binary Tree的Go提交中击败了18.52% 的用户 // 内存消耗 : 8.8 MB, 在Construct String from Binary Tree的Go提交中击败了26.67% 的用户 func tree2str(t *TreeNode) string { if t == nil{ return &amp;quot;&amp;quot; } return createStr(t) } func createStr(t *TreeNode) string { if t.</description>
    </item>
    
    <item>
      <title>Leetcode 572</title>
      <link>https://wushaoqiang.github.io/posts/leetcode-572/</link>
      <pubDate>Wed, 15 May 2019 10:41:14 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/leetcode-572/</guid>
      <description>题目 给定两个非空二叉树 s 和 t，检验 s 中是否包含和 t 具有相同结构和节点值的子树。s 的一个子树包括 s 的一个节点和这个节点的所有子孙。s 也可以看做它自身的一棵子树。 示例 1: 给定的树 s: 3 / \ 4 5 / \ 1 2 给定的树 t： 4 / \ 1 2 返回 true，因为 t 与 s 的一个子树拥有相同的结构和节点值。 示例 2: 给定的树 s： 3 / \ 4 5 / \ 1 2 / 0 给定的树 t： 4 / \ 1 2 返回 false。  我的解答 第一个实现
// 执行用时 : 40 ms, 在Subtree of Another Tree的Go提交中击败了39.</description>
    </item>
    
    <item>
      <title>Leetcode 563</title>
      <link>https://wushaoqiang.github.io/posts/leetcode-563/</link>
      <pubDate>Wed, 15 May 2019 10:41:11 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/leetcode-563/</guid>
      <description>题目 给定一个二叉树，计算整个树的坡度。 一个树的节点的坡度定义即为，该节点左子树的结点之和和右子树结点之和的差的绝对值。空结点的的坡度是0。 整个树的坡度就是其所有节点的坡度之和。 示例: 输入: 1 / \ 2 3 输出: 1 解释: 结点的坡度 2 : 0 结点的坡度 3 : 0 结点的坡度 1 : |2-3| = 1 树的坡度 : 0 + 0 + 1 = 1 注意: 任何子树的结点的和不会超过32位整数的范围。 坡度的值不会超过32位整数的范围。  我的解答 这道题和543题是基本一样的,只是将直径(与结点数值无关)转换为了与数值有关而已
func findTilt(root *TreeNode) int { var sum int findWeight(root, &amp;amp;sum) return sum } func findWeight(root *TreeNode, sum *int) int { if root == nil { return 0 } left := findWeight(root.</description>
    </item>
    
    <item>
      <title>Leetcode 543</title>
      <link>https://wushaoqiang.github.io/posts/leetcode-543/</link>
      <pubDate>Wed, 15 May 2019 10:41:09 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/leetcode-543/</guid>
      <description>题目 给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过根结点。 示例 : 给定二叉树 1 / \ 2 3 / \ 4 5 返回 3, 它的长度是路径 [4,2,1,3] 或者 [5,2,1,3]。 注意：两结点之间的路径长度是以它们之间边的数目表示。  我的解答 这里要注意了,不一定是要经过根节点才会有直径最大
第一种方法
// 执行用时 : 28 ms, 在Diameter of Binary Tree的Go提交中击败了11.54% 的用户 // 内存消耗 : 4.5 MB, 在Diameter of Binary Tree的Go提交中击败了95.83% 的用户 func diameterOfBinaryTree(root *TreeNode) int { if root == nil { return 0 } var max int iteration(root, &amp;amp;max) return max } func iteration(root *TreeNode, max *int) { if root !</description>
    </item>
    
    <item>
      <title>Leetcode 538</title>
      <link>https://wushaoqiang.github.io/posts/leetcode-538/</link>
      <pubDate>Wed, 15 May 2019 10:41:03 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/leetcode-538/</guid>
      <description>题目 给定一个二叉搜索树（Binary Search Tree），把它转换成为累加树（Greater Tree)，使得每个节点的值是原来的节点值加上所有大于它的节点值之和。 例如： 输入: 二叉搜索树: 5 / \ 2 13 输出: 转换为累加树: 18 / \ 20 13  我的解答 这个题主要在于发现它的规律,节点所有比自身大的节点到底有哪些
用树的思想去做会比较麻烦
// 执行用时 : 540 ms, 在Convert BST to Greater Tree的Go提交中击败了35.56% 的用户 // 内存消耗 : 41.9 MB, 在Convert BST to Greater Tree的Go提交中击败了100.00% 的用户 func convertBST(root *TreeNode) *TreeNode { if root == nil { return nil } orderByIn(root, nil) return root } func orderByIn(root *TreeNode, lastNode *TreeNode) { if root == nil { return } // 表明是有转折点的 // 有转折点的意思是这个节点在某个祖先节点的左子树上(所以要加上这个祖先节点) if lastNode !</description>
    </item>
    
    <item>
      <title>Leetcode 530</title>
      <link>https://wushaoqiang.github.io/posts/leetcode-530/</link>
      <pubDate>Wed, 15 May 2019 10:41:00 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/leetcode-530/</guid>
      <description>题目 给定一个所有节点为非负值的二叉搜索树，求树中任意两节点的差的绝对值的最小值。 示例 : 输入: 1 \ 3 / 2 输出: 1 解释: 最小绝对差为1，其中 2 和 1 的差的绝对值为 1（或者 2 和 3）。 注意: 树中至少有2个节点。  我的解答 这题在做的时候犯困了,把最小值看成最大值,懵了很久
// 执行用时 : 20 ms, 在Minimum Absolute Difference in BST的Go提交中击败了100.00% 的用户 // 内存消耗 : 6.4 MB, 在Minimum Absolute Difference in BST的Go提交中击败了85.71% 的用户 func getMinimumDifference(root *TreeNode) int { if root == nil { return 0 } res := make([]int, 0) orderByIn(root, &amp;amp;res) // fmt.</description>
    </item>
    
    <item>
      <title>Leetcode 501</title>
      <link>https://wushaoqiang.github.io/posts/leetcode-501/</link>
      <pubDate>Wed, 15 May 2019 10:40:57 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/leetcode-501/</guid>
      <description>题目 给定一个有相同值的二叉搜索树（BST），找出 BST 中的所有众数（出现频率最高的元素）。 假定 BST 有如下定义： 结点左子树中所含结点的值小于等于当前结点的值 结点右子树中所含结点的值大于等于当前结点的值 左子树和右子树都是二叉搜索树 例如： 给定 BST [1,null,2,2], 1 \ 2 / 2 返回[2]. 提示：如果众数超过1个，不需考虑输出顺序 进阶：你可以不使用额外的空间吗？（假设由递归产生的隐式调用栈的开销不被计算在内）  我的解答 // 执行用时 : 24 ms, 在Find Mode in Binary Search Tree的Go提交中击败了71.43% 的用户 // 内存消耗 : 6.5 MB, 在Find Mode in Binary Search Tree的Go提交中击败了23.53% 的用户 func findMode(root *TreeNode) []int { if root == nil { return nil } m := make(map[int]int) iteration(root, m) res := make(map[int][]int) max := 0 for k, v := range m { if max &amp;lt;= v { max = v res[v] = append(res[v], k) } } return res[max] } func iteration(root *TreeNode, m map[int]int) { if root !</description>
    </item>
    
    <item>
      <title>Leetcode 437</title>
      <link>https://wushaoqiang.github.io/posts/leetcode-437/</link>
      <pubDate>Wed, 15 May 2019 10:40:51 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/leetcode-437/</guid>
      <description>题目 给定一个二叉树，它的每个结点都存放着一个整数值。 找出路径和等于给定数值的路径总数。 路径不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。 二叉树不超过1000个节点，且节点数值范围是 [-1000000,1000000] 的整数。 示例： root = [10,5,-3,3,2,null,11,3,-2,null,1], sum = 8 10 / \ 5 -3 / \ \ 3 2 11 / \ \ 3 -2 1 返回 3。和等于 8 的路径有: 1. 5 -&amp;gt; 3 2. 5 -&amp;gt; 2 -&amp;gt; 1 3. -3 -&amp;gt; 11  我的解答 // 执行用时 : 20 ms, 在Path Sum III的Go提交中击败了87.72% 的用户 // 内存消耗 : 4.6 MB, 在Path Sum III的Go提交中击败了47.06% 的用户 func pathSum(root *TreeNode, sum int) int { if root == nil { return 0 } var count int iteration(root, sum, &amp;amp;count) return count } func iteration(root *TreeNode, target int, count *int) { // 每一个不为nil的节点都作为开始节点 if root !</description>
    </item>
    
    <item>
      <title>Leetcode 414</title>
      <link>https://wushaoqiang.github.io/posts/leetcode-414/</link>
      <pubDate>Wed, 15 May 2019 10:40:48 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/leetcode-414/</guid>
      <description>题目 给定一个非空数组，返回此数组中第三大的数。如果不存在，则返回数组中最大的数。要求算法时间复杂度必须是O(n)。 示例 1: 输入: [3, 2, 1] 输出: 1 解释: 第三大的数是 1. 示例 2: 输入: [1, 2] 输出: 2 解释: 第三大的数不存在, 所以返回最大的数 2 . 示例 3: 输入: [2, 2, 3, 1] 输出: 1 解释: 注意，要求返回第三大的数，是指第三大且唯一出现的数。 存在两个值为2的数，它们都排第二。  我的解答 用切片记录
// 执行用时 : 16 ms, 在Third Maximum Number的Go提交中击败了27.08% 的用户 // 内存消耗 : 4 MB, 在Third Maximum Number的Go提交中击败了23.33% 的用户 func thirdMax(nums []int) int { max := make([]int, 3) for i := 0; i &amp;lt; 3; i++ { max[i] = math.</description>
    </item>
    
    <item>
      <title>Leetcode 412</title>
      <link>https://wushaoqiang.github.io/posts/leetcode-412/</link>
      <pubDate>Wed, 15 May 2019 10:40:42 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/leetcode-412/</guid>
      <description>题目 写一个程序，输出从 1 到 n 数字的字符串表示。 1. 如果 n 是3的倍数，输出“Fizz”； 2. 如果 n 是5的倍数，输出“Buzz”； 3.如果 n 同时是3和5的倍数，输出 “FizzBuzz”。 示例： n = 15, 返回: [ &amp;quot;1&amp;quot;, &amp;quot;2&amp;quot;, &amp;quot;Fizz&amp;quot;, &amp;quot;4&amp;quot;, &amp;quot;Buzz&amp;quot;, &amp;quot;Fizz&amp;quot;, &amp;quot;7&amp;quot;, &amp;quot;8&amp;quot;, &amp;quot;Fizz&amp;quot;, &amp;quot;Buzz&amp;quot;, &amp;quot;11&amp;quot;, &amp;quot;Fizz&amp;quot;, &amp;quot;13&amp;quot;, &amp;quot;14&amp;quot;, &amp;quot;FizzBuzz&amp;quot; ]  我的解答 // 执行用时 : 160 ms, 在Fizz Buzz的Go提交中击败了99.21% 的用户 // 内存消耗 : 69.7 MB, 在Fizz Buzz的Go提交中击败了18.18% 的用户 func fizzBuzz(n int) []string { res := make([]string, n) for i := 0; i &amp;lt; n; i++ { if (i+1)%15 == 0 { res[i] = &amp;quot;FizzBuzz&amp;quot; } else if (i+1)%5 == 0 { res[i] = &amp;quot;Buzz&amp;quot; } else if (i+1)%3 == 0 { res[i] = &amp;quot;Fizz&amp;quot; } else { res[i] = strconv.</description>
    </item>
    
    <item>
      <title>Leetcode 409</title>
      <link>https://wushaoqiang.github.io/posts/leetcode-409/</link>
      <pubDate>Wed, 15 May 2019 10:40:39 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/leetcode-409/</guid>
      <description>题目 Given a string which consists of lowercase or uppercase letters, find the length of the longest palindromes that can be built with those letters. This is case sensitive, for example &amp;quot;Aa&amp;quot; is not considered a palindrome here. Note: Assume the length of given string will not exceed 1,010. Example: Input: &amp;quot;abccccdd&amp;quot; Output: 7 Explanation: One longest palindrome that can be built is &amp;quot;dccaccd&amp;quot;, whose length is 7.  我的解答 // 执行用时 : 0 ms, 在Longest Palindrome的Go提交中击败了100.</description>
    </item>
    
    <item>
      <title>Good Resource</title>
      <link>https://wushaoqiang.github.io/posts/good-resource/</link>
      <pubDate>Mon, 13 May 2019 22:54:34 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/good-resource/</guid>
      <description> 下面的笔者觉得比较好的一些资源,大多是关于Go和计算机方面的,像stackoverflow这类型知名的就不说了
数据结构 data structure visualzation
大牛博客 飞雪无情
Tony Bai
legendtkl
公众号  stormzhang
 Go语言中文网
 纯洁的微笑
 架构师之路
 Go中国
  开源书籍 Effective Go
书栈网
算法题  leetcode
 牛客网
  做简历  超级简历  </description>
    </item>
    
    <item>
      <title>Data Structure Tree</title>
      <link>https://wushaoqiang.github.io/posts/data-structure-bplus-tree/</link>
      <pubDate>Mon, 13 May 2019 21:21:24 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/data-structure-bplus-tree/</guid>
      <description>为了搞明白关于数据库的一些索引结构开的一篇数据结构-树博客
前言 这只是笔者的一些笔记和觉得不错的教学资源,分享一下
推荐一个可视化的数据结构网站
树是一个重要的数据结构,不仅要知道相关概念,建议在leetcode上刷上几十题
BST BST相信很多人都已经比较了解,不赘述了,说说会有哪些问题
BST按照不同的插入顺序会有不同的形状,在极端的条件下会变成一个线性链表,这样查找的时间复杂度就变成了O(logN)
因为查找和插入都相对比较简单,这里就不说了,说说删除的思路
 二叉树删除某个叶子节点,就直接删除就好
 二叉树删除某个中间节点(包括root节点),则需要一定的操作(建议多在上面推荐的网站上多试几次,就明白了)
  以要被删除的节点A开始,把它当做root节点(也就是把子树先看做整个树,其它部分先不管)
往左边找第一个节点B,如果左边不存在节点,直接用A的右节点去代替它
找到左边第一个节点B后,找基于这个节点的最右节点C(也就是路径是一直往右边走的,不存在往左走一段后再往右)
如果没有右边节点(一个右子树都没),则直接用刚才找到的节点B去代替它
如果有右节点C(并且已经按照规则找到最右的),那么我们将用这个结点C去替代它
如果这个结点C有左节点,那么节点C的父亲节点的右子树会指向C的左节点
完!
我相信看到这段文字心态是崩的,再建议一次,用上面的网站去得到图形化的结构
AVL 参考Youtube学习
又名(Balanced binary search tree)
解决了上面BST的问题:容易因为插入顺序问题造成一棵树倾斜(这样就无法得到该有的查询速度)
先解释一下什么叫平衡(Balanced)
一颗平衡的数满足这个条件
 无论从哪个节点开始数,它的左子树深度和右子树深度的差值的绝对值小于1  因为这个条件的限定,所以即使我们插入顺序比较极端,只要我们实现了AVL Tree,那么它就能自动帮我们平衡
这里要提醒一点
 不是说以前的不平衡树放进去就能平衡,这是要重新一个个插入才能达到这样的效果  所以说,如果以前的二叉树要转为AVL树,需要将二叉树的值重新插入一遍
这里再提醒一个点,我们所有的反转操作(rotation)都是只看三个节点
进入正题
1 \ 2 \ 3  这样的一个树就是不平衡的,因为从结点1看来,左子树的深度为0,右子树的深度为2,因此|0-2|&amp;lt;=1不成立
这种情况就是RR-imbalanced,需要做的操作叫RR-rotation(RR:Right of right)
变成
 2 / \ 1 3  再复杂一点就是这也(注意focus三个节点就好)
 6 / \ 4 7 / \ 2 5 / \ 1 3  这里我要再说明一点</description>
    </item>
    
    <item>
      <title>Gopher 2019 Testing Talk</title>
      <link>https://wushaoqiang.github.io/posts/gopher-2019/</link>
      <pubDate>Mon, 13 May 2019 09:59:56 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/gopher-2019/</guid>
      <description>go test -coverprofile cover.out go tool cover -html=cover.out -o cover.html  </description>
    </item>
    
    <item>
      <title>Mongodb Installation And Config</title>
      <link>https://wushaoqiang.github.io/posts/mongodb-installation-and-config/</link>
      <pubDate>Sat, 11 May 2019 19:39:42 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/mongodb-installation-and-config/</guid>
      <description>总结一下最近在配置MongoDB时遇到的坑吧
首先,在搜索安装教程的时候,很多文章写的是直接安装.tar包,然后解压缩来用
嗯,确实是个直接的方法,用起来也可以,只是稍微麻烦自己去设置环境而已
直接下载tar包 解压后,要将/bin添加到环境变量
然后还要自己创建一个mongod.conf,往里面配置一些东西.或者可以直接在每次开启mongod的时候加入参数(比较麻烦)
这里是我初步的一个配置文件
# mongod.conf # for documentation of all options, see: # http://docs.mongodb.org/manual/reference/configuration-options/ # Where and how to store data. storage: dbPath: /home/shelljo/mongodb/data/db journal: enabled: true # engine: # mmapv1: # wiredTiger: # where to write logging data. systemLog: destination: file logAppend: true path: /home/shelljo/mongodb/log/mongod.log # network interfaces net: port: 27017 bindIp: 0.0.0.0 # how the process runs processManagement: timeZoneInfo: /usr/share/zoneinfo security: authorization: enabled #operationProfiling: #replication: #sharding: ## Enterprise-Only Options: #auditLog: #snmp:  其实这里面还遇到一些别的坑,不太记得了,我搜索了几篇关于安装的教程都是这个样子</description>
    </item>
    
    <item>
      <title>Mongodb Role</title>
      <link>https://wushaoqiang.github.io/posts/mongodb-role/</link>
      <pubDate>Sat, 11 May 2019 19:39:35 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/mongodb-role/</guid>
      <description>参照 User Management Methods
build-in role
这篇文章主要介绍一下关于role的概念,希望读者还是以官网为主,本文为辅
简介 毫无以为,设置role是为了方便管理权限问题,保证数据库的一个安全使用(不然谁都可以删库跑路那还怎么搞)
所以这也算是一个很必要知道的东西
本文只讨论build-in role,不讨论自己设计的role
笔者会一一尝试每一个role
首先 MongoDB对普通的数据库只能添加database user and database administration的role
对admin数据库,则可以添加任何其它类型的role
Database User Role read 简单来说就是只提供对某个数据库读的权利(细节可以上官网上看具体描述)
例如db.collections.find()
我们如何添加呢,这里简单讲一下,后面的都一样
use admin //进入admin database db.createUser({user:&amp;quot;%s&amp;quot;,pwd:&amp;quot;%s&amp;quot;,roles:[{role:&amp;quot;read&amp;quot;,db:&amp;quot;%s&amp;quot;}]})  其中%s是大家自己选择的意思
readWrite 同上多了写的权限
Database Administration Roles dbAdmin 提供权限运行管理类的任务
例如schema-related tasks,indexing and gathering statistics
但是这个role不能够管理user and role management
userAdmin 提供能够在当前database修改roles和users的权利
注意:这样的一个权限代表着它是这个database的superuser,如果在admin database上设置了这种权限意味着间接提供了超级权限(可以看到集群的数据库了)
所以用这个权限的时候要小心点
dbOwner 这个就集成了readWrite,dbAdmin and userAdmin
Cluster Administration Roles 由于笔者对集群化了解还比较浅薄,这里就直接做一些简单翻译
这些administration就不像之前那样是指定某一个数据库了,这是管理整个系统的role
clusterAdmin 这是cluster的最高权限,结合了clusterManager,clusterMonitor,hostManager,additionally dropDatabase action
这是一个可以删库的权限,可见其权限很高了吧</description>
    </item>
    
    <item>
      <title>Golang Module</title>
      <link>https://wushaoqiang.github.io/posts/golang-module/</link>
      <pubDate>Fri, 10 May 2019 21:33:39 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/golang-module/</guid>
      <description>在dep还没正式登上Go的亲生包依赖管理工具位置的时候,Go Module出来了,并且Russ还建议广大Gopher用Go Module来代替go get,不知不觉go get以及存在了十年了,下一个十年应该由go module来主持了吧
不知道大家用Go Module还爽不爽,反正我一开始还挺不爽的,不过解决了不爽的问题之后就挺爽的了
不爽的地方 因为你懂的原因,某些golang.org包不能够根据依赖的版本直接下载下来,就和之前用go get一样,但是go get不行的们还能去github上clone一份
因为go module对版本有着严格的控制,因此如果我们按照同样的方法去github clone一份的话,就没有这么方便了
爽的地方 可能这个我认为好的地方,也有人认为不好,就是它把所有的package存放在了$GOPATH/pkg/mod里面了,在以前,我基本都是直接go get到src上的,所以整个src的文件夹都是库
这样一来,可以让src整洁很多吧
当然还不止一些,如果当上面关系下载包的问题被解决了,也就意味着,下载别人的代码,即使本地不存在它的依赖,也可以一键运行了?
如何解决下载问题 goproxy &amp;ndash;最简单的方法
通过他人做好的一个代理,之后对包的请求都会经过这个代理,但是无法下载私密仓库(也就是没有认证功能)
athens &amp;ndash;复杂点但全面的方法
这个是微软大力支持的一个开源项目,规模和功能什么的都比上面的多,但是现在还没有v1版本
对我来说,我更多的还是在github上下载公共仓库,所以,先用第一个吧
好,万一哪天代理不好用了,那还有一种比较难受的方法
在go.mod里面用replace替换下载的目的地
一些简单介绍 要启用module模式,需要
export GO111MODULE=on  在Go1.12版本中,不再依赖go.mod文件了(虽然是方便了,但我感觉有也不错)
如果打开了module模式,那么程序在寻找包的依赖就不再是在GOPATH/src上找了,而是在GOPATH/pkg/mod
如果想要查看一个程序的所有module依赖
go list -m -json all //以JSON格式显示会好看点  虽然Google的工程师提议使用go module,但毕竟还是要点事件,并且go get也有一些比较好用的特性,来列举一下
go get -u //get lastest go get -u=patch //首先,patch版本的不同一般是bug fixed,一般不会有其它功能的变化 go get package@v1.1.1 //得到一个package的v1.1.1版本 go get package@lastest //得到最新的tag版本,如果没有tag,就是最新commit go get package@master //得到最新commit版本  在module模式下,go get也会影响到go.</description>
    </item>
    
    <item>
      <title>Golang Mongodb</title>
      <link>https://wushaoqiang.github.io/posts/golang-mongodb/</link>
      <pubDate>Fri, 10 May 2019 21:17:02 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/golang-mongodb/</guid>
      <description>简单收集一些基本操作,作为一个笔记查找
参考官方文章
package main import ( &amp;quot;context&amp;quot; &amp;quot;fmt&amp;quot; &amp;quot;log&amp;quot; &amp;quot;go.mongodb.org/mongo-driver/bson&amp;quot; &amp;quot;go.mongodb.org/mongo-driver/mongo&amp;quot; &amp;quot;go.mongodb.org/mongo-driver/mongo/options&amp;quot; ) // You will be using this Trainer type later in the program type Trainer struct { Name string Age int City string } func main() { // Rest of the code will go here // Set client options clientOptions := options.Client().ApplyURI(&amp;quot;mongodb://localhost:27017&amp;quot;) // Connect to MongoDB client, err := mongo.Connect(context.TODO(), clientOptions) if err != nil { log.Fatal(err) } // Check the connection err = client.</description>
    </item>
    
    <item>
      <title>Mongodb Data Modeling Introduction</title>
      <link>https://wushaoqiang.github.io/posts/mongodb-data-modeling-introduction/</link>
      <pubDate>Fri, 10 May 2019 18:54:43 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/mongodb-data-modeling-introduction/</guid>
      <description>原文
Flexible Schema 不像SQL的数据库一样,Mongodb不需要我们准确定义一个数据格式的规范
也就是说,一个collection里面的document不一定要每个字段都一样,我们也可以实时的更新document的字段(增加或减少)
当然,有些时候为了让数据保持统一,Mongodb也可以让我们自定义collection的validation
Document structure  how the application represents relationships between data
 Embedded Data 这是官方推荐的一种数据结构
 For many use cases in MongoDB, the denormalized data model is optimal.
  This data model facilitates atomic operations.
 当一个写操作(insertOne or insertMany),对每一个document的修改都是atomic,但是并不是每一次改一个document
References 这种就又是关系型了
Data Use and Performance 当我们更侧重最近的数据的时候 &amp;ndash;使用capped collection
如果是侧重全局数据的读取 &amp;ndash;使用索引会增加性能
Document Growth and MMAPv1 当document size超过容量的时候,MongoDB会扩容</description>
    </item>
    
    <item>
      <title>Mongodb Schema Validation</title>
      <link>https://wushaoqiang.github.io/posts/mongodb-schema-validation/</link>
      <pubDate>Fri, 10 May 2019 16:06:32 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/mongodb-schema-validation/</guid>
      <description>Schema Validation MongoDB 提供了模式验证,就像SQL里面的结构类型检查一样
提前说一下,这些validation不能够设置在admin local config数据库,也不能设置在以system.*为名的collection
如果是还未创建的collection
 use db.createCollection() with the validator option.
 如果是已经创建了的collection
 use collMod command with the validator option.
 这里还提供了两个options
validationLevel 控制检查的程度 模式有两种:strict(default) and moderate,To disable validation entirely, you can set validationLevel to off. validationAction 当不符合规范的时候的响应动作(发出error,直接拒绝,还是warn然后接收) 模式有两种:error(default) and warn.  如果我们要具体一个JSON格式
 use the $jsonSchema operator in your validator expression.
 官网例子
db.createCollection(&amp;quot;students&amp;quot;, { validator: { $jsonSchema: { bsonType: &amp;quot;object&amp;quot;, required: [ &amp;quot;name&amp;quot;, &amp;quot;year&amp;quot;, &amp;quot;major&amp;quot;, &amp;quot;gpa&amp;quot;, &amp;quot;address.</description>
    </item>
    
    <item>
      <title>Mongodb Command</title>
      <link>https://wushaoqiang.github.io/posts/mongodb-command/</link>
      <pubDate>Fri, 10 May 2019 00:03:44 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/mongodb-command/</guid>
      <description>关于数据库和collection的操作 db.createCollection() // create a collection db.dropDatabase() // delete a db show collections // show all collections in db show dbs // show all db use db // create if not exist db.collection_name.drop() // delete a collection  插入操作 db.collection.insert({}) //insert one db.collection.insert([{},{}]) //insert many db.collection.insertMany([{},{}]) //insert many db.collection.insertOne({}) //insert one  查询操作 db.collection.find() //find all documents db.collection.find().pretty //much easier to read db.inventory.find( { status: &amp;quot;D&amp;quot; } ) // selects from the inventory collection all documents where the status equals &amp;quot;D&amp;quot; db.</description>
    </item>
    
    <item>
      <title>SQL vs NoSQL</title>
      <link>https://wushaoqiang.github.io/posts/sql-vs-nosql/</link>
      <pubDate>Thu, 09 May 2019 22:05:07 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/sql-vs-nosql/</guid>
      <description>花了点时间去了解了一下NoSQL,总结一下一些概念
SQL: Strcuture Query Language
NoSQL: Not Only SQL
一些概念 ACID 这是关系型数据库遵循的法则
A: Atomatic -all or nothing,要么全部完成,要么回滚什么都不做 C: Consistancy -一致性,系统就算是并发多个的,也必须如同串行事务一样 I: Isolation -用于竟态保护,并行安全,确保只有一个事务在使用系统 D: Durability -once executed, data is immediately saved  CAP 这是Eric Brewer说的,三个指标不可能同时做到,这就是CAP定理
Consistency 一致性 Availablility 可用性 Partition tolerance 分区容错  在分布式服务上,必须要满足P,所以只剩下了C和A选
最常见的是AP组合,一致性靠一个时间窗口达到
因为NoSQL常用在分布式系统上,所以这个概念也非常重要
SQL vs NoSQL 字段(有利有弊) SQL有固定的table字段(field),所以只能够往table里添加固定的结构数据
 优点:开发者知道要往table里面添加什么值,已经清楚table里面有什么具体的field
 缺点:随着业务需求,可能对结构会有所变化,变化麻烦
  NoSQL没有固定的collection字段,collection下面是document(一般是json),document里面的数据可以拥有不同的字段
 优点和缺点刚好和上面相反  关系(有利有弊) SQL通过table之间的关系来达到分布式数据
 优点:通过一个table将数据连接起来,没有过多的冗余数据
 缺点:对分布式不友好,并且一旦关系多了,会产生混乱
  NoSQL没有关系,全部都是直接存储</description>
    </item>
    
    <item>
      <title>Leetcode 405</title>
      <link>https://wushaoqiang.github.io/posts/leetcode-405/</link>
      <pubDate>Tue, 07 May 2019 21:25:48 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/leetcode-405/</guid>
      <description>题目  Given an integer, write an algorithm to convert it to hexadecimal. For negative integer, two’s complement method is used. Note: All letters in hexadecimal (a-f) must be in lowercase. The hexadecimal string must not contain extra leading 0s. If the number is zero, it is represented by a single zero character &#39;0&#39;; otherwise, the first character in the hexadecimal string will not be the zero character. The given number is guaranteed to fit within the range of a 32-bit signed integer.</description>
    </item>
    
    <item>
      <title>Leetcode 404</title>
      <link>https://wushaoqiang.github.io/posts/leetcode-404/</link>
      <pubDate>Tue, 07 May 2019 21:25:46 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/leetcode-404/</guid>
      <description>题目 Find the sum of all left leaves in a given binary tree. Example: 3 / \ 9 20 / \ 15 7 There are two left leaves in the binary tree, with values 9 and 15 respectively. Return 24.  我的解答 这个题参考了一下别人的思路写出来
func sumOfLeftLeaves(root *TreeNode) int { sum := 0 if root == nil { return 0 } search(root, false, &amp;amp;sum) return sum } func search(root *TreeNode, flag bool, sum *int) { if root == nil { return } if flag &amp;amp;&amp;amp; root.</description>
    </item>
    
    <item>
      <title>Leetcode 400</title>
      <link>https://wushaoqiang.github.io/posts/leetcode-400/</link>
      <pubDate>Tue, 07 May 2019 21:25:44 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/leetcode-400/</guid>
      <description>题目 Find the nth digit of the infinite integer sequence 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, ... Note: n is positive and will fit within the range of a 32-bit signed integer (n &amp;lt; 231). Example 1: Input: 3 Output: 3 Example 2: Input: 11 Output: 0 Explanation: The 11th digit of the sequence 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, .</description>
    </item>
    
    <item>
      <title>Leetcode 389</title>
      <link>https://wushaoqiang.github.io/posts/leetcode-389/</link>
      <pubDate>Tue, 07 May 2019 21:25:40 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/leetcode-389/</guid>
      <description>题目  Given two strings s and t which consist of only lowercase letters. String t is generated by random shuffling string s and then add one more letter at a random position. Find the letter that was added in t. Example: Input: s = &amp;quot;abcd&amp;quot; t = &amp;quot;abcde&amp;quot; Output: e Explanation: &#39;e&#39; is the letter that was added.  我的解答 这道题我用了三种方法
 全部统计,因为只会有一个字符是奇数,所以那个就是新增
 用t-byte的总和减去s-byte的总和
 异或,最后剩下那个增加的
  其中第三种方法最快</description>
    </item>
    
    <item>
      <title>Leetcode 387</title>
      <link>https://wushaoqiang.github.io/posts/leetcode-387/</link>
      <pubDate>Tue, 07 May 2019 21:25:34 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/leetcode-387/</guid>
      <description>题目  Given a string, find the first non-repeating character in it and return it&#39;s index. If it doesn&#39;t exist, return -1. Examples: s = &amp;quot;leetcode&amp;quot; return 0. s = &amp;quot;loveleetcode&amp;quot;, return 2. Note: You may assume the string contain only lowercase letters.  我的解答 func firstUniqChar(s string) int { m := make([]int, 26) for _, b := range s { m[b-&#39;a&#39;]++ } for idx, b := range s { if m[b-&#39;a&#39;] == 1 { return idx } } return -1 }  记录所有字符的个数,然后从头开始遍历,找到第一个count=1的索引</description>
    </item>
    
    <item>
      <title>Leetcode 383</title>
      <link>https://wushaoqiang.github.io/posts/leetcode-383/</link>
      <pubDate>Tue, 07 May 2019 21:25:30 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/leetcode-383/</guid>
      <description>题目  Given an arbitrary ransom note string and another string containing letters from all the magazines, write a function that will return true if the ransom note can be constructed from the magazines ; otherwise, it will return false. Each letter in the magazine string can only be used once in your ransom note. Note: You may assume that both strings contain only lowercase letters. canConstruct(&amp;quot;a&amp;quot;, &amp;quot;b&amp;quot;) -&amp;gt; false canConstruct(&amp;quot;aa&amp;quot;, &amp;quot;ab&amp;quot;) -&amp;gt; false canConstruct(&amp;quot;aa&amp;quot;, &amp;quot;aab&amp;quot;) -&amp;gt; true  我的解答 题目的意思是,右边的字符串能否凑成左边的字符串(每个字符只能用一次)</description>
    </item>
    
    <item>
      <title>Leetcode 371</title>
      <link>https://wushaoqiang.github.io/posts/leetcode-371/</link>
      <pubDate>Tue, 07 May 2019 21:25:19 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/leetcode-371/</guid>
      <description>题目 Calculate the sum of two integers a and b, but you are not allowed to use the operator + and -. Example 1: Input: a = 1, b = 2 Output: 3 Example 2: Input: a = -2, b = 3 Output: 1  我的解答 这个题也是考验对二进制的熟悉
我们来验算一下
以下都是二进制 a = 100 b = 111 结果应该等于 1011 add = 100^111 = 011 carry = (100&amp;amp;111)&amp;lt;&amp;lt;1 =1000 sum = add^carry  // 用&amp;amp;来得到是否有进位，并且要右移1位 // 用^来得到不考虑进位的相加 // 然后进位和不考虑进位的结果再次执行同样的操作，直到没有进位 func getSum(a int, b int) int { res := 0 for { carry := (a &amp;amp; b) &amp;lt;&amp;lt; 1 sum := a ^ b if carry&amp;amp;sum == 0 { res = carry ^ sum break } a = carry b = sum } return res }  最优解答 无</description>
    </item>
    
    <item>
      <title>Leetcode 367</title>
      <link>https://wushaoqiang.github.io/posts/leetcode-367/</link>
      <pubDate>Tue, 07 May 2019 21:25:16 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/leetcode-367/</guid>
      <description>题目 Given a positive integer num, write a function which returns True if num is a perfect square else False. Note: Do not use any built-in library function such as sqrt. Example 1: Input: 16 Output: true Example 2: Input: 14 Output: false  我的解答 根据数学公式 1+3+&amp;hellip;+(2n-1) = n**2
func isPerfectSquare(num int) bool { if num == 1 { return true } total := 0 for i := 1; i &amp;lt;= num/2 &amp;amp;&amp;amp; total &amp;lt; num; i++ { total += 2*i - 1 } return total == num }  最优解答 无</description>
    </item>
    
    <item>
      <title>Leetcode 350</title>
      <link>https://wushaoqiang.github.io/posts/leetcode-350/</link>
      <pubDate>Tue, 07 May 2019 21:25:10 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/leetcode-350/</guid>
      <description>题目 Given two arrays, write a function to compute their intersection. Example 1: Input: nums1 = [1,2,2,1], nums2 = [2,2] Output: [2,2] Example 2: Input: nums1 = [4,9,5], nums2 = [9,4,9,8,4] Output: [4,9] Note: Each element in the result should appear as many times as it shows in both arrays. The result can be in any order.  我的解答 func intersect(nums1 []int, nums2 []int) []int { res := make([]int, 0) m := make(map[int]int) for _, num1 := range nums1 { m[num1]++ } for _, num2 := range nums2 { if count, exist := m[num2]; exist &amp;amp;&amp;amp; count &amp;gt; 0 { res = append(res, num2) m[num2]-- } } return res }  和上题区别在于,这里有数量的区别,所以要稍微改动就可以了</description>
    </item>
    
    <item>
      <title>Leetcode 349</title>
      <link>https://wushaoqiang.github.io/posts/leetcode-349/</link>
      <pubDate>Tue, 07 May 2019 21:25:05 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/leetcode-349/</guid>
      <description>题目 Given two arrays, write a function to compute their intersection. Example 1: Input: nums1 = [1,2,2,1], nums2 = [2,2] Output: [2] Example 2: Input: nums1 = [4,9,5], nums2 = [9,4,9,8,4] Output: [9,4] Note: Each element in the result must be unique. The result can be in any order.  我的解答 func intersection(nums1 []int, nums2 []int) []int { res := make([]int, 0) m := make(map[int]bool) for _, num1 := range nums1 { m[num1] = true } for _, num2 := range nums2 { if use, exist := m[num2]; exist &amp;amp;&amp;amp; use { res = append(res, num2) m[num2] = false } } return res }  要注意这里只显示一次,所以要通过exist和use共同判断</description>
    </item>
    
    <item>
      <title>Leetcode 345</title>
      <link>https://wushaoqiang.github.io/posts/leetcode-345/</link>
      <pubDate>Tue, 07 May 2019 21:25:02 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/leetcode-345/</guid>
      <description>题目 Write a function that takes a string as input and reverse only the vowels of a string. Example 1: Input: &amp;quot;hello&amp;quot; Output: &amp;quot;holle&amp;quot; Example 2: Input: &amp;quot;leetcode&amp;quot; Output: &amp;quot;leotcede&amp;quot; Note: The vowels does not include the letter &amp;quot;y&amp;quot;.  我的解答 这个题目意思是,两个元音字母交换
func reverseVowels(s string) string { b := []byte(s) // m := map[byte]bool{ // &#39;a&#39;: true, // &#39;e&#39;: true, // &#39;i&#39;: true, // &#39;o&#39;: true, // &#39;u&#39;: true, // &#39;A&#39;: true, // &#39;E&#39;: true, // &#39;I&#39;: true, // &#39;O&#39;: true, // &#39;U&#39;: true, // } i := 0 j := len(b) - 1 for { for ; i &amp;lt; len(b); i++ { if isVowel(b[i]) { break } } for ; j &amp;gt;= 0; j-- { if isVowel(b[j]) { break } } if i &amp;gt;= j { break } b[i], b[j] = b[j], b[i] i++ j-- } return string(b) } func isVowel(b byte) bool { return b == &#39;a&#39; || b == &#39;e&#39; || b == &#39;i&#39; || b == &#39;o&#39; || b == &#39;u&#39; || b == &#39;A&#39; || b == &#39;E&#39; || b == &#39;I&#39; || b == &#39;O&#39; || b == &#39;U&#39; }  这个有点像快速排序那样,这里用函数好像会比较快</description>
    </item>
    
    <item>
      <title>Leetcode 344</title>
      <link>https://wushaoqiang.github.io/posts/leetcode-344/</link>
      <pubDate>Tue, 07 May 2019 21:25:00 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/leetcode-344/</guid>
      <description>题目 Write a function that reverses a string. The input string is given as an array of characters char[]. Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory. You may assume all the characters consist of printable ascii characters. Example 1: Input: [&amp;quot;h&amp;quot;,&amp;quot;e&amp;quot;,&amp;quot;l&amp;quot;,&amp;quot;l&amp;quot;,&amp;quot;o&amp;quot;] Output: [&amp;quot;o&amp;quot;,&amp;quot;l&amp;quot;,&amp;quot;l&amp;quot;,&amp;quot;e&amp;quot;,&amp;quot;h&amp;quot;] Example 2: Input: [&amp;quot;H&amp;quot;,&amp;quot;a&amp;quot;,&amp;quot;n&amp;quot;,&amp;quot;n&amp;quot;,&amp;quot;a&amp;quot;,&amp;quot;h&amp;quot;] Output: [&amp;quot;h&amp;quot;,&amp;quot;a&amp;quot;,&amp;quot;n&amp;quot;,&amp;quot;n&amp;quot;,&amp;quot;a&amp;quot;,&amp;quot;H&amp;quot;]  我的解答 这个好像就没什么难度了..
func reverseString(s []byte) { if len(s) == 0 { return } tmp := s[0] for i, j := 0, len(s)-1; i &amp;lt; j; i, j = i+1, j-1 { tmp = s[i] s[i] = s[j] s[j] = tmp } }  最优解答 无</description>
    </item>
    
    <item>
      <title>Leetcode 342</title>
      <link>https://wushaoqiang.github.io/posts/leetcode-342/</link>
      <pubDate>Tue, 07 May 2019 21:24:58 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/leetcode-342/</guid>
      <description>题目 Given an integer (signed 32 bits), write a function to check whether it is a power of 4. Example 1: Input: 16 Output: true Example 2: Input: 5 Output: false Follow up: Could you solve it without loops/recursion?  我的解答 func isPowerOfFour(num int) bool { return num &amp;gt; 0 &amp;amp;&amp;amp; 6148914691236517205&amp;amp;num == num &amp;amp;&amp;amp; num&amp;amp;(num-1) == 0 }   num要是整数
 这一串数字是64位有符号int010101.....01,因为4的倍数在二进制中是隔开的10000(16),100(4),所以这个是验证num偶数bit是否都为0
 验证了偶数bit都为0后,要验证是否只有一个位置1,其实就是验证是否是2的幂
  最优解答 无</description>
    </item>
    
    <item>
      <title>Leetcode 326</title>
      <link>https://wushaoqiang.github.io/posts/leetcode-326/</link>
      <pubDate>Tue, 07 May 2019 21:24:51 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/leetcode-326/</guid>
      <description>题目 Given an integer, write a function to determine if it is a power of three. Example 1: Input: 27 Output: true Example 2: Input: 0 Output: false Example 3: Input: 9 Output: true Example 4: Input: 45 Output: false Follow up: Could you do it without using any loop / recursion?  我的解答 一般思路,不断整除3,但题目提示了,这道题不用循环也可以做出来
func isPowerOfThree(n int) bool { return n &amp;gt; 0 &amp;amp;&amp;amp; 4052555153018976267%n == 0 }  这个一长串的数字是我通过程序计算出来的64位有符号int类型中最大的3的幂,也就是说,只要是3的幂,都肯定会被这个最大的数给整除,因此表示为余数为0</description>
    </item>
    
    <item>
      <title>Leetcode 303</title>
      <link>https://wushaoqiang.github.io/posts/leetcode-303/</link>
      <pubDate>Tue, 07 May 2019 21:24:46 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/leetcode-303/</guid>
      <description>题目 Given an integer array nums, find the sum of the elements between indices i and j (i ≤ j), inclusive. Example: Given nums = [-2, 0, 3, -5, 2, -1] sumRange(0, 2) -&amp;gt; 1 sumRange(2, 5) -&amp;gt; -1 sumRange(0, 5) -&amp;gt; -3 Note: You may assume that the array does not change. There are many calls to sumRange function.  我的解答 题目重点在于
You may assume that the array does not change.</description>
    </item>
    
    <item>
      <title>Leetcode 292</title>
      <link>https://wushaoqiang.github.io/posts/leetcode-292/</link>
      <pubDate>Tue, 07 May 2019 21:24:43 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/leetcode-292/</guid>
      <description>题目 You are playing the following Nim Game with your friend: There is a heap of stones on the table, each time one of you take turns to remove 1 to 3 stones. The one who removes the last stone will be the winner. You will take the first turn to remove the stones. Both of you are very clever and have optimal strategies for the game. Write a function to determine whether you can win the game given the number of stones in the heap.</description>
    </item>
    
    <item>
      <title>Leetcode 290</title>
      <link>https://wushaoqiang.github.io/posts/leetcode-290/</link>
      <pubDate>Tue, 07 May 2019 21:24:38 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/leetcode-290/</guid>
      <description>题目 Given a pattern and a string str, find if str follows the same pattern. Here follow means a full match, such that there is a bijection between a letter in pattern and a non-empty word in str. Example 1: Input: pattern = &amp;quot;abba&amp;quot;, str = &amp;quot;dog cat cat dog&amp;quot; Output: true Example 2: Input:pattern = &amp;quot;abba&amp;quot;, str = &amp;quot;dog cat cat fish&amp;quot; Output: false Example 3: Input: pattern = &amp;quot;aaaa&amp;quot;, str = &amp;quot;dog cat cat dog&amp;quot; Output: false Example 4: Input: pattern = &amp;quot;abba&amp;quot;, str = &amp;quot;dog dog dog dog&amp;quot; Output: false Notes: You may assume pattern contains only lowercase letters, and str contains lowercase letters that may be separated by a single space.</description>
    </item>
    
    <item>
      <title>Leetcode 283</title>
      <link>https://wushaoqiang.github.io/posts/leetcode-283/</link>
      <pubDate>Tue, 07 May 2019 21:24:35 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/leetcode-283/</guid>
      <description>题目 Given an array nums, write a function to move all 0&#39;s to the end of it while maintaining the relative order of the non-zero elements. Example: Input: [0,1,0,3,12] Output: [1,3,12,0,0] Note: You must do this in-place without making a copy of the array. Minimize the total number of operations.  我的解答 同样,暴力法也可以做,只是速度非常慢,不建议
// 将非零的直接往前移，剩下的全部写0 func moveZeroes(nums []int) { i := 0 for j := 0; j &amp;lt; len(nums); j++ { if nums[j] == 0 { continue } nums[i] = nums[j] i++ } // for ; i &amp;lt; len(nums); i++ { // nums[i] = 0 // } copy(nums[i:], make([]int, len(nums)-i)) }  因为我们只需要把非零的保留就已经不会缺失信息了,因此0是无关紧要的</description>
    </item>
    
    <item>
      <title>Leetcode 268</title>
      <link>https://wushaoqiang.github.io/posts/leetcode-268/</link>
      <pubDate>Tue, 07 May 2019 21:24:29 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/leetcode-268/</guid>
      <description>题目 Given an array containing n distinct numbers taken from 0, 1, 2, ..., n, find the one that is missing from the array. Example 1: Input: [3,0,1] Output: 2 Example 2: Input: [9,6,4,2,3,5,7,0,1] Output: 8 Note: Your algorithm should run in linear runtime complexity. Could you implement it using only constant extra space complexity?  我的解答 这个之前在一个博客上见到过,所以思路很清晰
func missingNumber(nums []int) int { total := 0 sum := 0 for i := 0; i &amp;lt; len(nums); i++ { total += i sum += nums[i] } total += len(nums) return total - sum }  直接加起来再相减,得到的数字就是缺少的数字</description>
    </item>
    
    <item>
      <title>Leetcode 263</title>
      <link>https://wushaoqiang.github.io/posts/leetcode-263/</link>
      <pubDate>Tue, 07 May 2019 21:24:26 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/leetcode-263/</guid>
      <description>题目 Write a program to check whether a given number is an ugly number. Ugly numbers are positive numbers whose prime factors only include 2, 3, 5. Example 1: Input: 6 Output: true Explanation: 6 = 2 × 3 Example 2: Input: 8 Output: true Explanation: 8 = 2 × 2 × 2 Example 3: Input: 14 Output: false Explanation: 14 is not ugly since it includes another prime factor 7.</description>
    </item>
    
    <item>
      <title>Leetcode 258</title>
      <link>https://wushaoqiang.github.io/posts/leetcode-258/</link>
      <pubDate>Tue, 07 May 2019 21:24:18 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/leetcode-258/</guid>
      <description>题目 Given a non-negative integer num, repeatedly add all its digits until the result has only one digit. Example: Input: 38 Output: 2 Explanation: The process is like: 3 + 8 = 11, 1 + 1 = 2. Since 2 has only one digit, return it. Follow up: Could you do it without any loop/recursion in O(1) runtime?  我的解答 这道题一开始我是用迭代去写的,运行效率太低,但是思路比较简单,读者可以自己尝试实现
这里主要讲一下另一种快速的实现
func addDigits(num int) int { if num &amp;lt;= 9 { return num } if num%9 == 0 { return 9 } return num % 9 }  理论依据是 f(10*x+y) = f(9x+x+y) ?</description>
    </item>
    
    <item>
      <title>Leetcode 257</title>
      <link>https://wushaoqiang.github.io/posts/leetcode-257/</link>
      <pubDate>Tue, 07 May 2019 21:24:06 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/leetcode-257/</guid>
      <description>题目 Given a binary tree, return all root-to-leaf paths. Note: A leaf is a node with no children. Example: Input: 1 / \ 2 3 \ 5 Output: [&amp;quot;1-&amp;gt;2-&amp;gt;5&amp;quot;, &amp;quot;1-&amp;gt;3&amp;quot;] Explanation: All root-to-leaf paths are: 1-&amp;gt;2-&amp;gt;5, 1-&amp;gt;3  我的解答 /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func binaryTreePaths(root *TreeNode) []string { if root == nil { return nil } res := make([]string, 0) findPaths(root, &amp;quot;&amp;quot;, &amp;amp;res) return res } func findPaths(root *TreeNode, str string, result *[]string) { if root.</description>
    </item>
    
    <item>
      <title>Ubuntu apt</title>
      <link>https://wushaoqiang.github.io/posts/linux-apt/</link>
      <pubDate>Tue, 07 May 2019 11:00:18 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/linux-apt/</guid>
      <description> 这个总结一下我经常用到的关于apt的命令
apt vs apt-get 这个问题其实也在一开始困扰了我很久，网上有人使用apt，有人使用apt-get，那到底用哪个？
其实apt的后来推出的版本，越来越多人已经被它对人阅读的友好给征服了，apt-get输出的信息给人看起来比较不友好
因此对于新入门的来说，建议使用apt
当然，apt-get并没有被遗弃，也有很多人在用
常用命令 更新仓库 sudo apt update 更新本地可更新的 sudo apt upgrade 一键更新 sudo apt update &amp;amp;&amp;amp; sudo apt upgrade -y 安装，如果pkg本身就已经安装，这个就是更新操作了 sudo apt install &amp;lt;pkg&amp;gt; 如果安装的包存在，不要更新，如果不存在，就安装 sudo apt install &amp;lt;pkg&amp;gt; --no-upgrade 如果包存在就更新，不存在也不安装 sudo apt install &amp;lt;pkg&amp;gt; --only-upgrade 指定版本安装 sudo apt install &amp;lt;pkg&amp;gt;=&amp;lt;version&amp;gt; 删除(不包括配置文件) sudo apt remove &amp;lt;pkg&amp;gt; 彻底删除(包括配置文件) sudo apt purge &amp;lt;pkg&amp;gt; 显示出这个term所有的package apt search &amp;lt;term&amp;gt; 这个可以显示pkg详细信息 apt show &amp;lt;pkg&amp;gt; 显示已安装的pkg apt list --installed 自动清除(清除那些没有用的pkg) sudo apt autoremove  </description>
    </item>
    
    <item>
      <title>Golang Sync Map</title>
      <link>https://wushaoqiang.github.io/posts/golang-sync-map/</link>
      <pubDate>Mon, 06 May 2019 18:32:49 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/golang-sync-map/</guid>
      <description>Sync.Map简介 Sync.Map就像是map[interface{}]interface{}，只是省去了开发人员关于map在并发时的安全调度设计
用空间换时间
Map的线程问题 今天被问到
golang的map是线程安全的吗，我呆了一下，觉得它不是(没有仔细验证过)，其实答案也确实
map不是线程安全的
如果有两个goroutine，一个向map写，一个向map读，会发生panic
所以在这里讨论一下有关map和它的线程安全问题
在Go1.9的时候，官方推出了sync.map
Youtu
在这说一下，不是所有情况sync.Map都是好用的，官方建议大多数情况下还是用Go的原生map，需要了解其底层以及开发的业务需求和它本身的特性(在某些情况下比较好用,后面提)
推出这个的原因 在我们多线程的应用里，访问同一个map需要加锁，这样导致的结果是
 本应该是并行的程序(假设几个内核在运行这个进程)，因为加锁问题，它们只能排队运行。这造成的就是时间复杂度从O(1)-&amp;gt;O(N)  这个sync.map实际上是拥有两个map，一个是read-only,一个是read-write
我们参照官方文档来进行一个初步了解
适用场景  当我们的map只需要写入一次，然后会被多次读取的时候
 当有多个goroutine读，写，覆盖的操作
  在这两种情况下，sync.Map相对于普通map加Mutex(只是一个比喻，在实现上有很大的区别)
方法 func (m *Map) Delete(key interface{}) func (m *Map) Load(key interface{}) (value interface{}, ok bool) func (m *Map) LoadOrStore(key, value interface{}) (actual interface{}, loaded bool) func (m *Map) Range(f func(key, value interface{}) bool) func (m *Map) Store(key, value interface{})  最基本的一些存取删除等操作已经实现
剖析 关于结构方面 type Map struct { mu Mutex // read contains the portion of the map&#39;s contents that are safe for // concurrent access (with or without mu held).</description>
    </item>
    
    <item>
      <title>Algorithm 二分查找</title>
      <link>https://wushaoqiang.github.io/posts/algorithm-binarysearch/</link>
      <pubDate>Sun, 05 May 2019 18:24:12 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/algorithm-binarysearch/</guid>
      <description> 递归式 func binarySearch(arr []int,left,right,target int) int{ if left &amp;lt;= right { mid := (left + right)/2 if arr[mid] == target{ return mid } if arr[mid] &amp;gt; target{ return binarySearch(arr,left,mid-1,target) } if arr[mid] &amp;lt; target{ return binarySearch(arr,mid+1,right,target) } } return -1 }  非递归式 func binarySearch(arr []int,target int) int{ left := 0 right := len(arr)-1 for left &amp;lt;= right{ mid := (left+right)/2 if arr[mid] == target{ return mid } if arr[mid] &amp;gt; target { right = mid-1 }else{ left = mid+1 } } return -1 }  </description>
    </item>
    
    <item>
      <title>Golang Slice底层</title>
      <link>https://wushaoqiang.github.io/posts/golang-slice/</link>
      <pubDate>Sun, 05 May 2019 11:36:45 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/golang-slice/</guid>
      <description>参考 golang blog
之前一直对slice有一定的误解
误解  以为是引用传递
 以为子函数改变切片，主函数会跟着变
 以为扩容只是简单的内存扩大
  开始 我们可以把byte的slice比喻成
type sliceHeader struct { Length int Capacity int ZerothElement *byte }   slice的传递是值传递，类似一个结构体的传递  这意味着，我们把一个slice传入到函数里，在主函数上的slice可能是不变的
为什么说可能，我们来看一下情况
值传递 发生扩容 这种情况下，切片所指向的数组发生变化，因此和原来的那块内存失去了联系
长度发生改变 在子函数里面，切片长度发生改变并不会影响主函数切片的长度(值传递)
同理容量也是
唯一造成影响 所以唯一能够在子函数里面影响主函数切片的方法只有一种
就是指向的数据数组，子函数修改了相同内存空间的数组，主函数切片也会跟着改变(只有不扩容的情况下才会维持同一个数组内存地址)
小结 不要认为切片是引用传递(很多博客为了方便解释会这样说)，它们唯一能够达到这个效果的情况是共用同一个数组，只要对切片底层认识够深就不会被这个困惑
记住切片是值传递
切片指针传递 我们也可以传递一个切片的指针，这个时候类似于传入一个指向结构体的指针
注意指针
这个指针并不是说数组数据的指针，而是指向这个切片结构体的指针
这个时候和上面的值传递就有很大的不同了
长度、容量、数组指针发生改变 因为是指针传递，改变这个切片的任何东西都会影响到主函数的切片，因此无论是长度发生改变、扩容导致容量发生改变、扩容导致数组指针发生改变，主函数的切片都能看见这些改变
 切片在扩容的时候，指针会发生改变(以前的数据会复制到新的内存上，新的内存能够存储更多数据)
 在容量大于长度的时候，不会进行扩容
  小结 对切片进行指针传递才是真正的引用传递，所有的改变都不会产生新的切片变量
用途 一般来说我们都会选择使用值传递，我们只要看什么时候需要用指针传递
 当你不清除一个切片到程序最后有多少个元素(也就是无法提前估计容量)，但是你又需要把所有结果放入这个切片，这个时候要用指针传递(这里说的是传入给函数参数)  为什么呢？
由于切片扩容的时候，改变了数据的指向。值传递切片不会因为子函数改变了指向而改变指向(事实上我们需要改变指向)
给个例子吧
这是一个二叉树所有根节点到叶子节点路径的程序
type TreeNode struct { Val int Left *TreeNode Right *TreeNode } func binaryTreePaths(root *TreeNode) []string { if root == nil { return nil } res := make([]string, 0) findPaths(root, &amp;quot;&amp;quot;, &amp;amp;res) return res } func findPaths(root *TreeNode, str string, result *[]string) { if root.</description>
    </item>
    
    <item>
      <title>Leetcode 242</title>
      <link>https://wushaoqiang.github.io/posts/leetcode-242/</link>
      <pubDate>Sat, 04 May 2019 20:58:20 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/leetcode-242/</guid>
      <description>题目 Given two strings s and t , write a function to determine if t is an anagram of s. Example 1: Input: s = &amp;quot;anagram&amp;quot;, t = &amp;quot;nagaram&amp;quot; Output: true Example 2: Input: s = &amp;quot;rat&amp;quot;, t = &amp;quot;car&amp;quot; Output: false Note: You may assume the string contains only lowercase alphabets. Follow up: What if the inputs contain unicode characters? How would you adapt your solution to such case?</description>
    </item>
    
    <item>
      <title>Leetcode 237</title>
      <link>https://wushaoqiang.github.io/posts/leetcode-237/</link>
      <pubDate>Sat, 04 May 2019 20:58:13 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/leetcode-237/</guid>
      <description>题目 Write a function to delete a node (except the tail) in a singly linked list, given only access to that node. Given linked list -- head = [4,5,1,9], which looks like following: Example 1: Input: head = [4,5,1,9], node = 5 Output: [4,1,9] Explanation: You are given the second node with value 5, the linked list should become 4 -&amp;gt; 1 -&amp;gt; 9 after calling your function. Example 2: Input: head = [4,5,1,9], node = 1 Output: [4,5,9] Explanation: You are given the third node with value 1, the linked list should become 4 -&amp;gt; 5 -&amp;gt; 9 after calling your function.</description>
    </item>
    
    <item>
      <title>Leetcode 235</title>
      <link>https://wushaoqiang.github.io/posts/leetcode-235/</link>
      <pubDate>Sat, 04 May 2019 20:58:10 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/leetcode-235/</guid>
      <description>题目 Given a binary search tree (BST), find the lowest common ancestor (LCA) of two given nodes in the BST. According to the definition of LCA on Wikipedia: “The lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q as descendants (where we allow a node to be a descendant of itself).” Given binary search tree: root = [6,2,8,0,4,7,9,null,null,3,5] Example 1: Input: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8 Output: 6 Explanation: The LCA of nodes 2 and 8 is 6.</description>
    </item>
    
    <item>
      <title>Leetcode 234</title>
      <link>https://wushaoqiang.github.io/posts/leetcode-234/</link>
      <pubDate>Sat, 04 May 2019 20:58:07 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/leetcode-234/</guid>
      <description>题目 Given a singly linked list, determine if it is a palindrome. Example 1: Input: 1-&amp;gt;2 Output: false Example 2: Input: 1-&amp;gt;2-&amp;gt;2-&amp;gt;1 Output: true Follow up: Could you do it in O(n) time and O(1) space?  我的解答 如果不限定空间复杂度
func isPalindrome(head *ListNode) bool { v := make([]int, 0) for head != nil { v = append(v, head.Val) head = head.Next } l := len(v) for i := 0; i &amp;lt; l/2; i++ { if v[i] !</description>
    </item>
    
    <item>
      <title>Leetcode 231</title>
      <link>https://wushaoqiang.github.io/posts/leetcode-231/</link>
      <pubDate>Sat, 04 May 2019 20:58:03 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/leetcode-231/</guid>
      <description>题目 Given an integer, write a function to determine if it is a power of two. Example 1: Input: 1 Output: true Explanation: 20 = 1 Example 2: Input: 16 Output: true Explanation: 24 = 16 Example 3: Input: 218 Output: false  我的解答 func isPowerOfTwo(n int) bool { if n == 0 { return false } return (n &amp;amp; (n - 1)) == 0 }  这其实算是一道智力题，判断这个数是否是2的次方
最优解答 无</description>
    </item>
    
    <item>
      <title>Leetcode 226</title>
      <link>https://wushaoqiang.github.io/posts/leetcode-226/</link>
      <pubDate>Sat, 04 May 2019 20:57:59 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/leetcode-226/</guid>
      <description>题目 Invert a binary tree. Example: Input: 4 / \ 2 7 / \ / \ 1 3 6 9 Output: 4 / \ 7 2 / \ / \ 9 6 3 1 Trivia: This problem was inspired by this original tweet by Max Howell: Google: 90% of our engineers use the software you wrote (Homebrew), but you can’t invert a binary tree on a whiteboard so f*** off.</description>
    </item>
    
    <item>
      <title>Leetcode 219</title>
      <link>https://wushaoqiang.github.io/posts/leetcode-219/</link>
      <pubDate>Sat, 04 May 2019 20:57:54 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/leetcode-219/</guid>
      <description>题目 Given an array of integers and an integer k, find out whether there are two distinct indices i and j in the array such that nums[i] = nums[j] and the absolute difference between i and j is at most k. Example 1: Input: nums = [1,2,3,1], k = 3 Output: true Example 2: Input: nums = [1,0,1,1], k = 1 Output: true Example 3: Input: nums = [1,2,3,1,2,3], k = 2 Output: false  我的解答 这个题目可以用暴力法做，只是速度究极慢</description>
    </item>
    
    <item>
      <title>Leetcode 217</title>
      <link>https://wushaoqiang.github.io/posts/leetcode-217/</link>
      <pubDate>Sat, 04 May 2019 20:57:49 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/leetcode-217/</guid>
      <description>题目 Given an array of integers, find if the array contains any duplicates. Your function should return true if any value appears at least twice in the array, and it should return false if every element is distinct. Example 1: Input: [1,2,3,1] Output: true Example 2: Input: [1,2,3,4] Output: false Example 3: Input: [1,1,1,3,3,4,3,2,4,2] Output: true  我的解答 func containsDuplicate(nums []int) bool { isExist := make(map[int]bool,len(nums)) for _, num := range nums { if _, exist := isExist[num]; exist { return true } isExist[num] = true } return false }  这题比较简单，唯一要注意的点是，提前分配好空间，会有速度提升</description>
    </item>
    
    <item>
      <title>Leetcode 206</title>
      <link>https://wushaoqiang.github.io/posts/leetcode-206/</link>
      <pubDate>Sat, 04 May 2019 20:57:43 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/leetcode-206/</guid>
      <description>题目 Reverse a singly linked list. Example: Input: 1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;5-&amp;gt;NULL Output: 5-&amp;gt;4-&amp;gt;3-&amp;gt;2-&amp;gt;1-&amp;gt;NULL Follow up: A linked list can be reversed either iteratively or recursively. Could you implement both?  我的解答 覆盖了迭代和递归的解法
func reverseList(head *ListNode) *ListNode { if head == nil { return nil } // curr := head // return reverse(nil, curr) return reverse(head) } // func reverse(parent, curr *ListNode) *ListNode { // if curr.Next == nil { // curr.Next = parent // return curr // } // result := reverse(curr, curr.</description>
    </item>
    
    <item>
      <title>Leetcode 205</title>
      <link>https://wushaoqiang.github.io/posts/leetcode-205/</link>
      <pubDate>Sat, 04 May 2019 20:57:39 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/leetcode-205/</guid>
      <description>题目 Given two strings s and t, determine if they are isomorphic. Two strings are isomorphic if the characters in s can be replaced to get t. All occurrences of a character must be replaced with another character while preserving the order of characters. No two characters may map to the same character but a character may map to itself. Example 1: Input: s = &amp;quot;egg&amp;quot;, t = &amp;quot;add&amp;quot; Output: true Example 2: Input: s = &amp;quot;foo&amp;quot;, t = &amp;quot;bar&amp;quot; Output: false Example 3: Input: s = &amp;quot;paper&amp;quot;, t = &amp;quot;title&amp;quot; Output: true  我的解答 func isIsomorphic(s string, t string) bool { beUsed := make(map[byte]bool) letterMap := make(map[byte]byte) for i := 0; i &amp;lt; len(s); i++ { if b, exist := letterMap[s[i]]; !</description>
    </item>
    
    <item>
      <title>Leetcode 204</title>
      <link>https://wushaoqiang.github.io/posts/leetcode-204/</link>
      <pubDate>Sat, 04 May 2019 20:57:35 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/leetcode-204/</guid>
      <description>题目 Count the number of prime numbers less than a non-negative number, n. Example: Input: 10 Output: 4 Explanation: There are 4 prime numbers less than 10, they are 2, 3, 5, 7.  我的解答 这题跟着评论区的思路做出来的&amp;ndash;厄拉多塞筛法
func countPrimes(n int) int { // 简单判断 if n &amp;lt; 3 { return 0 } // 标志哪些0～n-1已经被访问过 flag := make([]bool, n) //因为0,1不是素数，先减去 total := n - 2 // 只需要找n的根号前的素数 for i := 2; i*i &amp;lt; n; i++ { // 访问过 if flag[i] { continue } // 没访问过，这个素数i的所有倍数(在n内)都不是素数，去除 for j := 2; i*j &amp;lt; n; j++ { if !</description>
    </item>
    
    <item>
      <title>Leetcode 203</title>
      <link>https://wushaoqiang.github.io/posts/leetcode-203/</link>
      <pubDate>Sat, 04 May 2019 20:57:33 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/leetcode-203/</guid>
      <description>题目 Remove all elements from a linked list of integers that have value val. Example: Input: 1-&amp;gt;2-&amp;gt;6-&amp;gt;3-&amp;gt;4-&amp;gt;5-&amp;gt;6, val = 6 Output: 1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;5  我的解答 func removeElements(head *ListNode, val int) *ListNode { for head != nil &amp;amp;&amp;amp; head.Val == val { head = head.Next } if head == nil { return head } tmp := head for tmp.Next != nil { if tmp.Next.Val == val { tmp.Next = tmp.Next.Next } else { tmp = tmp.</description>
    </item>
    
    <item>
      <title>Leetcode 202</title>
      <link>https://wushaoqiang.github.io/posts/leetcode-202/</link>
      <pubDate>Sat, 04 May 2019 20:57:29 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/leetcode-202/</guid>
      <description>题目 Write an algorithm to determine if a number is &amp;quot;happy&amp;quot;. A happy number is a number defined by the following process: Starting with any positive integer, replace the number by the sum of the squares of its digits, and repeat the process until the number equals 1 (where it will stay), or it loops endlessly in a cycle which does not include 1. Those numbers for which this process ends in 1 are happy numbers.</description>
    </item>
    
    <item>
      <title>Leetcode 198</title>
      <link>https://wushaoqiang.github.io/posts/leetcode-198/</link>
      <pubDate>Tue, 30 Apr 2019 22:38:42 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/leetcode-198/</guid>
      <description>题目 You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security system connected and it will automatically contact the police if two adjacent houses were broken into on the same night. Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police.</description>
    </item>
    
    <item>
      <title>Leetcode 191</title>
      <link>https://wushaoqiang.github.io/posts/leetcode-191/</link>
      <pubDate>Tue, 30 Apr 2019 22:38:39 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/leetcode-191/</guid>
      <description>题目 Example 1: Input: 00000000000000000000000000001011 Output: 3 Explanation: The input binary string 00000000000000000000000000001011 has a total of three &#39;1&#39; bits. Example 2: Input: 00000000000000000000000010000000 Output: 1 Explanation: The input binary string 00000000000000000000000010000000 has a total of one &#39;1&#39; bit. Example 3: Input: 11111111111111111111111111111101 Output: 31 Explanation: The input binary string 11111111111111111111111111111101 has a total of thirty one &#39;1&#39; bits. Note: Note that in some languages such as Java, there is no unsigned integer type.</description>
    </item>
    
    <item>
      <title>Leetcode 190</title>
      <link>https://wushaoqiang.github.io/posts/leetcode-190/</link>
      <pubDate>Tue, 30 Apr 2019 22:38:37 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/leetcode-190/</guid>
      <description>题目 Reverse bits of a given 32 bits unsigned integer. Example 1: Input: 00000010100101000001111010011100 Output: 00111001011110000010100101000000 Explanation: The input binary string 00000010100101000001111010011100 represents the unsigned integer 43261596, so return 964176192 which its binary representation is 00111001011110000010100101000000. Example 2: Input: 11111111111111111111111111111101 Output: 10111111111111111111111111111111 Explanation: The input binary string 11111111111111111111111111111101 represents the unsigned integer 4294967293, so return 3221225471 which its binary representation is 10101111110010110010011101101001. Note: Note that in some languages such as Java, there is no unsigned integer type.</description>
    </item>
    
    <item>
      <title>Leetcode 189</title>
      <link>https://wushaoqiang.github.io/posts/leetcode-189/</link>
      <pubDate>Tue, 30 Apr 2019 22:38:28 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/leetcode-189/</guid>
      <description>题目 Given an array, rotate the array to the right by k steps, where k is non-negative. Example 1: Input: [1,2,3,4,5,6,7] and k = 3 Output: [5,6,7,1,2,3,4] Explanation: rotate 1 steps to the right: [7,1,2,3,4,5,6] rotate 2 steps to the right: [6,7,1,2,3,4,5] rotate 3 steps to the right: [5,6,7,1,2,3,4] Example 2: Input: [-1,-100,3,99] and k = 2 Output: [3,99,-1,-100] Explanation: rotate 1 steps to the right: [99,-1,-100,3] rotate 2 steps to the right: [3,99,-1,-100] Note: Try to come up as many solutions as you can, there are at least 3 different ways to solve this problem.</description>
    </item>
    
    <item>
      <title>Leetcode 172</title>
      <link>https://wushaoqiang.github.io/posts/leetcode-172/</link>
      <pubDate>Tue, 30 Apr 2019 22:38:25 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/leetcode-172/</guid>
      <description>题目 Given an integer n, return the number of trailing zeroes in n!. Example 1: Input: 3 Output: 0 Explanation: 3! = 6, no trailing zero. Example 2: Input: 5 Output: 1 Explanation: 5! = 120, one trailing zero. Note: Your solution should be in logarithmic time complexity.  我的解答 看了些提示才做出来
func trailingZeroes(n int) int { count := 0 tmp := 1 len := 0 for n/(tmp*5) &amp;gt; 0 { len++ tmp = tmp * 5 } for i := 0; i &amp;lt; len; i++ { count += (n / tmp) tmp = tmp / 5 } return count }  最优解答 无</description>
    </item>
    
    <item>
      <title>Leetcode 171</title>
      <link>https://wushaoqiang.github.io/posts/leetcode-171/</link>
      <pubDate>Tue, 30 Apr 2019 22:38:08 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/leetcode-171/</guid>
      <description>题目 Given a column title as appear in an Excel sheet, return its corresponding column number. For example: A -&amp;gt; 1 B -&amp;gt; 2 C -&amp;gt; 3 ... Z -&amp;gt; 26 AA -&amp;gt; 27 AB -&amp;gt; 28 ... Example 1: Input: &amp;quot;A&amp;quot; Output: 1 Example 2: Input: &amp;quot;AB&amp;quot; Output: 28 Example 3: Input: &amp;quot;ZY&amp;quot; Output: 701  我的解答 func titleToNumber(s string) int { result := 0 tmp := 1 for i := len(s) - 1; i &amp;gt;= 0; i-- { num := int(s[i] - 64) result += (num * tmp) tmp = tmp * 26 } return result }  最优解答 无</description>
    </item>
    
    <item>
      <title>计算机系统</title>
      <link>https://wushaoqiang.github.io/posts/computer-system/</link>
      <pubDate>Tue, 30 Apr 2019 21:34:14 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/computer-system/</guid>
      <description>最近复习了一遍计算机网络、数据结构等书，过了快一个星期了，可以开始看看《深入理解计算机系统》了，很多人不推荐一开始就啃这本书，吸收会比较慢，可以先看一些公开课
这里推荐B站的公开课
配套课件
第二章 溢出 整数注意溢出，浮点数注意大数吃小数(虽然也要注意溢出，但是大数吃小数情况更加容易出现)
大数吃小数的例子
func main() { a := 1000000000000000.0 b := a c := 0.001 fmt.Println((a - b) + c) //不会吃 fmt.Println(a - (b + c)) //会吃 }  性能与底层bit 二维数组，一行一行扫描比一列列扫描性能要好
无符号和有符号的数字需要小心分析它底层的bit，举例子
无符号：1 1 1 1 --&amp;gt; 2^3+2^2+2^1+2^0 = 15 有符号：1 1 1 1 --&amp;gt; -2^3+2^2+2^1+2^0 = -1  ###大小端
大端法：最高有效字节在最前面的方式
比如0x01234567,在内存的表示是
01 23 45 67  小端法：最低有效字节在最前面的方式
比如0x01234567,在内存的表示是
67 45 23 01  一般操作系统用的都是小端法</description>
    </item>
    
    <item>
      <title>Leetcode 169</title>
      <link>https://wushaoqiang.github.io/posts/leetcode-169/</link>
      <pubDate>Mon, 29 Apr 2019 22:27:15 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/leetcode-169/</guid>
      <description>题目 Given an array of size n, find the majority element. The majority element is the element that appears more than ⌊ n/2 ⌋ times. You may assume that the array is non-empty and the majority element always exist in the array. Example 1: Input: [3,2,3] Output: 3 Example 2: Input: [2,2,1,1,1,2,2] Output: 2  我的解答 func majorityElement(nums []int) int { insertSort(nums) return nums[len(nums)/2] } func insertSort(nums []int) { for i := 1; i &amp;lt; len(nums); i++ { tmp := nums[i] j := i - 1 for ; j &amp;gt;= 0 &amp;amp;&amp;amp; tmp &amp;lt; nums[j]; j-- { nums[j+1] = nums[j] } nums[j+1] = tmp } }  最优解答 func majorityElement(nums []int) int { if len(nums) &amp;lt; 1 { return 0 } count, flag := 1, nums[0] for i := 1; i &amp;lt; len(nums); i++ { if count &amp;lt; 1 { count = 1 flag = nums[i] continue } if flag == nums[i] { count++ } else { count-- } } return flag }  难疑点&amp;amp;核心 因题目特殊性，题目规定众数要超过数量的一半</description>
    </item>
    
    <item>
      <title>Leetcode 168</title>
      <link>https://wushaoqiang.github.io/posts/leetcode-168/</link>
      <pubDate>Mon, 29 Apr 2019 22:27:11 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/leetcode-168/</guid>
      <description>题目 Given a positive integer, return its corresponding column title as appear in an Excel sheet. For example: 1 -&amp;gt; A 2 -&amp;gt; B 3 -&amp;gt; C ... 26 -&amp;gt; Z 27 -&amp;gt; AA 28 -&amp;gt; AB ... Example 1: Input: 1 Output: &amp;quot;A&amp;quot; Example 2: Input: 28 Output: &amp;quot;AB&amp;quot; Example 3: Input: 701 Output: &amp;quot;ZY&amp;quot;  我的解答 func convertToTitle(n int) string { if n &amp;lt;= 0 { return &amp;quot;&amp;quot; } len := 0 tmp := n for tmp/26 &amp;gt; 0 { len++ tmp = tmp / 26 } strs := make([]string, len+1) for n &amp;gt; 0 { n-- strs[len] = string((n % 26) + &#39;A&#39;) n = n / 26 len-- } return strings.</description>
    </item>
    
    <item>
      <title>Leetcode 167</title>
      <link>https://wushaoqiang.github.io/posts/leetcode-167/</link>
      <pubDate>Mon, 29 Apr 2019 22:27:05 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/leetcode-167/</guid>
      <description>题目 Given an array of integers that is already sorted in ascending order, find two numbers such that they add up to a specific target number. The function twoSum should return indices of the two numbers such that they add up to the target, where index1 must be less than index2. Note: Your returned answers (both index1 and index2) are not zero-based. You may assume that each input would have exactly one solution and you may not use the same element twice.</description>
    </item>
    
    <item>
      <title>Leetcode 160</title>
      <link>https://wushaoqiang.github.io/posts/leetcode-160/</link>
      <pubDate>Mon, 29 Apr 2019 22:26:55 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/leetcode-160/</guid>
      <description>题目 Write a program to find the node at which the intersection of two singly linked lists begins. For example, the following two linked lists: begin to intersect at node c1. Example 1: Input: intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3 Output: Reference of the node with value = 8 Input Explanation: The intersected node&#39;s value is 8 (note that this must not be 0 if the two lists intersect).</description>
    </item>
    
    <item>
      <title>Leetcode 155</title>
      <link>https://wushaoqiang.github.io/posts/leetcode-155/</link>
      <pubDate>Mon, 29 Apr 2019 22:26:50 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/leetcode-155/</guid>
      <description>题目  Design a stack that supports push, pop, top, and retrieving the minimum element in constant time. push(x) -- Push element x onto stack. pop() -- Removes the element on top of the stack. top() -- Get the top element. getMin() -- Retrieve the minimum element in the stack. Example: MinStack minStack = new MinStack(); minStack.push(-2); minStack.push(0); minStack.push(-3); minStack.getMin(); --&amp;gt; Returns -3. minStack.pop(); minStack.top(); --&amp;gt; Returns 0. minStack.getMin(); --&amp;gt; Returns -2.</description>
    </item>
    
    <item>
      <title>Leetcode 141</title>
      <link>https://wushaoqiang.github.io/posts/leetcode-141/</link>
      <pubDate>Mon, 29 Apr 2019 22:26:44 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/leetcode-141/</guid>
      <description>题目 Given a linked list, determine if it has a cycle in it. To represent a cycle in the given linked list, we use an integer pos which represents the position (0-indexed) in the linked list where tail connects to. If pos is -1, then there is no cycle in the linked list. Example 1: Input: head = [3,2,0,-4], pos = 1 Output: true Explanation: There is a cycle in the linked list, where tail connects to the second node.</description>
    </item>
    
    <item>
      <title>Leetcode 136</title>
      <link>https://wushaoqiang.github.io/posts/leetcode-136/</link>
      <pubDate>Mon, 29 Apr 2019 22:26:40 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/leetcode-136/</guid>
      <description>题目 Given a non-empty array of integers, every element appears twice except for one. Find that single one. Note: Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory? Example 1: Input: [2,2,1] Output: 1 Example 2: Input: [4,1,2,1,2] Output: 4  我的解答 没想出来，看了评论区才知道
最优解答 func singleNumber(nums []int) int { for i := len(nums) - 1; i &amp;gt; 0; i-- { nums[i-1] = nums[i-1] ^ nums[i] } return nums[0] }  难疑点&amp;amp;核心 因为题目说了，只有一个数字是不会出现两次，其它数字都出现两次</description>
    </item>
    
    <item>
      <title>Leetcode 125</title>
      <link>https://wushaoqiang.github.io/posts/leetcode-125/</link>
      <pubDate>Mon, 29 Apr 2019 22:26:35 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/leetcode-125/</guid>
      <description>题目 给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。 说明：本题中，我们将空字符串定义为有效的回文串。 示例 1: 输入: &amp;quot;A man, a plan, a canal: Panama&amp;quot; 输出: true 示例 2: 输入: &amp;quot;race a car&amp;quot; 输出: false  我的解答 func isPalindrome(s string) bool { s = strings.Join(filter(s), &amp;quot;&amp;quot;) n := len(s) for i := 0; i &amp;lt; n/2; i++ { if s[i] != s[n-1-i] { return false } } return true } func filter(s string) []string { return strings.FieldsFunc(strings.ToLower(s), func(r rune) bool { return !</description>
    </item>
    
    <item>
      <title>Leetcode 122</title>
      <link>https://wushaoqiang.github.io/posts/leetcode-122/</link>
      <pubDate>Mon, 29 Apr 2019 22:26:29 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/leetcode-122/</guid>
      <description>题目 给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。 设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。 注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。 示例 1: 输入: [7,1,5,3,6,4] 输出: 7 解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。 随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。 示例 2: 输入: [1,2,3,4,5] 输出: 4 解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。 注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。 因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。 示例 3: 输入: [7,6,4,3,1] 输出: 0 解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。  我的解答 func maxProfit(prices []int) int { buy := 0 sell := 0 profit := 0 n := len(prices) for { for buy &amp;lt; n-1 &amp;amp;&amp;amp; prices[buy+1] &amp;lt;= prices[buy] { buy++ } sell = buy for sell &amp;lt; n-1 &amp;amp;&amp;amp; prices[sell+1] &amp;gt; prices[sell] { sell++ } if sell == buy { return profit } profit += prices[sell] - prices[buy] buy = sell } }  最优解答 无</description>
    </item>
    
    <item>
      <title>Leetcode 121</title>
      <link>https://wushaoqiang.github.io/posts/leetcode-121/</link>
      <pubDate>Mon, 29 Apr 2019 00:38:18 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/leetcode-121/</guid>
      <description>题目 Say you have an array for which the ith element is the price of a given stock on day i. If you were only permitted to complete at most one transaction (i.e., buy one and sell one share of the stock), design an algorithm to find the maximum profit. Note that you cannot sell a stock before you buy one. Example 1: Input: [7,1,5,3,6,4] Output: 5 Explanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.</description>
    </item>
    
    <item>
      <title>Leetcode 119</title>
      <link>https://wushaoqiang.github.io/posts/leetcode-119/</link>
      <pubDate>Mon, 29 Apr 2019 00:38:14 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/leetcode-119/</guid>
      <description>题目 Given a non-negative index k where k ≤ 33, return the kth index row of the Pascal&#39;s triangle. Note that the row index starts from 0. In Pascal&#39;s triangle, each number is the sum of the two numbers directly above it. Example: Input: 3 Output: [1,3,3,1] Follow up: Could you optimize your algorithm to use only O(k) extra space?  我的解答 func getRow(rowIndex int) []int { result := make([]int, rowIndex+1) result[0] = 1 for i := 0; i &amp;lt; rowIndex; i++ { result[i+1] = result[i] for j := i; j &amp;gt; 0; j-- { result[j] = result[j] + result[j-1] } } return result }  最优解答 无</description>
    </item>
    
    <item>
      <title>Leetcode 118</title>
      <link>https://wushaoqiang.github.io/posts/leetcode-118/</link>
      <pubDate>Mon, 29 Apr 2019 00:38:11 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/leetcode-118/</guid>
      <description>题目 Given a non-negative integer numRows, generate the first numRows of Pascal&#39;s triangle. In Pascal&#39;s triangle, each number is the sum of the two numbers directly above it.  我的解答 func generate(numRows int) [][]int { if numRows == 0 { return nil } result := make([][]int, numRows) for i := 0; i &amp;lt; numRows; i++ { result[i] = make([]int, i+1) result[i][0] = 1 result[i][i] = 1 for j := 1; j &amp;lt; i; j++ { result[i][j] = result[i-1][j-1] + result[i-1][j] } } return result }  最优解答 无</description>
    </item>
    
    <item>
      <title>Leetcode 112</title>
      <link>https://wushaoqiang.github.io/posts/leetcode-112/</link>
      <pubDate>Mon, 29 Apr 2019 00:38:06 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/leetcode-112/</guid>
      <description>题目 Given a binary tree and a sum, determine if the tree has a root-to-leaf path such that adding up all the values along the path equals the given sum. Note: A leaf is a node with no children. Example: Given the below binary tree and sum = 22, 5 / \ 4 8 / / \ 11 13 4 / \ \ 7 2 1 return true, as there exist a root-to-leaf path 5-&amp;gt;4-&amp;gt;11-&amp;gt;2 which sum is 22.</description>
    </item>
    
    <item>
      <title>Leetcode 111</title>
      <link>https://wushaoqiang.github.io/posts/leetcode-111/</link>
      <pubDate>Mon, 29 Apr 2019 00:38:02 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/leetcode-111/</guid>
      <description>题目 Given a binary tree, find its minimum depth. The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node. Note: A leaf is a node with no children. Example: Given binary tree [3,9,20,null,null,15,7], 3 / \ 9 20 / \ 15 7 return its minimum depth = 2.  我的解答 func minDepth(root *TreeNode) int { return findMinDepth(root) } func findMinDepth(root *TreeNode) int { if root == nil { return 0 } return 1 + min(findMinDepth(root.</description>
    </item>
    
    <item>
      <title>Leetcode 110</title>
      <link>https://wushaoqiang.github.io/posts/leetcode-110/</link>
      <pubDate>Mon, 29 Apr 2019 00:38:00 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/leetcode-110/</guid>
      <description>题目 Given a binary tree, determine if it is height-balanced. For this problem, a height-balanced binary tree is defined as: a binary tree in which the depth of the two subtrees of every node never differ by more than 1. Example 1: Given the following tree [3,9,20,null,null,15,7]: 3 / \ 9 20 / \ 15 7 Return true. Example 2: Given the following tree [1,2,2,3,3,null,null,4,4]: 1 / \ 2 2 / \ 3 3 / \ 4 4 Return false.</description>
    </item>
    
    <item>
      <title>TenToSeventeen</title>
      <link>https://wushaoqiang.github.io/posts/tenToSeventeen/</link>
      <pubDate>Sun, 28 Apr 2019 16:25:41 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/tenToSeventeen/</guid>
      <description>代码 func tenToSeventeen(num int) []int { len := 0 tmp := num for tmp/17 &amp;gt; 0 { len++ tmp = tmp / 17 } result := make([]int, len+1) for num &amp;gt; 0 { result[len] = num % 17 num = num / 17 len-- } return result } func intToString(result []int) []string { strs := make([]string, 0) for _, num := range result { switch { case num &amp;lt; 10: strs = append(strs, strconv.</description>
    </item>
    
    <item>
      <title>Data Structure</title>
      <link>https://wushaoqiang.github.io/posts/data-structure/</link>
      <pubDate>Sun, 28 Apr 2019 11:03:57 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/data-structure/</guid>
      <description> 前段时间复习了一些数据结构，一直没来得及总结一下
链表(双向) 单向链表和循环链表思路是差不多的
结构体 type LinkListNode struct { Value interface{} Next *LinkListNode Prev *LinkListNode } type LinkList struct { len int head *LinkListNode tail *LinkListNode }  </description>
    </item>
    
    <item>
      <title>Web请求历程</title>
      <link>https://wushaoqiang.github.io/posts/web-request-process/</link>
      <pubDate>Sun, 28 Apr 2019 10:19:02 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/web-request-process/</guid>
      <description>这几乎是做后端开发面试的时候必问的一道题，答案可以说得很简单，也可以是很复杂，当然面试官喜欢看到你对此有所深入，因此这篇文章就从头到尾详细的讲一遍这个历程
参考 《计算机网络》
1 当一台电脑将网线插上，网线的另一端是以太网的交换机(交换机能够知道连接它的机器的MAC地址，如果不清楚交换机是什么，建议自己搜一下，这里不做解释)
首先，刚开始电脑是没有IP地址的，这个时候电脑会生成一个DHCP请求报文，这个报文是一个UDP报文，目的端口为67，源端口为68。这个UDP报文被装载到IP报文，有目的IP地址是255.255.255.255，因为电脑不知道可以从哪个IP请求到自己的IP地址，源IP地址是0.0.0.0。再次往下传递就到了链路层，我们这里假设用的是以太网，所以链路层会将网络层的数据包放置在以太网帧中，目的MAC地址为FF:FF:FF:FF:FF:FF，源MAC地址就是你电脑网卡的MAC地址了，这个我们不用关心。这个时候一个广播的报文就做好了
报文被发送到交换机上，因为这是一个广播报文，因此在交换机上连接的所有设备都应该能收到这个报文，包括了DHCP服务器
这里说多一句，现阶段，一般DHCP服务器集成在了路由器上，而这个路由器一般来说是我们的网关(至少在我这边是这样的)，具体如何查的，用wireshark抓包看看吧，抓到DHCP包你就知道了(记得先拔网线再插上)
2 我们假设这个DHCP包已经完整到达了路由，这个路由生成了一个UDP-IP-以太网报文，这个时候数据报里包含了
 分配给电脑的IP
 DNS服务器IP
 默认网关路由器IP
 网络掩码
  这个数据包是具有一个准确的目的MAC地址的(也就是电脑的MAC，我们之前发送的报文里有记录)
所以交换机能够将这个DHCP的响应报文发给电脑
3 刚插上网线呢，就做了这么多东西了
这个时候我们打开浏览器，输入网址域名
这个时候我们需要得到这个域名的IP地址才能与其建立连接
再次构造一个UDP报文，目的端口为53，源端口任意
封装到IP数据包，源和目的IP地址在上面已经得到了，填上
到了链路层需要两个MAC地址，好像我们只有自己的MAC地址，目的MAC地址未知
这个时候电脑会生成一个ARP报文寻找默认网关的MAC地址(这个就不详细说了)
关于DNS报文的所有要的东西都齐全了，发送DNS报文
4 一般来说，常用的域名的IP都会存储在DNS缓存里，因此会比较快速
关于更多的DNS相关的，不在这次范围内
因此我们假设已经在某DNS服务器上拿到了DNS回答报文，这个报文就包括了我们要访问的URL的IP
5 这个时候电脑以及具备和远程的服务器建立TCP连接了
首先先是TCP的三次握手，三次握手在别的文章里讲到
握手成功后，发送请求报文，经过互联网路由器的一系列转发到达了相应的服务器
服务器收到了电脑发送的请求，并做出相应的处理，将结果写入响应报文，按照原来的TCP连接返回给电脑
6 电脑的浏览器通过处理渲染以及加载就呈现出了看到的网页</description>
    </item>
    
    <item>
      <title>Leetcode 108</title>
      <link>https://wushaoqiang.github.io/posts/leetcode-108/</link>
      <pubDate>Sat, 27 Apr 2019 23:13:54 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/leetcode-108/</guid>
      <description>题目 Given an array where elements are sorted in ascending order, convert it to a height balanced BST. For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1. Example: Given the sorted array: [-10,-3,0,5,9], One possible answer is: [0,-3,9,-10,null,5], which represents the following height balanced BST: 0 / \ -3 9 / / -10 5  我的解答 func sortedArrayToBST(nums []int) *TreeNode { if len(nums) == 0 { return nil } mid := (len(nums) - 1) / 2 head := &amp;amp;TreeNode{Val: nums[mid]} heightHalancedTree(head, nums, 0, mid-1) heightHalancedTree(head, nums, mid+1, len(nums)-1) return head } func heightHalancedTree(t *TreeNode, nums []int, left, right int) { if left &amp;lt;= right { mid := (left + right) / 2 // fmt.</description>
    </item>
    
    <item>
      <title>Leetcode 107</title>
      <link>https://wushaoqiang.github.io/posts/leetcode-107/</link>
      <pubDate>Sat, 27 Apr 2019 21:36:47 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/leetcode-107/</guid>
      <description>题目 Given a binary tree, return the bottom-up level order traversal of its nodes&#39; values. (ie, from left to right, level by level from leaf to root). For example: Given binary tree [3,9,20,null,null,15,7], 3 / \ 9 20 / \ 15 7 return its bottom-up level order traversal as: [ [15,7], [9,20], [3] ]  我的解答 没做出来
最优解答 func levelOrderBottom(root *TreeNode) [][]int { var ret [][]int if root == nil { return nil } que := []*TreeNode{root} for len(que) &amp;gt; 0 { //先记录这一层的长度 len := len(que) var level []int //只要遍历完len长度就退出循环 for i := 0; i &amp;lt; len; i++ { // 每次遍历取队列第一个元素，因此队列遍历了一个元素之后要立即删除 node := que[0] que = que[1:] level = append(level, node.</description>
    </item>
    
    <item>
      <title>Leetcode 104</title>
      <link>https://wushaoqiang.github.io/posts/leetcode-104/</link>
      <pubDate>Sat, 27 Apr 2019 21:36:42 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/leetcode-104/</guid>
      <description>题目 Given a binary tree, find its maximum depth. The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node. Note: A leaf is a node with no children. Example: Given binary tree [3,9,20,null,null,15,7], 3 / \ 9 20 / \ 15 7 return its depth = 3.  我的解答 func maxDepth(root *TreeNode) int { if root == nil { return 0 } if root.</description>
    </item>
    
    <item>
      <title>Leetcode 101</title>
      <link>https://wushaoqiang.github.io/posts/leetcode-101/</link>
      <pubDate>Sat, 27 Apr 2019 21:36:39 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/leetcode-101/</guid>
      <description>题目 Given a binary tree, check whether it is a mirror of itself (ie, symmetric around its center). For example, this binary tree [1,2,2,3,4,4,3] is symmetric: 1 / \ 2 2 / \ / \ 3 4 4 3 But the following [1,2,2,null,3,null,3] is not: 1 / \ 2 2 \ \ 3 3 Note: Bonus points if you could solve it both recursively and iteratively.  我的解答 这题做的比较蠢，没有任何参考价值，就不放了</description>
    </item>
    
    <item>
      <title>Leetcode 100</title>
      <link>https://wushaoqiang.github.io/posts/leetcode-100/</link>
      <pubDate>Sat, 27 Apr 2019 21:36:35 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/leetcode-100/</guid>
      <description>题目 Given two binary trees, write a function to check if they are the same or not. Two binary trees are considered the same if they are structurally identical and the nodes have the same value. Example 1: Input: 1 1 / \ / \ 2 3 2 3 [1,2,3], [1,2,3] Output: true Example 2: Input: 1 1 / \ 2 2 [1,2], [1,null,2] Output: false Example 3: Input: 1 1 / \ / \ 2 1 1 2 [1,2,1], [1,1,2] Output: false  我的解答 /** * Definition for a binary tree node.</description>
    </item>
    
    <item>
      <title>Leetcode 88</title>
      <link>https://wushaoqiang.github.io/posts/leetcode-88/</link>
      <pubDate>Sat, 27 Apr 2019 21:33:45 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/leetcode-88/</guid>
      <description>题目 Given two sorted integer arrays nums1 and nums2, merge nums2 into nums1 as one sorted array. Note: The number of elements initialized in nums1 and nums2 are m and n respectively. You may assume that nums1 has enough space (size that is greater or equal to m + n) to hold additional elements from nums2. Example: Input: nums1 = [1,2,3,0,0,0], m = 3 nums2 = [2,5,6], n = 3 Output: [1,2,2,3,5,6]  我的解答 func merge(nums1 []int, m int, nums2 []int, n int) { for m &amp;gt; 0 &amp;amp;&amp;amp; n &amp;gt; 0 { if nums1[m-1] &amp;gt;= nums2[n-1] { nums1[n+m-1] = nums1[m-1] m-- } else { nums1[n+m-1] = nums2[n-1] n-- } } if m == 0 { for n &amp;gt; 0 { nums1[n-1] = nums2[n-1] n-- } return } }  解法思路是归并排序，这相当于归并排序的最后一步了</description>
    </item>
    
    <item>
      <title>Golang GC</title>
      <link>https://wushaoqiang.github.io/posts/golang-GC/</link>
      <pubDate>Sat, 27 Apr 2019 12:48:58 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/golang-GC/</guid>
      <description>用了Golang有一段时间了，知道Golang能够自动回收内存也有一段时间了，对于我这种不搞明白原理不甘心系列，今天就来搞明白什么是GC
参考  legendtkl
 Golang UK Conference 2017 | Will Sewell &amp;amp; Jim Fisher - Golang&amp;rsquo;s Realtime GC in Theory and Practice
  算法模型 三色标记算法(Mark-and-sweep)
三色分别为(黑色，灰色，白色)，其中黑色不能够有指针指向白色的数据
 这个算法实现广度优先(BF)
 重复选取一个灰色，将它的所指向的所有对象都变成灰色，自己变成黑色
 这个重复选取直到没有灰色的对象为止
  在上面三个步骤能体会到各个颜色代表的意思(运行阶段)
 黑色：已经遍历过这个对象的所有对象
 灰色：这个对象所指向的对象还没有被遍历过
 白色：它被指向的节点是灰色、或者它根本没有被指向(这就是垃圾)
  结束阶段里，按算法所解释的，是不会再有灰色了，只有
 黑色：有用的数据
 白色：已经不可能到达的数据(垃圾，会被清理)
  回收时主要的流程  从root开始找到所有可达的对象，标记灰色
 执行我们前面所说的模型里的循环
 在处理完循环后，清理所有白色标记的对象
  小结 其实GC还有很多很多的细节，笔者只是在这里先建立一个概念，等后面到达一定阶段再去看看具体的实现
2019.05.06 今天在看了一个视频
在最后面讲到GC的问题的时候，发现GC的一个问题
 对象太多的时候，GC会大量占用CPU  是怎么一回事呢，因为对象越多，GC在遍历的时候需要的资源就越多，所以会导致CPU被大量占用(因为GC是多协程并发的)</description>
    </item>
    
    <item>
      <title>Golang 依赖注入</title>
      <link>https://wushaoqiang.github.io/posts/golang-dependency-injection/</link>
      <pubDate>Fri, 26 Apr 2019 21:05:43 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/golang-dependency-injection/</guid>
      <description>面试时遇到一道题，问依赖注入带来了什么好处。。。？？？我连啥是依赖注入都不知道，真是打扰了，赶紧补回来
没有DI 把所有创建变量放在New函数里面
type Person struct{ name string age int } type Student struct{ person *Person } func NewPerson() *Person{ return &amp;amp;Person{} } func NewStudent() *Student{ return &amp;amp;Student{ person:&amp;amp;Person{}, } } func main(){ s := NewStudent() }  我们不能按照自己的意愿传入想要的参数,这样main函数比较简单
有DI type Person struct{ name string age int } type Student struct{ person *Person } func NewPerson(name string,age int) *Person{ return &amp;amp;Person{ name:name, age:age, } } func NewStudent(person *Person) *Student{ return &amp;amp;Student{ person:person, } } func main(){ p := NewPerson(&amp;quot;abc&amp;quot;,12) s := NewStudent(p) }  这里我们就是有依赖注入，能够按照我们的需要传入参数，但是main的代码会随着结构体的传递变得很长</description>
    </item>
    
    <item>
      <title>Golang 泛型</title>
      <link>https://wushaoqiang.github.io/posts/golang-generic/</link>
      <pubDate>Fri, 26 Apr 2019 19:55:21 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/golang-generic/</guid>
      <description>笔者今天参加了一个面试，笔试第一题泛型，因为Go里没有泛型，因此对此毫无概念，开这篇文章解决这个问题
泛型是什么 类型的参数化，在静态语言里，类型尤为重要，虽然Go里interface{}接口可以传入任何类型，但这不利于错误检查(程序不会在编译的时候检查到错误，而是在运行时出错，这就很不爽了)
比如我们需要一个int双向链表，这个时候我们就要写一个结构体大概是
type LinkListNode struct { Value int Next *LinkListNode Prev *LinkListNode } type LinkList struct { len int head *LinkListNode tail *LinkListNode }  如果我们还要写一个字符串的链表，这个时候将Value的类型改成string就行了，其它不用变，如果我们还要..balabala，可能就要定义上百个结构体了，到时候代码全是结构体
有些同学说，用接口不就可以了吗？用接口不就无法实现类型的判断了吗，万一程序哪个地方本应该收到int，却收了一个string，然后程序boom
关于网上很多网友使用interface来达到所谓的泛型，我是越看越像多态呀，并且还是达不到泛型所能提供的类型保护啊，虽然算法确实可以复用了(有些)
泛型的目的是减少代码的重复性，也就是增加重用性，还能够确定数据类型，比如Java中的一个例子
class Factory&amp;lt;T&amp;gt;{ private T value; public T getValue() { return value; } public void setValue(T v) { this.value = v; } }  T我可以是字符串，也可以是整数等，或者是自己定义的结构体。但是一旦定下来，创建了的变量类型就不能变了
所以我说了那么多。。怎么实现啊
实现 Go2草稿中有提到这个话题Go 2 Draft Designs
目前只是一个草稿，并且是由Gopher们共同推进的一个话题，所以说现在Go内置里面还未实现泛型
笔者也去看了一些关于泛型的讨论，到最后都还是建议不要在现阶段写泛型程序，因为Go有一个很本质的特点，就是简单写、简单读，如果通过一些自己的&amp;rdquo;创造&amp;rdquo;而造成别人阅读代码困难，那是得不偿失
所以真香，还是用回多态吧，有机会再详细阅读一下草稿
对此Go2还对错误处理进行了强烈的讨论，笔者也希望以后写Go不用一大堆错误处理了。。真的看到眼花
这里是Go2官方对这些修改的想法视频</description>
    </item>
    
    <item>
      <title>Effective Go</title>
      <link>https://wushaoqiang.github.io/posts/effective-go/</link>
      <pubDate>Thu, 25 Apr 2019 23:46:13 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/effective-go/</guid>
      <description>参考Effective Go中英双语版
 It&amp;rsquo;s also important to know the established conventions for programming in Go, such as naming, formatting, program construction, and so on, so that programs you write will be easy for other Go programmers to understand.
 Go的一个好处就是，大家的代码风格基本一致，看别人代码就不会显得很痛苦了(前提是开发者遵守)
所以我们今天来谈谈代码规范吧，这里只记录了我自己有时候会忽略的点，有一些规范我以及掌握并且时刻用在编写Golang程序上了，因此不记录，想看完整的请阅读上面的开源书本
格式化 Go的gofmt为我们做好了，所以安装这个程序，在保存的时候就可以自动帮你调整代码布局
注释 行注释更为常用，而块注释则主要用作包的注释
每个包都应包含一段包注释，即放置在包子句前的一个块注释。对于包含多个文件的包， 包注释只需出现在其中的任一文件中即可。包注释应在整体上对该包进行介绍，并提供包的相关信息。 它将出现在 godoc 页面中的最上面，并为紧随其后的内容建立详细的文档。
每个可导出（首字母大写）的名称都应该有文档注释。
命名 我记得有一个叫go-lint会检查这个
Go 中约定使用驼峰记法 MixedCaps 或 mixedCaps 而非下划线的方式来对多单词名称进行命名。
只包含一个方法的接口应当以该方法的名称加上 - er 后缀来命名，如 Reader
若你有个名为 owner （小写，未导出）的字段，其获取器应当名为 Owner（大写，可导出）而非 GetOwner。大写字母即为可导出的这种规定为区分方法和字段提供了便利。 若要提供设置器方法，SetOwner 是个不错的选择</description>
    </item>
    
    <item>
      <title>Interview2</title>
      <link>https://wushaoqiang.github.io/posts/interview2/</link>
      <pubDate>Thu, 25 Apr 2019 22:05:12 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/interview2/</guid>
      <description>最大连续子数组和  线程之间共享数据的方式  Go encourages the use of channels to pass references to data between goroutines
 这里应该用channel来达到通信
在Go里面，推荐使用数据交换来达到共享的效果，可能和别的编程语言有很大的不同
进程和线程的区别 进程：操作系统对一个正在运行的程序的一种抽象，一个系统上可以运行多个进程，这些进程在单核的处理器下一样可以显得好像的并发的一样，这是通过处理器在进程之间的切换实现的，这种交错执行的机制称为上下文切换
线程：一个进程可以由多个线程的执行单元组成，每个线程都运行在进程的上下文中
区别：
 进程在系统上运行，线程在进程上运行，因此进程是独立的地址空间、线程共享进程的地址空间
 线程比进程的开销要小
 线程一般来说比进程更高效
 线程之间的数据共享比进程的简单
 线程必须依赖在进程上执行
  临界区是啥 临界区从通俗层面来讲就是我们锁-解锁之间的代码，通常会写在程序(或者说资源)无法同时被使用的地方
这个区域只能允许一个线程或进程进入，其它后来的需要等待解锁
死锁是啥。死锁产生的条件是什么 在我理解里，线程A占用了资源C，这个时候线程A还要申请资源D(占用且申请)，但线程B这时占用着资源D，而且线程A无法将资源抢过来，所以现在线程A就在等待线程B释放资源D。线程B在这个时候也需要使用资源C，并且不得到就不离开(一直等待)，所以现在局面就是A在等B释放D，B在等A释放C(循环等待)，并且都不肯让资源(不可抢占)，并且资源CD都是只能有一个线程占有的(互斥)
若干进程竞争有限资源，但顺序或者决策不当，使得大家都在无限循环等待，就形成了死锁
 互斥条件
 不可抢占条件
 占有且申请条件(这个的意思是在占有资源的情况下还要去申请别的资源)
 循环等待条件
  只要上述条件有一个不满足，就可以避免死锁
给出很多串信息 包含ip url info 等信息 info包含error等状态码 用Linux命令统计出每个url对应的error概率 占时还不太清除这个
Linux命令 如何杀死占用指定端口的进程 这个可能可以分解为两个问题，如果从端口找到进程pid，如何杀死指定pid的进程
所以查找pid有lsof -i:port和netstat -p |grep port</description>
    </item>
    
    <item>
      <title>Linux 网络管理</title>
      <link>https://wushaoqiang.github.io/posts/linux-network-management/</link>
      <pubDate>Thu, 25 Apr 2019 20:29:02 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/linux-network-management/</guid>
      <description>ping -c 发送一定数量的报文
ifconfig 其中输出信息里
enp0s31f6：以太网(有线)
lo：回传
wlp4s0：无线网
tcpdump 这是一个类似wireshark抓包的命令,需要权限
-c：指定抓取包的数量
-i：指定接口(上面说到有3个接口)
port：指定端口
netstat -r：显示路由
-i：显示接口
-n：显示IP
-t：tcp
-u：udp</description>
    </item>
    
    <item>
      <title>Linux 进程管理</title>
      <link>https://wushaoqiang.github.io/posts/linux-process-management/</link>
      <pubDate>Thu, 25 Apr 2019 17:04:19 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/linux-process-management/</guid>
      <description>进程状态  R 正在运行或在运行队列
 D 不可中断，进程不会因为信号被唤醒，只能等待中断发生
 S 中断，等待某个事件完成或者被信号唤醒
 Z 僵死，进程已经终止但其父进程没有用wait()或在waitpid()来释放它
 T 停止，可能是收到控制信号，也可能是被跟踪
  相关命令 ps,pstree,top(htop),jobs,kill，nice，nohup
Crtl+c:终结进程
Ctrl+z:暂停进程
ps(Process Status) ps 只会给当前终端中运行的进程
ps -a Select all processes except both session leaders (see getsid(2)) and processes not associated with a terminal.
ps -u root显示root用户的process，这里root也可以是别的用户名
ps -l 相对ps，会显示父PID等信息
ps aux 显示所有process
ps -ef 详细显示所有process
pstree pstree 进程树
pstree -p 显示PID
pstree (username) 显示用户的进程
jobs jobs 查看后台运行的进程
fg %num 将后台程序转移到前台</description>
    </item>
    
    <item>
      <title>Golang Vscode Problem</title>
      <link>https://wushaoqiang.github.io/posts/golang-vscode-problem/</link>
      <pubDate>Wed, 24 Apr 2019 20:56:13 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/golang-vscode-problem/</guid>
      <description>今天Vscode用着用着，突然自动补全不能用了，不仅没有自动导入，也没有函数提示等
突然觉得自己被打入地狱(没有自动补全就像手写代码一样，很不是滋味)
在Google上找了别人的方法也都没用，最后瞎搞一下搞好了
方法 删掉gocode
go get github.com/nsf/gocode,这是一个老版本的gocode，现在已经被新的替代了
这个时候vscode会提示你下载推荐版本的gocode，按下载就可以了
疑问 我也曾经重试下载最新版gocode，但是没用，不知道为什么直接在vscode更新就有用</description>
    </item>
    
    <item>
      <title>Golang Context</title>
      <link>https://wushaoqiang.github.io/posts/golang-context/</link>
      <pubDate>Wed, 24 Apr 2019 19:07:52 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/golang-context/</guid>
      <description>Context又名上下文，在一开始接触这个词的时候就有点迷惑了，开一篇文章把这个困扰了我有一阵子的迷惑解开吧
参考博客理解Go Context机制
Golang的执行单元是goroutine，main也是一个goroutine
上下文，上下则是存在上下层的传递，我们在编写Web后端的时候，接收到一个请求可能会执行一些列的goroutine(数据库，业务层处理)来达到并发效果
这个时候，如果客户端那边取消了呢？如果我们在服务器端检测不到这个信号，那么我们服务器还是会继续服务，直到完成所有服务的时候，发现客户端已经不见了(资源就被浪费了)
所以我们需要在每一个由Request产生的goroutine里面装一个监控，这个监控会告诉程序客户端是否还在等待返回，如果客户端离开，那么程序立即停止对客户端的服务
Context接口 type Context interface { Deadline() (deadline time.Time, ok bool) Done() &amp;lt;-chan struct{} Err() error Value(key interface{}) interface{} }   Deadline会返回一个超时时间，Goroutine获得了超时时间后，例如可以对某些io操作设定超时时间。
 Done方法返回一个信道（channel），当Context被撤销或过期时，该信道是关闭的，即它是一个表示Context是否已关闭的信号。
 当Done信道关闭后，Err方法表明Context被撤的原因。
 Value可以让Goroutine共享一些数据，当然获得数据是协程安全的。但使用这些数据的时候要注意同步，比如返回了一个map，而这个map的读写则要加锁。
  每当我们处理一个Request的时候，都应该从Request里拿一个Context
req,err := http.NewRequest(http.MethodGet,&amp;quot;http://127.0.0.1:8080&amp;quot;,nil) if err != nil { log.Fatalln(err) } ctx := req.Context()   the context is canceled when the client&amp;rsquo;s connection closes
 如果Request的context是nil，那么它会返回一个context.Background()
var ( background = new(emptyCtx) todo = new(emptyCtx) )  方法 我们前面说了，Context是要上下传递的，我们需要达到一种效果： 上面的Context收到了中断信号，下面的也要进行中断</description>
    </item>
    
    <item>
      <title>Interview</title>
      <link>https://wushaoqiang.github.io/posts/interview/</link>
      <pubDate>Wed, 24 Apr 2019 15:32:21 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/interview/</guid>
      <description>本文是笔者自己收集他人面经，顺便检查一下自己的知识状况，找目标进一步提升
go的优势  Go是Google工程师基于现实世界开发经验进行改进的友好型语言
 简单明了
 容易学习
 简单的内置并发
 持有现代化标准库
 编译快
 格式被标准化
 较小内存占用
 部署独立
 支持vendor依赖
 兼容性好
 商业支持的开源
  go的调度 这里应该指的是goroutine的调度模式
读过Go Web编程那本书的人可能知道，go的并发是由线程、处理器、调度器和一个个的goroutine
简单说一下运行的一些规则
 每一个线程里面有一个的协程，从微观角度来看是顺序执行的，但是从宏观角度来看，因为执行速度快，线程里的协程不断切换，因此可以看作是并行
 处理器主要就是用来执行goroutine的，它也维护了一个goroutine的队列，里面有在等待的goroutine
 只有线程和处理器结合起来才能构造一个goroutine执行环境
 调度器，当协程阻塞的时候，会保存上下文，直到下次可以恢复运行
  这是一些比较浅显运行的规则，如果要深入goroutine的源码分析，推荐一篇文章
go struct能不能比较 如果是值类型，是可以比较的，比如
p1 := Person{Name: &amp;quot;SQ&amp;quot;, Age: 1} p2 := Person{Name: &amp;quot;SQ&amp;quot;, Age: 1} if p1 == p2 { fmt.Println(&amp;quot;same&amp;quot;) }  这样是有输出的
那如果是嵌套呢？也是一样的，只要是具有可比性的，如string,int这些类型，都能直接比较。如果结构体含有引用类型，因为是地址，所以肯定不一样，给个例子</description>
    </item>
    
    <item>
      <title>关于加密 --基础</title>
      <link>https://wushaoqiang.github.io/posts/encryption-basic/</link>
      <pubDate>Wed, 24 Apr 2019 11:03:38 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/encryption-basic/</guid>
      <description> 我们现在接触较多的两种加密方式
 对称加密
 公钥加密
  对称加密 利用一样的秘钥，在持有者双方进行加密和解密
但是第一次建立连接并且传输秘钥的时候不安全(当然可以通过其它方式传输)
速度快
公钥加密 用对方的公钥加密，发送给对方，因为只要对方有自己的私钥，因此就算密文半路被拦截，也不会泄露信息
安全性好，但速度慢
结合 结合两种加密方式，创建一个既安全又快的连接
 利用对方公钥加密对称秘钥，发送给对方
 对方收到用自己秘钥解密，得到对称秘钥
 双方用对称秘钥进行接下来的通信
  </description>
    </item>
    
    <item>
      <title>Leetcode 83</title>
      <link>https://wushaoqiang.github.io/posts/leetcode-83/</link>
      <pubDate>Tue, 23 Apr 2019 22:21:39 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/leetcode-83/</guid>
      <description>题目 给定一个排序链表，删除所有重复的元素，使得每个元素只出现一次。 示例 1: 输入: 1-&amp;gt;1-&amp;gt;2 输出: 1-&amp;gt;2 示例 2: 输入: 1-&amp;gt;1-&amp;gt;2-&amp;gt;3-&amp;gt;3 输出: 1-&amp;gt;2-&amp;gt;3  我的解答 type ListNode struct { Val int Next *ListNode } func deleteDuplicates(head *ListNode) *ListNode { c := head for c != nil { if c.Next == nil { return head } if c.Val == c.Next.Val { c.Next = c.Next.Next } else { c = c.Next } } return head }  因为是个排序的链表，因此只要前后对比，再根据指针的指向来改变链表
最优解答 /** * Definition for singly-linked list.</description>
    </item>
    
    <item>
      <title>Leetcode 70</title>
      <link>https://wushaoqiang.github.io/posts/leetcode-70/</link>
      <pubDate>Tue, 23 Apr 2019 22:21:35 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/leetcode-70/</guid>
      <description>题目 假设你正在爬楼梯。需要 n 阶你才能到达楼顶。 每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？ 注意：给定 n 是一个正整数。 示例 1： 输入： 2 输出： 2 解释： 有两种方法可以爬到楼顶。 1. 1 阶 + 1 阶 2. 2 阶 示例 2： 输入： 3 输出： 3 解释： 有三种方法可以爬到楼顶。 1. 1 阶 + 1 阶 + 1 阶 2. 1 阶 + 2 阶 3. 2 阶 + 1 阶  我的解答 func climbStairs(n int) int { if n == 1 || n == 2 { return n } count2 := n / 2 result := 0 for ; count2 &amp;gt;= 0; count2-- { result += calc(n-count2, count2) } return result } //注意float的运算可能会出现一些.</description>
    </item>
    
    <item>
      <title>Leetcode 69</title>
      <link>https://wushaoqiang.github.io/posts/leetcode-69/</link>
      <pubDate>Tue, 23 Apr 2019 22:21:31 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/leetcode-69/</guid>
      <description>题目 实现 int sqrt(int x) 函数。 计算并返回 x 的平方根，其中 x 是非负整数。 由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。 示例 1: 输入: 4 输出: 2 示例 2: 输入: 8 输出: 2 说明: 8 的平方根是 2.82842..., 由于返回类型是整数，小数部分将被舍去。  我的解答 func mySqrt(x int) int { return int(math.Floor(math.Sqrt(float64(x)))) }  向下取整
最优解答 func mySqrt(x int) int { if x == 0 || x == 1 { return x } i := x / 2.0 for i*i &amp;gt; x { i = (i + x/i) / 2 } return i }  数学公式</description>
    </item>
    
    <item>
      <title>Leetcode 67</title>
      <link>https://wushaoqiang.github.io/posts/leetcode-67/</link>
      <pubDate>Tue, 23 Apr 2019 22:21:26 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/leetcode-67/</guid>
      <description>题目 给定两个二进制字符串，返回他们的和（用二进制表示）。 输入为非空字符串且只包含数字 1 和 0。 示例 1: 输入: a = &amp;quot;11&amp;quot;, b = &amp;quot;1&amp;quot; 输出: &amp;quot;100&amp;quot; 示例 2: 输入: a = &amp;quot;1010&amp;quot;, b = &amp;quot;1011&amp;quot; 输出: &amp;quot;10101&amp;quot;  我的解答 func addBinary(a string, b string) string { lengthLonger, lengthShorter := 0, 0 tmp := &amp;quot;&amp;quot; if len(a) &amp;gt; len(b) { lengthLonger = len(a) lengthShorter = len(b) } else { lengthLonger = len(b) lengthShorter = len(a) tmp = b b = a a = tmp } resultArray := make([]int, lengthLonger+1) carry := 0 for i := lengthLonger; i &amp;gt;= 0; i-- { if i &amp;gt; (lengthLonger - lengthShorter) { currentA, _ := strconv.</description>
    </item>
    
    <item>
      <title>Leetcode 66</title>
      <link>https://wushaoqiang.github.io/posts/leetcode-66/</link>
      <pubDate>Tue, 23 Apr 2019 22:21:23 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/leetcode-66/</guid>
      <description>题目 给定一个由整数组成的非空数组所表示的非负整数，在该数的基础上加一。 最高位数字存放在数组的首位， 数组中每个元素只存储一个数字。 你可以假设除了整数 0 之外，这个整数不会以零开头。 示例 1: 输入: [1,2,3] 输出: [1,2,4] 解释: 输入数组表示数字 123。 示例 2: 输入: [4,3,2,1] 输出: [4,3,2,2] 解释: 输入数组表示数字 4321。  我的解答 func plusOne(digits []int) []int { for i := len(digits) - 1; i &amp;gt;= 0; i-- { if digits[i] != 9 { digits[i]++ return digits } digits[i] = 0 } digits = append([]int{1}, digits...) return digits }  比较简单
最优解答 无
难疑点&amp;amp;核心 无</description>
    </item>
    
    <item>
      <title>Leetcode 58</title>
      <link>https://wushaoqiang.github.io/posts/leetcode-58/</link>
      <pubDate>Tue, 23 Apr 2019 22:21:19 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/leetcode-58/</guid>
      <description> 题目 给定一个仅包含大小写字母和空格 &#39; &#39; 的字符串，返回其最后一个单词的长度。 如果不存在最后一个单词，请返回 0 。 说明：一个单词是指由字母组成，但不包含任何空格的字符串。 示例: 输入: &amp;quot;Hello World&amp;quot; 输出: 5  我的解答 func lengthOfLastWord(s string) int { if s == &amp;quot;&amp;quot; { return 0 } if !strings.Contains(s, &amp;quot; &amp;quot;) { return len(s) } s = strings.TrimSpace(s) lastSpaceIndex := strings.LastIndex(s, &amp;quot; &amp;quot;) return len(s) - lastSpaceIndex - 1 }  前面两个判断是为了能够快速判断简单情况
要注意去掉头尾的空格，不然索引查找会出错
这里也调用了标准库，可能在算法上不算合规
最优解答 无
难疑点&amp;amp;核心  容易把头尾的空格忽略掉  </description>
    </item>
    
    <item>
      <title>Leetcode 53</title>
      <link>https://wushaoqiang.github.io/posts/leetcode-53/</link>
      <pubDate>Tue, 23 Apr 2019 22:21:16 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/leetcode-53/</guid>
      <description>题目 给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。 示例: 输入: [-2,1,-3,4,-1,2,1,-5,4], 输出: 6 解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。 进阶: 如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的分治法求解。  我的解答 func maxSubArray(nums []int) int { if len(nums) == 0 { return 0 } if len(nums) == 1 { return nums[0] } total := nums[0] max := nums[0] for i := 1; i &amp;lt; len(nums); i++ { if total &amp;lt; 0 { total = 0 } total += nums[i] if max &amp;lt; total { max = total } } return max }  暴力法的话，时间复杂度是O(N^2)，这里使用的方法时间复杂度O(N)</description>
    </item>
    
    <item>
      <title>Leetcode 35</title>
      <link>https://wushaoqiang.github.io/posts/leetcode-35/</link>
      <pubDate>Tue, 23 Apr 2019 22:21:07 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/leetcode-35/</guid>
      <description>题目 给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。 你可以假设数组中无重复元素。 示例 1: 输入: [1,3,5,6], 5 输出: 2 示例 2: 输入: [1,3,5,6], 2 输出: 1 示例 3: 输入: [1,3,5,6], 7 输出: 4 示例 4: 输入: [1,3,5,6], 0 输出: 0  我的解答 func searchInsert(nums []int, target int) int { isFound, idx := binarySearch(nums, 0, len(nums)-1, target) if isFound { return idx } if nums[idx] &amp;gt; target { return idx } else { return idx + 1 } } func binarySearch(nums []int, left, right, target int) (found bool, idx int) { if left &amp;lt; right { mid := (left + right) / 2 if nums[mid] == target { return true, mid } else if nums[mid] &amp;gt; target { return binarySearch(nums, left, mid-1, target) } else { return binarySearch(nums, mid+1, right, target) } } else if nums[left] == target { return true, left } else { return false, left } }  因为是个有序的数组，因此可以不用暴力搜索，这里使用比较简单的二分法，找到索引(就算没有相等的，也找到最后一个查找的索引)</description>
    </item>
    
    <item>
      <title>Leetcode 28</title>
      <link>https://wushaoqiang.github.io/posts/leetcode-28/</link>
      <pubDate>Tue, 23 Apr 2019 22:21:04 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/leetcode-28/</guid>
      <description>题目 实现 strStr() 函数。 给定一个 haystack 字符串和一个 needle 字符串，在 haystack 字符串中找出 needle 字符串出现的第一个位置 (从0开始)。如果不存在，则返回 -1。 示例 1: 输入: haystack = &amp;quot;hello&amp;quot;, needle = &amp;quot;ll&amp;quot; 输出: 2 示例 2: 输入: haystack = &amp;quot;aaaaa&amp;quot;, needle = &amp;quot;bba&amp;quot; 输出: -1 说明: 当 needle 是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。 对于本题而言，当 needle 是空字符串时我们应当返回 0 。这与C语言的 strstr() 以及 Java的 indexOf() 定义相符。  我的解答 func strStr(haystack string, needle string) int { return strings.Index(haystack, needle) }  这里可能有点赖皮，直接调用了标准库，看网上说还有一种KMP的算法，比较难，按笔者现在的进度，先刷60简单题吧，后面再考虑实现。
当然还有暴力算法，但是我宁愿使用标准库吧
最优解答 无</description>
    </item>
    
    <item>
      <title>Leetcode 27</title>
      <link>https://wushaoqiang.github.io/posts/leetcode-27/</link>
      <pubDate>Tue, 23 Apr 2019 22:21:01 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/leetcode-27/</guid>
      <description>题目 给定一个数组 nums 和一个值 val，你需要原地移除所有数值等于 val 的元素，返回移除后数组的新长度。 不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。 元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。 示例 1: 给定 nums = [3,2,2,3], val = 3, 函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。 你不需要考虑数组中超出新长度后面的元素。 示例 2: 给定 nums = [0,1,2,2,3,0,4,2], val = 2, 函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。 注意这五个元素可为任意顺序。 你不需要考虑数组中超出新长度后面的元素。 说明: 为什么返回数值是整数，但输出的答案是数组呢? 请注意，输入数组是以“引用”方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。 你可以想象内部操作如下: // nums 是以“引用”方式传递的。也就是说，不对实参作任何拷贝 int len = removeElement(nums, val); // 在函数里修改输入数组对于调用者是可见的。 // 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。 for (int i = 0; i &amp;lt; len; i++) { print(nums[i]); }  我的解答 func removeElement(nums []int, val int) int { if len(nums) == 0 { return 0 } i := 0 j := len(nums) - 1 for i &amp;lt; j { if nums[i] == val { nums[i] = nums[j] j-- } else { i++ } } if nums[i] == val { return j } return j+1 }  因为题目说只需要给索引就可以了，因此不需要创建新的内存存放，只需要用一个索引将符合要求的值和不符合要求的值划分开(所以要交换它们位置)</description>
    </item>
    
    <item>
      <title>Leetcode 26</title>
      <link>https://wushaoqiang.github.io/posts/leetcode-26/</link>
      <pubDate>Tue, 23 Apr 2019 22:20:55 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/leetcode-26/</guid>
      <description>题目 给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。 不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。 示例 1: 给定数组 nums = [1,1,2], 函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 你不需要考虑数组中超出新长度后面的元素。 示例 2: 给定 nums = [0,0,1,1,1,2,2,3,3,4], 函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。 你不需要考虑数组中超出新长度后面的元素。 说明: 为什么返回数值是整数，但输出的答案是数组呢? 请注意，输入数组是以“引用”方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。 你可以想象内部操作如下: // nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝 int len = removeDuplicates(nums); // 在函数里修改输入数组对于调用者是可见的。 // 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。 for (int i = 0; i &amp;lt; len; i++) { print(nums[i]); }  我的解答 func removeDuplicates(nums []int) int { if len(nums) == 0 || len(nums) == 1 { return len(nums) } count := 0 existMap := make(map[int]bool) for _, num := range nums { if _, exist := existMap[num]; !</description>
    </item>
    
    <item>
      <title>Leetcode 21</title>
      <link>https://wushaoqiang.github.io/posts/leetcode-21/</link>
      <pubDate>Tue, 23 Apr 2019 22:20:50 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/leetcode-21/</guid>
      <description>题目 将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 示例： 输入：1-&amp;gt;2-&amp;gt;4, 1-&amp;gt;3-&amp;gt;4 输出：1-&amp;gt;1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;4  我的解答 /** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode { l4 := &amp;amp;ListNode{} l3 := &amp;amp;ListNode{} l4.Next = l3 for l1 != nil || l2 != nil { if l1 == nil { return l2 } if l2 == nil { return l1 } if l1.</description>
    </item>
    
    <item>
      <title>SQL 进阶</title>
      <link>https://wushaoqiang.github.io/posts/SQL-highlevel/</link>
      <pubDate>Tue, 23 Apr 2019 10:25:40 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/SQL-highlevel/</guid>
      <description>只针对Mysql的SQL语句
##创建TABLE
CREATE TABLE user ( id int PRIMARY KEY, username varchar(255) NOT NULL UNIQUE, password varchar(255) NOT NULL );  约束也可以这样写
CREATE TABLE user ( id int, username varchar(255) NOT NULL, password varchar(255) NOT NULL City varchar(255) DEFAULT &#39;Sandnes&#39; UNIQUE(username) PRIMARY KEY(id) FOREIGN KEY (P_id) REFERENCES Persons(P_id) )  约束  NOT NULL
 UNIQUE
 PRIMARY KEY(NOT NULL和UNIQUE的结合)
 FOREIGN KEY:保证一个表中的数据匹配另一个表中的值的参照完整性
 CHECK
 DEFAULT 默认值，在没有赋值的情况下就是默认值
  NOT NULL 强制不接受NULL，如果不向该字段添加值，就无法插入新纪录或者更新记录</description>
    </item>
    
    <item>
      <title>SQL 基础</title>
      <link>https://wushaoqiang.github.io/posts/SQL-basic/</link>
      <pubDate>Mon, 22 Apr 2019 23:05:06 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/SQL-basic/</guid>
      <description>笔者之前学了一些基础的Mysql的语法，现在进一步学习
关系型数据库用的语言标准就是SQL，只是不同的数据库有自己的拓展，所以学SQL标准可以说是一举多得吧
非关系型数据库有自己的一套语言
只针对Mysql的SQL语句
SELECT 选定要输出的列
SELECT column_name,column_name FROM table_name;  将所有列输出
SELECT * FROM table_name;  SELECT DISTINCT 如果一个列中包含了很多相同的，比如国家里面有很多人是中国的、日本的等等，我们指向查看有多少种的话，这样看起来很费劲
介绍一个解决这种问题的命令
和SELECT语法基本一样，只是这里不会输出相同的字段
SELECT DISTINCT column_name,column_name FROM table_name;  WHERE WHERE子句用于提取那些满足指定标准的记录
SELECT column_name,column_name FROM table_name WHERE column_name operator value;  例如，我要id大于3的user的id和name字段
SELECT id,name FROM user WHERE id &amp;gt; 3  这里提醒一点，当实例是文本字段需要加单引号，如果是数值字段，就像上面一样直接写就好
WHERE的运算符 WHERE column_name operator value  这里的operator就是运算符的位置
运算符有：
 =,&amp;gt;,&amp;gt;=,&amp;lt;,&amp;lt;= 这些就比较好理解了
 &amp;lt;&amp;gt; 不等于
 BETWEEN 在某个范围，用法WHERE column_name BETWEEN value1 AND value2</description>
    </item>
    
    <item>
      <title>DHCP 和 NAT</title>
      <link>https://wushaoqiang.github.io/posts/DHCP-and-NAT/</link>
      <pubDate>Mon, 22 Apr 2019 20:59:55 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/DHCP-and-NAT/</guid>
      <description>DHCP(动态主机配置协议) 我们在上网的时候，其实是向某一个ISP请求一个IP地址，这个IP地址是临时的，到期是要被回收的
四个步骤  让DHCP服务器发现客户端：客户端创建一个请求报文，请求端口号为67，但这个时候它连自己的IP地址都不知道(因为还没分配)，就用0.0.0.0:68来代替，但是它也不知道目标地址，所以用广播地址255.255.255.255:67
 DHCP服务器提供：DHCP收到了请求，做出响应，目标地址仍然使用255.255.255.255:68(这里端口号为68.因为客户68端口是接收这个包的)，这个时候客户端已经知道DHCP的位置了
 再次对准确地址发出请求
 DHCP响应
  到这里交互就完成了
NAT(网络地址转换) 这个是普遍使用在学校，家庭，公司等，因为现在IPv4的资源已经枯竭，利用NAT能够使得大家共用一个对外的IP，而内部会有不同的IP(局域网内IP)
比如我在学习请求百度这个网页，百度实际上看到的IP地址是我学校的IP地址，并且将内容返回给这个IP地址，学校再通过NAT转换表把东西转给我
有些人也说道，NAT实质上很大阻碍了IPv6的发展</description>
    </item>
    
    <item>
      <title>IPv4 数据报格式与分片</title>
      <link>https://wushaoqiang.github.io/posts/ip-message-field/</link>
      <pubDate>Mon, 22 Apr 2019 20:21:55 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/ip-message-field/</guid>
      <description>直接上图  版本号
 首部长度：一般为20
 服务类型：为了区分数据报，有点想女士优先这种
 数据报长度(首部加数据，一般不超过1500字节)
 标识、标志、片偏移：与IP数据报分片有关(别的篇幅讲)
 寿命：每经过一台路由器，TTL减1，若为0的时候，这个数据报就要丢掉了
 上层协议：6代表TCP；17代表UDP
 首部校验和(检验IP数据报比特错误)
 源和目的IP地址
 选项(很少用)
 数据(TCP or UDP报文段)
  IP数据报分片 发送方与目的地路径上的每段链路可能使用不同的链路层协议，且每种协议可能具备不同的MTU
比如以太网的MTU为1500
所以在通过MTU比较小的链路段时，就需要分片了
为了让目的主机执行重装任务，IPv4的设计者将标识、标志、片偏移字段放在IP数据报首部
分别解释这三个字段 标识 发送主机在发送IP数据报的时候，通常会将它发送的每个数据报的标识号加1
所以目的地址收到了很多片，这些片上标识号是同一个数字的，那么它们就是可以组合的
标志 最后一个片的标志比特被设为0，表明已经接收到某个标识的最后一个片
偏移量 毫无疑问，是为了将片重新组织回去的</description>
    </item>
    
    <item>
      <title>HTTP 报文</title>
      <link>https://wushaoqiang.github.io/posts/http-message-field/</link>
      <pubDate>Mon, 22 Apr 2019 19:17:47 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/http-message-field/</guid>
      <description> 客户向它的套接字接口发送HTTP请求报文和向它的套接字接口接收HTTP响应报文
HTTP是一个无状态协议
报文格式 响应报文格式 常见状态码 //Success 200 OK ：表示请求成功 201 Created ：表示请求成功且新建了资源 202 Accepted ：请求成功，但还没创建资源 //Redirection 301 Moved Permanently ：永久转移，服务器会自动转到新的位置 302 Found ：暂时转移，下次还是用这个URI 304 Not Modified ：服务端已经执行了GET，但文件未变化 //Client Error 400 Bad Request ：报文中存在语法错误 401 Unauthorized ：未认证 403 Forbidden ：对请求资源的访问被服务器拒绝了 404 Not Found ：无法找到指定的资源 //Server Error 500 Internal Server Error :服务器端在执行请求时发生了错误 503 Service Unavailable :服务器暂时处于超负载或正在进行停机维护  </description>
    </item>
    
    <item>
      <title>UDP</title>
      <link>https://wushaoqiang.github.io/posts/udp/</link>
      <pubDate>Mon, 22 Apr 2019 16:35:03 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/udp/</guid>
      <description>  UDP无连接建立
 不需要维护连接状态
 报文头比TCP小
 能尽可能的快，没有速度限制
  应用场景 对丢包不是很看重，对速度很敏感
 DNS
 SNMP
  报文结构 </description>
    </item>
    
    <item>
      <title>TCP 流量控制</title>
      <link>https://wushaoqiang.github.io/posts/tcp-flow-control/</link>
      <pubDate>Mon, 22 Apr 2019 15:17:17 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/tcp-flow-control/</guid>
      <description>流量控制是为了匹配发送方和接收方的数据交换速度，如果发送方发的太快，接收方的缓存可能会溢出
还要提醒一下流量控制和拥塞控制是两码事
TCP通过让发送方维护一个称为接收窗口的变量来提供流量控制
在接收方一定要满足
LastByteRcvd - LastByteRead &amp;lt;= RcvBuffer
用rwnd表示还有多少空间可以用，所以rwnd = RcvBuffer - (LastByteRcvd - LastByteRead)
在TCP报文首部里有一个叫做接收窗口，这个就是接收者告诉发送者rwnd的
在发送方，通过将未确认的数据量控制在值rwnd以内，就可以保证接收者不会缓存溢出了
UDP是不提供流量控制的，所以UDP很有可能会出现缓存溢出</description>
    </item>
    
    <item>
      <title>TCP 拥塞控制</title>
      <link>https://wushaoqiang.github.io/posts/tcp-congestion-control/</link>
      <pubDate>Mon, 22 Apr 2019 13:11:08 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/tcp-congestion-control/</guid>
      <description> TCP必须使用端到端拥塞控制而不是网络辅助的拥塞控制
TCP所采用的方法是让每一个发送方根据所感知到的网络拥塞程度来限制其能向连接发送流量的速率
三个问题 我们如何知道网络开始拥塞？
我们如何限制发送方发送速率
当发送方感受到拥塞时，用什么算法去限制其发送速率
如何知道网络拥塞 TCP是不会有一种特殊的包叫“我拥塞啦”
接收到Ack 没有拥塞，可以提速
没接收到Ack 可能拥塞，降速
如何限制发送方速率 改变cwnd
当一切顺利，cwnd增加；丢包，cwnd减少
我们发送方被限制在min(rwnd,cwnd)
LastByteSent - LastByteAcked &amp;lt;= cwnd
rwnd和cwnd是不同的，前者是表示接收方的buffer还有多少能用，后者是改变在网络上的容量
用什么算法来限制速度 我们希望TCP能在不发生拥塞情况上利用最大的带宽
所以发送方速率有点像三角波，上上下下，因为要尽可能利用带宽又不要制造拥塞
慢启动 在包被收到的情况下 cwnd每次是之前的两倍1,2,4,8,16...，直到大于或等于阈值，切换到拥塞避免
在包没有被收到的情况下 三次冗余Ack 进入快速恢复
超时 阈值=cwnd/2
把cwnd变为1
阈值(threhold) 记录上一次拥塞时一半的cwnd
拥塞避免 在包被接收到的情况下 线性增长，每次在所有分片的Ack被接收到的情况下(一个RTT)，增加一个MSS
在包没有被接收到的情况下 三次冗余Ack 进入快速恢复
超时 切换到慢启动
快速恢复 每个冗余的Ack对cwnd增加一个MSS，当丢失报文段的Ack最终回到时，再减少一个MSS
进入拥塞避免状态
出现超时，进入慢启动
出现丢包，cwnd设置为1，阈值设置为cwnd的一半
总结一下 三次冗余ACK  阈值设置为cwnd/2
 cwnd设置为阈值(有快速恢复的情况下)
  超时  阈值设置为cwnd/2
 cwnd设置为1(MSS)
  </description>
    </item>
    
    <item>
      <title>TCP 连接 --三次握手和四次挥手</title>
      <link>https://wushaoqiang.github.io/posts/tcp-connect/</link>
      <pubDate>Mon, 22 Apr 2019 12:52:03 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/tcp-connect/</guid>
      <description> 首先这里所说的握手，是进程之间的握手
三次握手 简单来说就是
A --&amp;gt; B 不承载有效负荷 B --&amp;gt; A 不承载有效负荷 A --&amp;gt; B 可以承载有效负荷  再细致点说就是
 客户端应用程序发起一个TCP连接
 发送报文里有SYN
 收到来自服务器端的SYN&amp;amp;ACK
 再次向服务器端发送ACK
  这里面总共有3次报文，所以为三次握手
最大报文段长度&amp;amp;最大传输单元 最大报文段长度(MSS):一般为1460
最大传输单元(MTU):一般为1500
之说以说一般，是因为一般来说TCP/IP的首部字段加起来是40字节
1500-40=1460
清除认识 当进程通过套接字把数据给到TCP的时候，数据就和进程没关系了，已经全权交给TCP了
为什么不是两次握手？ 这是书本上的一个问题
在我理解，握手其实是为了双方知道对方的初始序列号
 客户端给服务器端发送初始序列号
 服务器端收到了客户端的初始序列号，并且发送服务器端的初始序列号
  如果客户端不产生第三次握手，那么服务器端不知道客户端到底拿到了初始序列号没
 客户端看到回复后就知道服务器端拿到了自己的初始序列号，于是也和服务器端说明，已经拿到它的初始序列号了  四次挥手  客户端应用程序发起关闭连接
 发送报文里包含FIN
 服务器端发送一个ACK表示接收到了
 服务器端再次发一个FIN
 客户端给服务器端发一个ACK
 等待一会，资源就释放了
  </description>
    </item>
    
    <item>
      <title>TCP --报文</title>
      <link>https://wushaoqiang.github.io/posts/tcp-message-field/</link>
      <pubDate>Mon, 22 Apr 2019 12:14:31 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/tcp-message-field/</guid>
      <description> 之间写过一个关于《计算机网络(原书第六版)：自顶向下方法》的一部分笔记，当时没继续写下去是因为觉得一个篇幅太多了，决定分开写，这样可能可以更加详细点，也算是第二次的复习吧
这篇主要讲报文
先看看报文的格式
首先，TCP是运输层的协议，IP是网络层的协议，一般运输层协议会确定端口号，网络层协议则确定IP地址
 源/目的端口号
 序号/确认号：是用来双方实现可靠传输的(下面详细讲)
 接收窗口字段：用于流量控制(可能会在别的篇幅讲)
 首部长度：由于有选项这个字段，使得TCP的首部长度是可以变化的，不过通常就是20字节
 标志字段/紧急指针：标志字段包括确认字段有效、建立和拆除连接、紧急数据。紧急指针指向紧急数据
  序号/确认号 一条TCP连接的双发均可随机地选择初始序号，可能是0和4294967295之间的任意值
我们假设初始序号为0
A --&amp;gt; B Seq=42,ACK=79,data=1 B --&amp;gt; A Seq=79,ACK=43,data=2 A --&amp;gt; B Seq=43,ACK=80,data=3 ...  在我理解
序号是标识我要发送给对方的数据
确认号是标识我需要对方发送给我的数据
所以上面场景就是
A给B发序号为42的数据，并且向B要序号为79的数据 B收到了A的数据，并且返回A所要的序号为79的数据，并且B还想要A序号为43的数据 以此类推...  </description>
    </item>
    
    <item>
      <title>Leetcode 20</title>
      <link>https://wushaoqiang.github.io/posts/leetcode-20/</link>
      <pubDate>Mon, 22 Apr 2019 00:46:01 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/leetcode-20/</guid>
      <description>题目 给定一个只包括 &#39;(&#39;，&#39;)&#39;，&#39;{&#39;，&#39;}&#39;，&#39;[&#39;，&#39;]&#39; 的字符串，判断字符串是否有效。 有效字符串需满足： 左括号必须用相同类型的右括号闭合。 左括号必须以正确的顺序闭合。 注意空字符串可被认为是有效字符串。 示例 1: 输入: &amp;quot;()&amp;quot; 输出: true 示例 2: 输入: &amp;quot;()[]{}&amp;quot; 输出: true 示例 3: 输入: &amp;quot;(]&amp;quot; 输出: false 示例 4: 输入: &amp;quot;([)]&amp;quot; 输出: false 示例 5: 输入: &amp;quot;{[]}&amp;quot; 输出: true  我的解答 笔者在做这道题的时候想的稍微复杂了点，用了递归的方法做，但速度什么的非常慢，所以不值得参考，只能说一路摸坑吧
var ( relation = map[string]string{&amp;quot;(&amp;quot;: &amp;quot;)&amp;quot;, &amp;quot;[&amp;quot;: &amp;quot;]&amp;quot;, &amp;quot;{&amp;quot;: &amp;quot;}&amp;quot;} ) func isValid(s string) bool { if len(s) == 0 { return true } if (len(s)+2)%2 != 0 { return false } if len(s) == 2 { return string(s[1]) == relation[string(s[0])] } // l := len(s) for { idx := getLastIndex(s) if idx == -1 { return false } if !</description>
    </item>
    
    <item>
      <title>Leetcode 14</title>
      <link>https://wushaoqiang.github.io/posts/leetcode-14/</link>
      <pubDate>Mon, 22 Apr 2019 00:45:56 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/leetcode-14/</guid>
      <description>题目 编写一个函数来查找字符串数组中的最长公共前缀。 如果不存在公共前缀，返回空字符串 &amp;quot;&amp;quot;。 示例 1: 输入: [&amp;quot;flower&amp;quot;,&amp;quot;flow&amp;quot;,&amp;quot;flight&amp;quot;] 输出: &amp;quot;fl&amp;quot; 示例 2: 输入: [&amp;quot;dog&amp;quot;,&amp;quot;racecar&amp;quot;,&amp;quot;car&amp;quot;] 输出: &amp;quot;&amp;quot; 解释: 输入不存在公共前缀。 说明: 所有输入只包含小写字母 a-z 。  我的解答 func longestCommonPrefix(strs []string) string { if len(strs) == 0 { return &amp;quot;&amp;quot; } if len(strs) == 1 { return strs[0] } shortestLen := len(strs[0]) for _, str := range strs { if len(str) &amp;lt; shortestLen { shortestLen = len(str) } } var finalStr string for i := 0; i &amp;lt; shortestLen; i++ { tmp := strs[0][i] for j := 1; j &amp;lt; len(strs); j++ { if tmp !</description>
    </item>
    
    <item>
      <title>Leetcode 13</title>
      <link>https://wushaoqiang.github.io/posts/leetcode-13/</link>
      <pubDate>Mon, 22 Apr 2019 00:45:53 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/leetcode-13/</guid>
      <description>题目 罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。 字符 数值 I 1 V 5 X 10 L 50 C 100 D 500 M 1000 例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做 XXVII, 即为 XX + V + II 。 通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况： I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。 X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。 给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。 示例 1: 输入: &amp;quot;III&amp;quot; 输出: 3 示例 2: 输入: &amp;quot;IV&amp;quot; 输出: 4 示例 3: 输入: &amp;quot;IX&amp;quot; 输出: 9 示例 4: 输入: &amp;quot;LVIII&amp;quot; 输出: 58 解释: L = 50, V= 5, III = 3.</description>
    </item>
    
    <item>
      <title>Leetcode 9</title>
      <link>https://wushaoqiang.github.io/posts/leetcode-9/</link>
      <pubDate>Mon, 22 Apr 2019 00:45:41 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/leetcode-9/</guid>
      <description>题目 判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。 示例 1: 输入: 121 输出: true 示例 2: 输入: -121 输出: false 解释: 从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。 示例 3: 输入: 10 输出: false 解释: 从右向左读, 为 01 。因此它不是一个回文数。 进阶: 你能不将整数转为字符串来解决这个问题吗？  我的解答 func isPalindrome(x int) bool { str := strconv.Itoa(x) for i := 0; i &amp;lt; len(str)/2; i++ { if str[i] != str[len(str)-1-i] { return false } } return true }  转换为字符串进行比较就简单很多了,直接头尾比较，时间复杂度为O(N/2),N为字符串长度</description>
    </item>
    
    <item>
      <title>Leetcode 1</title>
      <link>https://wushaoqiang.github.io/posts/leetcode-1/</link>
      <pubDate>Mon, 22 Apr 2019 00:19:11 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/leetcode-1/</guid>
      <description>题目 给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。
你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。
示例:
给定 nums = [2, 7, 11, 15], target = 9 因为 nums[0] + nums[1] = 2 + 7 = 9 所以返回 [0, 1]  我的解答 func twoSum(nums []int, target int) []int { myMap := make(map[int]int) for idx,num := range nums{ myMap[num] = idx } for idx,num := range nums{ tmp := target - num if pos,exist := myMap[tmp]; exist{ if idx &amp;gt; pos{ return []int{pos,idx} } else if idx &amp;lt; pos{ return []int{idx,pos} }else{ continue } } } return nil }  方法是通过map来达到快速查找，而不像暴力法需要每次都遍历整个数组</description>
    </item>
    
    <item>
      <title>Leetcode 7</title>
      <link>https://wushaoqiang.github.io/posts/leetcode-7/</link>
      <pubDate>Mon, 22 Apr 2019 00:19:11 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/leetcode-7/</guid>
      <description>题目 给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。 示例 1: 输入: 123 输出: 321 示例 2: 输入: -123 输出: -321 示例 3: 输入: 120 输出: 21 注意: 假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为 [−2^31, 2^31 − 1]。请根据这个假设，如果反转后整数溢出那么就返回 0。  我的解答 func reverse(x int) int { var rev int for x != 0 { lastNum := x % 10 x = x / 10 if rev &amp;gt; math.MaxInt32/10 || rev == math.MaxInt32/10 &amp;amp;&amp;amp; lastNum &amp;gt; 7 { return 0 } if rev &amp;lt; math.</description>
    </item>
    
    <item>
      <title>Leetcode 开篇</title>
      <link>https://wushaoqiang.github.io/posts/leetcode-before-start/</link>
      <pubDate>Mon, 22 Apr 2019 00:00:37 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/leetcode-before-start/</guid>
      <description> 不积跬步无以至千里，不积小流无以成江海
 作为Leetcode的开篇作，在这里希望自己能够坚持每天code一两道题(视难度而定)
以后博客应该是以这样的方式呈现
### 题目 ### 我的解答 ### 最优解答 ### 难疑点&amp;amp;核心  </description>
    </item>
    
    <item>
      <title>Golang Pipeline</title>
      <link>https://wushaoqiang.github.io/posts/golang-pipeline/</link>
      <pubDate>Sun, 21 Apr 2019 10:59:13 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/golang-pipeline/</guid>
      <description>根据官网博客学习Pipeline
什么是Pipeline 管道其实就是一系列的Channel连接起来
 通过channel(可能不止一个)来接收数据
 处理数据
 用Channel向下传递数据(也可能不止一个)
  代码演示 package main import ( &amp;quot;fmt&amp;quot; &amp;quot;sync&amp;quot; ) func main() { // Set up a done channel that&#39;s shared by the whole pipeline, // and close that channel when this pipeline exits, as a signal // for all the goroutines we started to exit. done := make(chan struct{}) defer close(done) in := gen(done, 2, 3) // Distribute the sq work across two goroutines that both read from in.</description>
    </item>
    
    <item>
      <title>Golang make vs new</title>
      <link>https://wushaoqiang.github.io/posts/golang-makevsnew/</link>
      <pubDate>Sun, 21 Apr 2019 00:30:06 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/golang-makevsnew/</guid>
      <description>make和new的对象  make只能对slice、map、channel作用，比如不能make(int)
 new可以对任何类型作用
  make和new的返回值  make返回主体
 new也是返回指针，比如new(int)，返回一个int的指针，这个指针的内容是0
  初始化 两者都会初始化为“0”值
总结 所以我觉得它们最大的区别还是返回值的区别，以及作用对象</description>
    </item>
    
    <item>
      <title>Golang Map</title>
      <link>https://wushaoqiang.github.io/posts/golang-map/</link>
      <pubDate>Sat, 20 Apr 2019 20:03:42 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/golang-map/</guid>
      <description>Construct: m:=map[key]value{}
 Insert: m[k] = v
 Lookup: v = m[k]
 Delete: delete(m,k)
 lterate: for k,v := range m
 Size: len(m)
  Key不能为 maps,slices,funcs. 因为它们不可比较
Map底层 map header
len lg(#buckets) bucket array hash seed  流程  接收到一个key
 对key进行hash
 通过hash找到是哪一个bucket
 取hash前8bit作为extra(作为快速检查)
 找到bucket的内存(对不同的类型，大小会有不同)
  扩容  新创建一个两倍的空间
 复制entries到新的bucket，但是这里的复制是递增式的，因为如果一次性将很大的数据复制到一块内存，它会很耗费时间，但是这种方法就代表着，在扩容的时候，查找会变得慢了，因为要查找两块内存空间。这也决定了我们不能直接用指针指向map的某一个value，因为这个value可能扩容后就不在那了
 用新的bucket
  和其它Map比较  Go map不能用指针指向单个value
 迭代的时候，go map是可以修改的</description>
    </item>
    
    <item>
      <title>Golang Channel</title>
      <link>https://wushaoqiang.github.io/posts/golang-channel/</link>
      <pubDate>Sat, 20 Apr 2019 17:19:20 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/golang-channel/</guid>
      <description>这里就不再赘述重要性了
Channel特性  goroutine-safe
 两个goroutine之间传递数据
 FIFO
 cause goroutine to block and unblock
  What is the inside of channel  mutex
 send-index and recieve index
 buf
  Create a channel ch := make(chan int,3) //buffered chan ch := make(chan int) //sync chan  ch is a pointer
How it work Send  When it is going to send data to the channel, it will acquire the lock because it is going to modify.</description>
    </item>
    
    <item>
      <title>Golang Interface</title>
      <link>https://wushaoqiang.github.io/posts/golang-interface/</link>
      <pubDate>Sat, 20 Apr 2019 13:36:59 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/golang-interface/</guid>
      <description>在说接口之前，我们先说一下类型，类型在Go语言里面可以大致分为
 concrete type(具体类型,int,string&amp;hellip;)
 abstract type(抽象类型 io.Writer,io.Reader&amp;hellip;)
  具体类型我们知道它到底长什么样子，比如说int64，我们知道它在底层有8个字节
抽象类型我们不知道或者说我们不关注它长什么样，但我们知道它的用处，比如io.Writer是用来写的
具体化谈Interface 举个非常简单的例子，我们在读文件的时候，可能会这样做
func main() { f, err := os.Open(&amp;quot;abc.txt&amp;quot;) if err != nil { fmt.Println(err) } byte, _ := ioutil.ReadAll(f) fmt.Println(string(byte)) }  看一下ioutil.ReadAll()
func ReadAll(r io.Reader) ([]byte, error) { return readAll(r, bytes.MinRead) }  这里需要传入的是一个io.Reader接口，为什么*File类型传入一样可以呢
这里io.Reader是一个接口，接口里面只要一个函数
type Reader interface { Read(p []byte) (n int, err error) }  而*File里面也实现了这个接口的函数
func (f *File) Read(b []byte) (n int, err error) { if err := f.</description>
    </item>
    
    <item>
      <title>Golang Tips</title>
      <link>https://wushaoqiang.github.io/posts/golang-tips/</link>
      <pubDate>Thu, 18 Apr 2019 22:56:20 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/golang-tips/</guid>
      <description>关于select case runtime.GOMAXPROCS(1) int_chan := make(chan int, 1) string_chan := make(chan string, 1) int_chan &amp;lt;- 1 string_chan &amp;lt;- &amp;quot;hello&amp;quot; select { case value := &amp;lt;-string_chan: fmt.Println(value) case value := &amp;lt;-int_chan: panic(value) }  上面代码两个case都满足，会伪随机的执行一个
关于defer func DeferCalc() { a := 1 b := 2 defer calc(&amp;quot;1&amp;quot;, a, calc(&amp;quot;10&amp;quot;, a, b)) a = 0 defer calc(&amp;quot;2&amp;quot;, a, calc(&amp;quot;20&amp;quot;, a, b)) b = 1 time.Sleep(1 * time.Second) } func calc(index string, a, b int) int { ret := a + b fmt.</description>
    </item>
    
    <item>
      <title>Algorithm 排序</title>
      <link>https://wushaoqiang.github.io/posts/algorithm-sort/</link>
      <pubDate>Mon, 15 Apr 2019 20:03:27 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/algorithm-sort/</guid>
      <description>排序时间复杂度 堆排序 参考dreamcatcher-cx博客
最好最坏的平均时间复杂度都为O(NlogN)
代码 func HeapSortUp(a []int) []int { for i := len(a)/2 - 1; i &amp;gt;= 0; i-- { adjustHeapUp(a, i, len(a)) } for j := len(a) - 1; j &amp;gt; 0; j-- { a[0], a[j] = a[j], a[0] adjustHeapUp(a, 0, j) } return a } func adjustHeapUp(a []int, i int, length int) { tmp := a[i] for k := 2*i + 1; k &amp;lt; length; k = 2*k + 1 { if k+1 &amp;lt; length &amp;amp;&amp;amp; a[k+1] &amp;gt; a[k] { k++ } if a[k] &amp;gt; tmp { a[i] = a[k] i = k } else { break } } a[i] = tmp }  思路  先将数组变换为一个大顶堆</description>
    </item>
    
    <item>
      <title>Golang Gin</title>
      <link>https://wushaoqiang.github.io/posts/golang-gin/</link>
      <pubDate>Sun, 14 Apr 2019 23:12:41 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/golang-gin/</guid>
      <description> 中间件 在Gin的中间件可以这样定义，这是Gin定义的中间件的接口
func JWT() gin.HandlerFunc { return func(c *gin.Context){ //这个就和我们平时编写的路由函数一样了 } }  然后利用Use()函数注册进去
gin函数 //这三步和gin.Default()返回的Engine一样,之说gin.Default()会有一个输出消息 debugPrintWARNINGDefault() r := gin.New() r.Use(gin.Logger()) r.Use(gin.Recovery()) gin.SetMode(setting.RunMode)  分组 apiv1 := r.Group(&amp;quot;/api/v1&amp;quot;)  gin.HandlerFunc func GetTags(c *gin.Context){ }  Context方法 </description>
    </item>
    
    <item>
      <title>Golang Validation</title>
      <link>https://wushaoqiang.github.io/posts/golang-validation/</link>
      <pubDate>Sun, 14 Apr 2019 14:43:43 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/golang-validation/</guid>
      <description>Validation项目地址
创建 valid := validation.Validation{}  Validation方法 valid是创建过的对象
 valid.Required(name,&amp;quot;name&amp;quot;)：检验变量不能为空，字符串不能为&amp;quot;&amp;quot;,后面的&amp;quot;name&amp;quot;是用来标识而已
 valid.MaxSize(name,100,&amp;quot;name&amp;quot;)：最大长度
 valid.Range(state,0,1,&amp;quot;state&amp;quot;)：范围
 valid.HasErrors()：这个会返回布尔值，是否有不符合限定的内容
 valid.Errors：这个是一个Error数组，其中Error是这个包自带的，并不是标准库的error
 valid.Min(id,1,&amp;quot;id&amp;quot;)：id最小为1
  以上这些都返回*Result
Result方法 我们拿上面一个返回*Result对象做例子
 valid.Required(name,&amp;quot;name&amp;quot;).Message(&amp;quot;name不能为空&amp;quot;)  当加了Message后，发生错误返回*Error对象，Error.key就是name Error.Message就是上面的信息</description>
    </item>
    
    <item>
      <title>Golang Build blog with gin</title>
      <link>https://wushaoqiang.github.io/posts/golang-blog/</link>
      <pubDate>Sun, 14 Apr 2019 13:47:15 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/golang-blog/</guid>
      <description> Package  ini &amp;mdash;配置文件的读取
 com &amp;mdash;功能性
 validation &amp;mdash;做验证
 jwt-go &amp;mdash;Token
 endless &amp;mdash;服务器热启动
 swag &amp;mdash;API文档
  </description>
    </item>
    
    <item>
      <title>Golang标准库--os</title>
      <link>https://wushaoqiang.github.io/posts/golangstd-os/</link>
      <pubDate>Fri, 12 Apr 2019 20:24:48 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/golangstd-os/</guid>
      <description>Open与OpenFile的区别 笔者在某天遇到一个情况，用Open打开文件并且想写入发生了错误
bad file descriptor  检查过后发现Open在底层是调用了OpenFile，并且默认是只读的形式
// Open opens the named file for reading. If successful, methods on // the returned file can be used for reading; the associated file // descriptor has mode O_RDONLY. // If there is an error, it will be of type *PathError. func Open(name string) (*File, error) { return OpenFile(name, O_RDONLY, 0) }  所以要是想要自己定义打开的文件限制的话，就用OpenFile吧
// Flags to OpenFile wrapping those of the underlying system.</description>
    </item>
    
    <item>
      <title>Golang Path Problem</title>
      <link>https://wushaoqiang.github.io/posts/golang-path-problem/</link>
      <pubDate>Fri, 12 Apr 2019 17:28:21 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/golang-path-problem/</guid>
      <description>笔者在学习的路上遇到了一些关于路径的奇怪问题，想着这个问题都埋了这么久了，赶紧出来总结一下，以防下次再出现这类型错误
直接用相对路径 在os.Open()直接输入相对路径，这个相对路径决定于你的工作目录，如果工作目录发生改变，就不行了
filepath.Abs() filepath.Abs()是根据当前工作目录返回的绝对路径，这个和上面的不同在于，这个可以打开工作目录之前的文件，而上面的只能打开后面的文件
所谓前后是值文件夹的前后
所以写在程序里面，你在这个目录执行成功了，你退一个目录就不行了，因为这个时候工作路径改变了
笔者感觉这种方法不安全，或者我们写应用的时候指定要在某某目录执行，我有见过类似的项目
同一目录下，package都为main，不能调用 如果我们有两个文件，package都为main，比如是这样的
-main.go | -file.go  main.go想调用file.go的函数，会返回未定义的错误
有两种解决方法
 go install Or go build 转换为二进制文件执行
 go run *.go Or go run main.go file.go 这个表达意思一样的，把包含的文件都包含进去
  解决相对路径的最稳的方法 来自外国友人icza</description>
    </item>
    
    <item>
      <title>Nice Sentences</title>
      <link>https://wushaoqiang.github.io/posts/nice-sentences/</link>
      <pubDate>Fri, 12 Apr 2019 16:13:54 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/nice-sentences/</guid>
      <description> Don&amp;rsquo;t assume that you are right, just because nobody has proved you wrong
The bigger the interface, the weaker the abstraction &amp;ndash;Rob Pike
 </description>
    </item>
    
    <item>
      <title>Opinion</title>
      <link>https://wushaoqiang.github.io/posts/opinion/</link>
      <pubDate>Fri, 12 Apr 2019 16:13:32 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/opinion/</guid>
      <description> 关于在百度搜索问题 笔者在很早就体会到一点，百度搜出来的东西，理论价值真的不高
我开发遇到Bug第一时间去的都是google，基本第一页搞定我的问题
我在安装东西，工具最基本的使用，我会百度，因为这些东西肯定一大堆人在写
这也让我开始反思，写博客的人，应该以一种什么样的心态去写呢？
下面我总结出了两个点
 理论性较强的文章，应该多权威性的网站或者论坛(比如stackoverflow这类型的)，对比大家的意见，再结合自己对这些的想法和理解，写出一篇有深度的文章，而不仅仅停留在发现问题&amp;ndash;解决问题&amp;ndash;完事
 工具类型的文章，为了让自己能够在忘记怎么使用某一个工具时翻阅，属于一种笔记类型，不算文章
  </description>
    </item>
    
    <item>
      <title>Golang Log</title>
      <link>https://wushaoqiang.github.io/posts/golang-log/</link>
      <pubDate>Fri, 12 Apr 2019 01:34:09 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/golang-log/</guid>
      <description>笔者上面总结了一下网上关于错误处理和异常处理的资料，发现不知道什么时候要记录一个信息，什么时候不应该，再去找找别人的经验，总结到这篇博客。当然，笔者对标准库的log的接口表示有点少，而且输出的信息看起来有点累(虽然很多人喜欢标准库的log，但这里不讨论这个)，我将尝试着用用第三方库
我们做后台开发，无论有什么语言，都有相应的一套日志记录系统，并且日志记录的信息可能是一些小小的问题，也可能是一些大问题，这个时候就要分级处理了，很多人(包括我之前)都对分级这个界限划分的认识模糊，不知道什么时候该用什么级别的信息
在很多时候，log给我们提供的级别种类非常多，例如info、warning、debug、error等等，其实我对这些有些难以区分
在一些论坛上，大家也为这些发表意见，都有各自的道理，我把我觉得有道理的记录下来，以后我就会按照这样的一套标准(并非所有人的标准)来实现我的日志记录
先讲标准，在来简单分析一下第三方库的使用
warning  Nobody needs a warning log level
 警告是什么意思？出错了吗，还是没出错，不知道，有点模棱两可的感觉
所以要么是正常的信息输出(INFO)，要么就是错误
其实笔者后来觉得，warning可以在下面情况使用
 对，是出错了，但是经过我们的错误处理，在合适的尝试次数中成功了，这样我们可以给出警告，告诉开发者，这里曾经出过错  fatal 首先，在Go里面，Fatal是会调用os.Exit(1)的
这代表着什么样的结果(灾难)呢
 在其它线程的defer没有得到调用(比如一个文件的关闭在defer里，这样这个文件就未关闭，程序就挂了)
 缓冲区没有刷新(flush)，我们都知道，缓冲区要刷新，数据才能真正流入到我们想它到达的地方
 临时文件或者文件夹不会被移除(程序可能会生成临时文件，这是我们在结果中不想要的东西)
   It is commonly accepted that libraries should not use panic, but if calling log.Fatal has the same effect, surely this should also be outlawed.
 网上看到别人这样说，称panic,fatal应该属于违规操作
stackoverflow上赞同较多的答案说
 You should assume that a panic will be immediately fatal, for the entire program, or at the very least for the current goroutine.</description>
    </item>
    
    <item>
      <title>Golang Errandpanic</title>
      <link>https://wushaoqiang.github.io/posts/golang-errandpanic/</link>
      <pubDate>Thu, 11 Apr 2019 21:28:42 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/golang-errandpanic/</guid>
      <description>笔者在自己做一个小项目的时候，从0开始写呀写呀写，忽然发现代码里充满了错误处理，异常处理，乱七八糟，心情非常不好，所以是时候学习一下这方面的知识了，于是在网上搜索别的博主的总结
本文参考了张伯雨的博客 飞雪无情的博客 外国友人的博客
直观理解 虽然我一开始也知道错误和异常是两码事，但我处理起来就把它们当成一码事了，这是不对的，我们先从直观上去判断什么是错误，什么是异常
错误是我们意料之中的，比如我们在做一个Get请求，我们知道这个操作是有可能发生错误的(比如超时等)，意料之中的事情
异常是我们意料之外的事情，比如空指针、数组越界等，程序在编译阶段是无法辨认出数组越界，或者空指针的
 but unable to check mistakes like an out-of-bounds array, access or nil pointer deference which require checks at run time
 defer 说到异常就要提一下defer，它是一个关键字，用于延迟函数的执行，我们常见的是
... defer file1.Close() defer file2.Close() ...  当一个函数触发panic，或者正常的return，总之它所在的函数执行完毕了，这个时候就轮到defer的函数了
并且它是按照一个栈的形式来执行，也就是先进后出，在上面的例子中，file2会比file1先执行Close()
如果是panic，那么这个panic将会一直被传递上去，直到最后一个defer执行完毕
同样的功能，不同的设计 比如说，许多标准库里的函数，会有两种设计
 一般设计，如果输入有误，则返回错误
 异常设计，如果输入有误，直接抛出异常
  怎么看都觉得第二种好恐怖啊，动不动就抛出异常
其实不然，我们在编写程序的时候，有些时候是硬编码的，也就是说这个部分是很大概率不会出错的，比如说我们在调用template标准库时，我们写好的网页(H5)，一般来说到上线的时候都是固定死了的,所以在读取模板的时候基本不会出错，这个时候就不用再写错误处理了
凡事要有规则 异常处理的作用域
 空指针引用
 下标越界
 除数为0
 不应该出现的分支，比如我们在switch的时候，没有一个符合，就会到default分支
 输入不应该引起函数错误
  错误处理正确姿势 1.失败原因只有一个时，不用error 比如只是一些简单的判断，这个时候输出bool会更好</description>
    </item>
    
    <item>
      <title>Golang Crawler</title>
      <link>https://wushaoqiang.github.io/posts/golang-crawler/</link>
      <pubDate>Thu, 11 Apr 2019 17:35:02 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/golang-crawler/</guid>
      <description>笔者最近用了几天时间用Golang写一个爬虫并且做数据分析，先记录一下用了哪些包，方便后面总结
goquery --处理HTML标签 viper --读取配置文件 go-echarts --图表显示 gorm --Mysql数据库 golang-proxy --代理IP pkg/errors --更好追踪错误 logrus --美化log lfhook --为了生成log本地文件，与logrus配合使用  过程中遇到的错误(不分顺序)
 first path segment in URL cannot contain colon 这里把IP地址当做协议了，但是程序一样能运行，只要在IP地址前面加上//即可，就像//127.0.0.1:1080
 invalid memory address or nil pointer dereference 在我把IP替换成代理后，出现了这个情况，初步估计是resp.Body搞的鬼，在后面我多尝试几次后，也成功过。我在这里的做法是将函数重新调用(递归)，设置好递归的最大次数，如果超过这个次数就终止，或者使用下面的错误处理
  defer func () { if resp != nil { resp.Body.Close() } }()  单元测试 func TestCrawler(t *testing.T) { // keywords := []string{&amp;quot;golang&amp;quot;, &amp;quot;java&amp;quot;} keywords := &amp;quot;golang,java&amp;quot; refresh := &amp;quot;on&amp;quot; value := url.</description>
    </item>
    
    <item>
      <title>Golang Handle</title>
      <link>https://wushaoqiang.github.io/posts/golang-handle/</link>
      <pubDate>Thu, 11 Apr 2019 11:14:34 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/golang-handle/</guid>
      <description>本文主要解释Golang中http-handler几个容易混淆的概念
HandleFunc 源代码
在源码文件(net/http/server.go)中定义了一个默认的路由管理器(Mux)，我们如果直接调用
http.HandleFunc(...)  其实就用了默认的路由管理器，然后通过这个默认的路由器来调用路由管理器的方法
当然我们也可以自己定义一个路由管理器，然后通过这个对象来调用这些方法,和调用默认Mux不同的是
myMux.HandleFunc(...)  来看一下源码的这两个函数，验证上面所说的。
// HandleFunc registers the handler function for the given pattern // in the DefaultServeMux. // The documentation for ServeMux explains how patterns are matched. func HandleFunc(pattern string, handler func(ResponseWriter, *Request)) { DefaultServeMux.HandleFunc(pattern, handler) }  利用DefaultServeMux来调用HandleFunc()方法
// HandleFunc registers the handler function for the given pattern. func (mux *ServeMux) HandleFunc(pattern string, handler func(ResponseWriter, *Request)) { if handler == nil { panic(&amp;quot;http: nil handler&amp;quot;) } mux.</description>
    </item>
    
    <item>
      <title>Golang goquery</title>
      <link>https://wushaoqiang.github.io/posts/golang-goquery/</link>
      <pubDate>Mon, 08 Apr 2019 23:10:14 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/golang-goquery/</guid>
      <description>goquery是一个开源的库，针对解析HTML
今天在做爬虫的时候用到了一些功能，记录下来方便查阅
创建Document对象 doc, err := goquery.NewDocumentFromReader(resp.Body) if err != nil { log.Fatalf(&amp;quot;go query Error %s\n&amp;quot;, err) }  doc对象就包含了我们要解析的HTML主体
一般我们这样用，Find()里面的字符串就是我们要填写的规则
doc.Find(&amp;quot;div&amp;quot;).Each(func(i int, s *goquery.Selection) { fmt.Println(i,s.Text()) })  规则 我们可以根据HTML的源码分析对应的属性id，class等等
 div#id #id是某个div的id属性，筛选出此id的div标签
 div.class .class 同理，是class属性
 div[class],div[lang] 这个也是属性的筛选
 div&amp;gt;p div嵌套的p标签，这里规定只有一级标签，一级以后的p标签不会被筛选出来
 div p div嵌套的p标签，这里无论第几级都会被筛选出来
  属性可以和嵌套一起使用，例如div.class&amp;gt;p&amp;gt;li
Size num := doc.Find(&amp;quot;ul&amp;gt;li&amp;gt;div.job-primary&amp;quot;).Size()  取出标签内的属性 doc.Find(&amp;quot;ul&amp;gt;li&amp;gt;div.job-primary&amp;gt;div&amp;gt;h3&amp;gt;a&amp;quot;).Each(func(i int, s *goquery.Selection) { detail := s.Get(0).Attr[0].Val // fmt.Println(i, nextPage) jobs[i].Detail = detail })  我在这里踩过一个坑</description>
    </item>
    
    <item>
      <title>Golangstd Request</title>
      <link>https://wushaoqiang.github.io/posts/golangstd-request/</link>
      <pubDate>Mon, 08 Apr 2019 11:37:38 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/golangstd-request/</guid>
      <description>最近笔者看了一些源代码，也找了一些Web示例跟着学习，这次是Go源代码的request.go的学习总结
我们知道，在处理Web后端的时候，都会有两个参数http.ResponseWriter和*http.Request
所以Request是我们处理用户请求的接口，学习这个对Web开发也相当重要
Request结构体 type Request struct { Method string URL *url.URL Proto string // &amp;quot;HTTP/1.0&amp;quot; ProtoMajor int // 1 ProtoMinor int // 0 Header Header Body io.ReadCloser GetBody func() (io.ReadCloser, error) ContentLength int64 TransferEncoding []string Close bool Host string Form url.Values PostForm url.Values MultipartForm *multipart.Form Trailer Header RemoteAddr string RequestURI string TLS *tls.ConnectionState Cancel &amp;lt;-chan struct{} Response *Response ctx context.Context }  下面详细介绍每个字段的意义
Method 这就是一个请求的方法(如GET、POST)
但是Go的HTTP客户端不支持发送方法为CONNECT的请求
URL  // URL specifies either the URI being requested (for server // requests) or the URL to access (for client requests).</description>
    </item>
    
    <item>
      <title>Golang Gorm</title>
      <link>https://wushaoqiang.github.io/posts/golang-gorm/</link>
      <pubDate>Fri, 05 Apr 2019 20:37:11 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/golang-gorm/</guid>
      <description>连接数据库 Mysql db, err := gorm.Open(&amp;quot;mysql&amp;quot;, &amp;quot;root:123456@tcp/test?charset=utf8&amp;amp;parseTime=True&amp;quot;) if err != nil { panic(&amp;quot;连接数据库失败&amp;quot;) } defer db.Close() db.SingularTable(true)  选定好数据库后一般会配上
db.SingularTable(true)  如果不调用这个函数，当在数据库加入某个表单的时候，名字会自动加一个s
比如db.CreateTable(&amp;amp;Product{})，在数据库表单里面会得到一个名字为products
所以一般都会加上这个函数
创建Table db.CreateTable(&amp;amp;Product{})  创建多个table
db.CreateTable(&amp;amp;Product{},&amp;amp;User{})  删除Table 关于删除，有两个
db.DropTableIfExist(interface{}) db.DropTable(interface{})  这里可以传入字符串，也可以传入一个结构体
接着上面的例子
db.DropTableIfExist(&amp;quot;product&amp;quot;) db.DropTableIfExist(&amp;amp;Product{})  删除Column 删除Column是要指定Table，所以不能这样
db.DropColumn(&amp;quot;created_at&amp;quot;)  要定位Table，则需要
db.Model(&amp;amp;Product).DropColumn(&amp;quot;created_at&amp;quot;)  创建数据 db.Create(&amp;amp;Product{Code: &amp;quot;L1213&amp;quot;, Price: 1002})  查询数据 // 最后一个符合条件，默认id最后的那个 // Get last record, order by primary key db.Last(&amp;amp;user) //// SELECT * FROM users ORDER BY id DESC LIMIT 1; // 将所有符合条件的返回，这里要传一个结构体数组 // Get all records db.</description>
    </item>
    
    <item>
      <title>Golang Viper</title>
      <link>https://wushaoqiang.github.io/posts/golang-viper/</link>
      <pubDate>Fri, 05 Apr 2019 17:41:18 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/golang-viper/</guid>
      <description>Github
 Viper is a complete configuration solution for Go applications
 这是一个帮组我们读取配置文件的包，总结一些方法，方便以后使用
Reading Config Files  a single Viper instance only supports a single configuration file
 一个Viper对象只能对应一个配置文件，是一个一一对应的映射关系
但是我们在搜索配置文件的时候，可以设置多个路径，如果没有设置路径，则当前程序的目录上寻找，所以我们要设置好路径
这是Github上的一个例子
viper.SetConfigName(&amp;quot;config&amp;quot;) // name of config file (without extension) viper.AddConfigPath(&amp;quot;/etc/appname/&amp;quot;) // path to look for the config file in viper.AddConfigPath(&amp;quot;$HOME/.appname&amp;quot;) // call multiple times to add many search paths viper.AddConfigPath(&amp;quot;.&amp;quot;) // optionally look for config in the working directory err := viper.</description>
    </item>
    
    <item>
      <title>Learn Gitflow</title>
      <link>https://wushaoqiang.github.io/posts/learn-gitflow/</link>
      <pubDate>Wed, 03 Apr 2019 23:27:50 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/learn-gitflow/</guid>
      <description>gitflow是一种规范，适合大项目开发
Github上开源了一个遵循这样规范的一个Git工具gitflow
初始化一个git git flow init  然后会提醒一系列创建操作，类似
Which branch should be used for bringing forth production releases? Branch name for production releases: [master] Which branch should be used for integration of the &amp;quot;next release&amp;quot;? Branch name for &amp;quot;next release&amp;quot; development: [develop] How to name your supporting branch prefixes? Feature branches? [feature/] Bugfix branches? [bugfix/] Release branches? [release/] Hotfix branches? [hotfix/] Support branches? [support/] Version tag prefix? [] Hooks and filters directory?</description>
    </item>
    
    <item>
      <title>Golang Mega</title>
      <link>https://wushaoqiang.github.io/posts/golang-mega/</link>
      <pubDate>Mon, 01 Apr 2019 15:12:46 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/golang-mega/</guid>
      <description>不积跬步无以至千里，不积小流无以成江海
 本文是博主在学习基础记录的笔记
2019-04-01到2019-04-04，后面会自己DIY一些内容上去(想做成一个小小的技术论坛)
先来总体看一下整个项目的目录吧
. ├── cmd │ └── db_init │ └── main.go ├── config │ └── g.go ├── config.yml ├── controller │ ├── g.go │ ├── home.go │ ├── middle.go │ └── utils.go ├── main.go ├── model │ ├── g.go │ ├── post.go │ ├── user.go │ └── utils.go ├── templates │ ├── 404.html │ ├── _base.html │ ├── content │ │ ├── explore.html │ │ ├── index.</description>
    </item>
    
    <item>
      <title>Questions Network</title>
      <link>https://wushaoqiang.github.io/posts/questions-network/</link>
      <pubDate>Tue, 26 Mar 2019 17:27:44 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/questions-network/</guid>
      <description>这篇文章是要记录在学习网络基础相关知识的时候遇到的问题与解答
IP Q: 为什么我电脑的IP(172.29.15.243)可以访问外面的网络
A: 我们知道某些专用网络的地址在外部是访问不到的，比如学校内部网不可以直接从外部访问，要通过VPN。我们之所以能够用专用网络分配给我们的地址访问外部网络，是因为我们在访问因特网时，IP地址会被NAT转换。
Session 在mega项目里遇到一个问题
首先，我访问服务器，服务器将会返回一个Session给我，那么我在这个网页游走都可以用这个Session，没毛病
现在我Logout，这个时候服务器调用函数将Session的期限变为-1，也就是将Session过期
这个时候我把之前服务器给我的Session自己存起来，用Postman构造一个请求，并且附上这个Session(其实是通过Cookie传)，这个时候服务器不会因为将Session期限改为-1而不认识这个Session
所以这个现象表明所谓的清除只是服务器给浏览器发送的Cookie期限设置为-1，然后浏览器看到Cookie已经过期了，因此就不用了
这样也就验证了，一个用户在服务器上只有一个Session id？
resp.Body resp, err := http.DefaultClient.Do(req) if err != nil { log.Fatalf(&amp;quot;Do Error %s\n&amp;quot;, err) } defer resp.Body.Close() body, err := ioutil.ReadAll(resp.Body) if err != nil { log.Fatalf(&amp;quot;ReadAll Error %s\n&amp;quot;, err) } // fmt.Println(string(body)) file, err := os.Create(path + keyword + &amp;quot;.html&amp;quot;) if err != nil { log.Fatalf(&amp;quot;Create File Error %s\n&amp;quot;, err) } defer file.Close() _, err = file.</description>
    </item>
    
    <item>
      <title>Golang标准库--http</title>
      <link>https://wushaoqiang.github.io/posts/golangstd-net-http/</link>
      <pubDate>Tue, 19 Mar 2019 20:52:05 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/golangstd-net-http/</guid>
      <description>这篇文章是为了探索Golang中net/http包的实现，笔者暂时只会把主要脉络摸清，具体某些实现逻辑暂不考究，是一篇比较基础的源码阅读文章。
Package http doc.go 先来看看官方对这个包的一个解释
这里说到，这个包是为HTTP提供客户端和服务器端的实现的。
这里还举了一些方法的例子
// Copyright 2011 The Go Authors. All rights reserved. // Use of this source code is governed by a BSD-style // license that can be found in the LICENSE file. /* Package http provides HTTP client and server implementations. Get, Head, Post, and PostForm make HTTP (or HTTPS) requests: resp, err := http.Get(&amp;quot;http://example.com/&amp;quot;) ... resp, err := http.Post(&amp;quot;http://example.com/upload&amp;quot;, &amp;quot;image/jpeg&amp;quot;, &amp;amp;buf) ... resp, err := http.</description>
    </item>
    
    <item>
      <title>一些名词的定义</title>
      <link>https://wushaoqiang.github.io/posts/definition/</link>
      <pubDate>Tue, 19 Mar 2019 20:07:44 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/definition/</guid>
      <description>这里是为了记录一些常用名词的定义，大多参照百度百科和Wiki
句柄 句柄是一种特殊的智能指针 。当一个应用程序要引用其他系统（如数据库、操作系统）所管理的内存块或对象时，就要使用句柄
在Golang里面，我们使用函数打开一个文件得到的就是一个文件句柄(打开的文件就是操作系统所管理的内存块)
在Golang里面，我们使用数据库的驱动连接数据库时，返回的也是一个句柄，这个返回值只是一个对象，并不是一个连接
Redis  redis是一个key-value存储系统。和Memcached类似，它支持存储的value类型相对更多，包括string(字符串)、list(链表)、set(集合)、zset(sorted set &amp;ndash;有序集合)和hash（哈希类型）。这些数据类型都支持push/pop、add/remove及取交集并集和差集及更丰富的操作，而且这些操作都是原子性的。在此基础上，redis支持各种不同方式的排序。与memcached一样，为了保证效率，数据都是缓存在内存中。区别的是redis会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件，并且在此基础上实现了master-slave(主从)同步。
 TLS  传输层安全性协议（英语：Transport Layer Security，缩写作TLS），及其前身安全套接层（Secure Sockets Layer，缩写作SSL）是一种安全协议，目的是为互联网通信提供安全及数据完整性保障。
安全传输层协议（TLS）用于在两个通信应用程序之间提供保密性和数据完整性。 该协议由两层组成： TLS 记录协议（TLS Record）和 TLS 握手协议（TLS Handshake）。
 Cookie&amp;amp;Session Cookie Cookie是客户端保持状态
Cookie的内容主要包括：名字，值，过期时间，路径和域
若不设置过期时间，则表示这个cookie的生命期为浏览器会话期间，关闭浏览器窗口，cookie就消失。这种生命期为浏览器会话期的cookie被称为会话cookie
Session Session是服务器端保持状态
一个用户在服务器上拥有唯一的一个session Id
如果一个用户不断在请求同一个东西或者行为异常(爬虫？)，则可以对这个用户进行相应操作
Session能够记录用户的动作，比如淘宝能够记录你购物车有多少东西
Difference 我们拿淘宝作例子
我们登录淘宝不用账号密码的时候用的就是Cookie
但是我们在挑选商品加入购物车，淘宝的服务器也在记录我们的动作信息(比如添加商品)，这个时候用的是Session
所以我们可以用Session来跟踪用户的动作。
安全性 Session会比Cookie安全，因为Cookie可能会被欺骗(Cookie在一定程度上就算是你的用户名和密码，被人获取后，别人就可以用你的身份来做事了)</description>
    </item>
    
    <item>
      <title>Golang Exercism</title>
      <link>https://wushaoqiang.github.io/posts/golang-exercism/</link>
      <pubDate>Sun, 17 Mar 2019 02:15:05 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/golang-exercism/</guid>
      <description>Exercism &amp;ndash; Bob 我的方法：(总之非常愚蠢就是了)
func Hey(remark string) string { // Write some code here to pass the test suite. // Then remove all the stock comments. // They&#39;re here to help you get started but they only clutter a finished solution. // If you leave them in, reviewers may protest! if strings.EqualFold(remark, &amp;quot;&amp;quot;) { return &amp;quot;Fine. Be that way!&amp;quot; } whitespace := true for _, item := range []byte(remark) { if !</description>
    </item>
    
    <item>
      <title>Mysql学习笔记</title>
      <link>https://wushaoqiang.github.io/posts/mysql-basic/</link>
      <pubDate>Sun, 17 Mar 2019 02:14:18 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/mysql-basic/</guid>
      <description>安装 sudo apt-get install mysql-server mysql-client
查询是否安装了： sudo netstat -tap grep mysql
安装成功
tcp 0 0 localhost:mysql 0.0.0.0:* LISTEN 31238/mysqld  整个安装过程没有叫输入密码
登录 打开debian.cnf文件： sudo nano /etc/mysql/debian.cnf
# Automatically generated for Debian scripts. DO NOT TOUCH! [client] host = localhost user = debian-sys-maint password = x7McPCywm2p7SsnZ socket = /var/run/mysqld/mysqld.sock [mysql_upgrade] host = localhost user = debian-sys-maint password = x7McPCywm2p7SsnZ socket = /var/run/mysqld/mysqld.sock  这里面有一个叫debian-sys-maint的user
登录debian-sys-maint： mysql -u debian-sys-maint -p</description>
    </item>
    
    <item>
      <title>Go圣经读书笔记</title>
      <link>https://wushaoqiang.github.io/posts/golang-bible/</link>
      <pubDate>Sun, 17 Mar 2019 02:13:08 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/golang-bible/</guid>
      <description>第一章 入门 命令行参数 os.Args变量是一个字符串的切片，并且它的第一个元素是命令本身的名字
func main() { var s, sep string for i := 0; i &amp;lt; len(os.Args); i++ { s += sep + os.Args[i] sep = &amp;quot; &amp;quot; } fmt.Println(s) }  运行go run main.go 123
输出/tmp/go-build115927302/b001/exe/main 123
查找重复的行  input := bufio.NewScanner(os.stdin) ~ func NewScanner(r io.Reader) *Scanner  返回一个从r读取的Scanner
 func (s *Scanner) Scan() bool  逐行扫描，当scan停止的时候，或者是到了读取的终点，又或者是发生了错误，这里都会返回false
 func (s *Scanner) Text() string  返回scanner所在行的文本
counts := make(map[string]int) input := bufio.</description>
    </item>
    
    <item>
      <title>Go语言实战</title>
      <link>https://wushaoqiang.github.io/posts/golang-inaction/</link>
      <pubDate>Sun, 17 Mar 2019 02:11:56 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/golang-inaction/</guid>
      <description>Go语言优点：
 Go语言可以说是夹在C/C++和Python这两类语言之间，即提供了较高的性能，又使得开发更加迅速了。
 Go语言内置并发机制，对并发有着更好的性能
 Go语言自带垃圾回收器
 goroutine使用的内存比线程要少，所以常常能够成千上万个goroutine并发
  第六章 并发 概念  进程：当运行一个应用程序时，操作系统会为这个应用程序启动一个进程，可以将这个进程看作一个包含了应用程序在运行中需要用到和维护的各种资源 线程：一个线程是一个空间，这个空间会被操作系统调度来运行函数中所写的代码，线程会被调度到CPU上运行。 每个逻辑处理器绑定在一个线程上 逻辑处理器可以调度goroutine 并发：某一个事情的停止，另一个事情就开始(单线程) 并行：同时开始做(多线程)  goroutine 一个创建goroutine的示例 package main import ( &amp;quot;fmt&amp;quot; &amp;quot;runtime&amp;quot; &amp;quot;sync&amp;quot; ) // main is the entry point for all Go programs. func main() { // Allocate 1 logical processor for the scheduler to use. runtime.GOMAXPROCS(1) // wg is used to wait for the program to finish. // Add a count of two, one for each goroutine.</description>
    </item>
    
    <item>
      <title>Go语言高级编程</title>
      <link>https://wushaoqiang.github.io/posts/golang-highlevel/</link>
      <pubDate>Sun, 17 Mar 2019 02:09:45 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/golang-highlevel/</guid>
      <description>感谢 在文章开头感谢两位作者:柴树杉和曹春晖
这篇文章是开源的，欢迎大家去阅读
本篇博客是笔者对这篇文章的理解，引用的图片也是来自原文，如有侵权请告知！
第一章 基础 1.3 数组、字符串和切片  Go语言的数组是一种值类型，虽然数组的元素可以被修改，但是数组本身的赋值和函数传参都是以整体复制的方式处理的
 Go语言字符串底层数据也是对应的字节数组，但是字符串的只读属性禁止了在程序中对底层字节数组的元素的修改字符串赋值只是复制了数据地址和对应的长度，而不会导致底层数据的复制
 切片头含有底层数据的指针，所以它的赋值也不会导致底层数据的复制
  字符串  字符串的元素不可修改，是一个只读的字节数组
 字符串虽然不是切片，但是支持切片操作
type StringHeader struct { Data uintptr Len int }  字符串结构由两个信息组成：第一个是字符串指向的底层字节数组，第二个是字符串的字节的长度。
  切片 type SliceHeader struct { Data uintptr Len int Cap int }  a = append(a, 0) // 切片扩展1个空间 copy(a[i+1:], a[i:]) // a[i:]向后移动1个位置 a[i] = x // 设置新添加的元素  copy将a[i:]直接搬到了a[i+1:]这个时候就可以在a[i]插入
这种做法可以减少中间创建的临时切片
copy append可以完成切片的添加 删除 插入操作</description>
    </item>
    
    <item>
      <title>Golang--Leetcode</title>
      <link>https://wushaoqiang.github.io/posts/golang-leetcode/</link>
      <pubDate>Sun, 17 Mar 2019 02:07:37 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/golang-leetcode/</guid>
      <description>此文章为做题时发现的不足
 Go语言中的结构体直接赋值是==值传递==，如果要用引用传递，需要这样struct1 := &amp;amp;struct2，也就是要使用取地址符号。但是如果本来struct2就是一个指针，那么就可以直接赋值了。 go func addTwoNumbers(l1 *ListNode, l2 *ListNode) *ListNode { Head := ListNode{} curr := &amp;amp;Head  &amp;mdash;-  给定一个字符串，找出其中不含有重复字符的最长子串的长度方法 - 穷举法：
func lengthOfLongestSubstring(s string) int { var max = 0 for i := 0; i &amp;lt; len(s); i++ { m := make(map[string]bool) for j := i; j &amp;lt; len(s); j++ { if _, ok := m[s[j:j+1]]; !ok { m[s[j:j+1]] = true if j == len(s)-1 { if max &amp;lt; j-i+1 { max = j - i + 1 } } } else { if max &amp;lt; j-i { max = j - i } break } } } return max }   另一个方法： ```go func lengthOfLongestSubstring(s string) int { var max = 0 i := 0 m := make(map[string]int) for j := 0; j &amp;lt; len(s); j++ {  	if _, ok := m[s[j:j+1]]; ok {</description>
    </item>
    
    <item>
      <title>Golang标准库--Unicode</title>
      <link>https://wushaoqiang.github.io/posts/golangstd-unicode/</link>
      <pubDate>Sun, 17 Mar 2019 02:06:01 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/golangstd-unicode/</guid>
      <description>unicode package utf8 utf8.go 这里就不详细分析源码了，只说函数的作用
&amp;mdash; FullRune(p []byte) bool  FullRune报告p中的字节是否以一个rune的完整UTF-8编码开始。
 无效的编码被认为是完整的rune，因为它将转换为宽度为1的错误符文rune。
&amp;mdash; FullRuneInString(s string) bool 和FullRune一样，只是传入了字符串
&amp;mdash; DecodeRune(p []byte) (r rune, size int) 这个函数将切片p中第一个rune返回，并且返回这个rune的大小。
如果p是空的，那么会返回RuneError,0
如果切片中的编码是无效的，那么会返回RuneError,1,对应上一个函数，当编码无效时依然返回true
&amp;mdash; DecodeRuneInString(s string) (r rune, size int) 同上，只是参数变成了字符串
&amp;mdash; func DecodeLastRune(p []byte) (r rune, size int) 只是从后面开始了，功能一样。
&amp;mdash; DecodeLastRuneInString(s string) (r rune, size int) 如上，参数换了字符串
&amp;mdash; RuneLen(r rune) int 返回一个rune的长度，也就是其大小
&amp;mdash; EncodeRune(p []byte, r rune) int 这个就是将rune写入到byte切片上
&amp;mdash; RuneCount(p []byte) int 返回整个切片里面rune的个数</description>
    </item>
    
    <item>
      <title>Golang标准库--String</title>
      <link>https://wushaoqiang.github.io/posts/golangstd-string/</link>
      <pubDate>Sun, 17 Mar 2019 02:04:07 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/golangstd-string/</guid>
      <description>目录 strings builder.go Builder 结构体 noescape(p unsafe.Pointer) unsafe.Pointer &amp;amp; copyCheck() (b *Builder) String() string &amp;amp; (b *Builder) Len() int &amp;amp; (b *Builder) Reset() (b *Builder) Grow(n int) 关于Write的方法 reader.go Reader 结构体 (r *Reader) Len() int &amp;amp; (r *Reader) Size() int64 关于读的方法 (r *Reader) UnreadRune() error (r *Reader) Seek(offset int64, whence int) (int64, error) strings.go  strings builder.go Builder 相当于bytes里面的buffer，并且方法也差不多。但是buffer更加全面
&amp;mdash; 结构体 // A Builder is used to efficiently build a string using Write methods.</description>
    </item>
    
    <item>
      <title>Golang标准库--Bytes</title>
      <link>https://wushaoqiang.github.io/posts/golangstd-bytes/</link>
      <pubDate>Sun, 17 Mar 2019 02:03:03 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/golangstd-bytes/</guid>
      <description>目录 bytes buffer.go Buffer 结构体 const of readOp (b *Buffer) Bytes() []byte (b *Buffer) String() string (b *Buffer) empty() bool (b *Buffer) Len() int (b *Buffer) Cap() int (b *Buffer) Truncate(n int) (b *Buffer) Reset() (b *Buffer) tryGrowByReslice(n int) (int, bool) (b *Buffer) grow(n int) int (b *Buffer) Grow(n int) (b *Buffer) Write(p []byte) (n int, err error) (b *Buffer) WriteString(s string) (n int, err error) makeSlice(n int) []byte (b *Buffer) WriteTo(w io.</description>
    </item>
    
    <item>
      <title>Golang标准库--Bufio</title>
      <link>https://wushaoqiang.github.io/posts/golangstd-bufio/</link>
      <pubDate>Sun, 17 Mar 2019 01:59:52 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/golangstd-bufio/</guid>
      <description>目录 bufio bufio.go 常量 Reader 结构体 常量 NewReaderSize(rd io.Reader, size int) *Reader NewReader(rd io.Reader) *Reader (r *Reader) Size() int (b *Reader) Reset(r io.Reader) &amp;amp; (b *Reader) reset(buf []byte, r io.Reader) (b *Reader) fill() (b *Reader) Peek(n int) ([]byte, error) (b *Reader) Discard(n int) (discarded int, err error) (b *Reader) Read(p []byte) (n int, err error) (b *Reader) ReadByte() (byte, error) (b *Reader) UnreadByte() (b *Reader) ReadRune() (r rune, size int, err error) (b *Reader) UnreadRune() error (b *Reader) Buffered() int (b *Reader) ReadSlice(delim byte) (line []byte, err error) (b *Reader) ReadLine() (line []byte, isPrefix bool, err error) (b *Reader) ReadBytes(delim byte) ([]byte, error) (b *Reader) ReadString(delim byte) (string, error) (b *Reader) WriteTo(w io.</description>
    </item>
    
    <item>
      <title>网络协议基础</title>
      <link>https://wushaoqiang.github.io/posts/internet-protocal/</link>
      <pubDate>Sun, 17 Mar 2019 01:58:00 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/internet-protocal/</guid>
      <description>OSI模型把网络通信的工作分为7层，分别是物理层、数据链路层、网络层、传输层、会话层、表示层和应用层
一直觉得自己的基础很不牢固，事实也确实是这样，希望自己能够系统的总结好计算机网络这本书
二、应用层 Web、电子邮件、DNS和对等文件分发等
2.1 应用层协议原理 2.1.1 网络应用程序体系结构 应用程序体系结构
 客户-服务器体系结构
 对等体系结构(P2P)
  现在大多数应用都是以客户-服务器体系结构
P2P面临的挑战
 下载比上传多很多
 安全性
 用户是否能自愿提供带宽、存储和计算资源
  最近比较火的一个名词区块链就是倡导去中心化的网络，也就是P2P
2.1.2 进程通信 在同一个端系统上(可以理解为同一部电脑)，进程间通信的规则由端系统上的操作系统决定
在不同端系统上，通过跨越计算机网络交换报文来相互通信
2.1.2.1 客户和服务器进程 发起通信的进程就是客户
等待联系的进程是服务器
2.1.2.2 进程与计算机网络之间的接口 进程通过一个称为套接字的软件接口向网络发送报文和从网络接收报文
这个套接字就好比如一个房子的大门，发送或者接收都要先开门
而这里把进程比作房子，运输层协议(TCP等)比作两个房子的路
所以套接字是应用层和运输层的接口，也叫应用程序编程接口(API)
2.1.2.3 进程寻址 主机由IP地址标识
指定的进程由端口号标识
2.1.3 可供应用程序使用的运输服务 根据运输层所提供的服务来决定用哪种运输层协议
2.1.3.1 可靠数据传输 当一个运输协议提供这种服务时，发送进程只要将其数据传递进套接字，就可以完全相信该数据将能无差错地到达接收进程
有些能够容忍数据丢失的应用可以不使用可靠数据传输
2.1.3.2 吞吐量 吞吐量就是发送进程能够向接收进程交付比特的速率
具有吞吐量要求的应用被称为带宽敏感应用
否则就称为弹性应用
2.1.3.3 定时 对于实时要求较高的应用
2.1.3.4 安全性 防止数据以某种方式在两个进程之间被观察到
安全包括
 机密性
 完整性
 端点鉴别</description>
    </item>
    
    <item>
      <title>Web框架</title>
      <link>https://wushaoqiang.github.io/posts/web-strcuture/</link>
      <pubDate>Sun, 17 Mar 2019 01:53:57 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/web-strcuture/</guid>
      <description>这篇文章是参考人世间博主写的一篇文章，这里哪里作为自己了解Gin框架的例子，笔者想在这做初步了解后再去深入了解源码，到时候再写一篇博客来说说Gin源码。
Gin 路由常用方法 func (group *RouterGroup) POST(relativePath string, handlers ...HandlerFunc) IRoutes func (group *RouterGroup) GET(relativePath string, handlers ...HandlerFunc) IRoutes type HandlerFunc func(*Context)  可以看出路由需要的参数是
 相对路径
 处理函数
  这里面是Gin自己定义的一个HandlerFunc，和标准库里面的有所不同，这里的gin.*Context包含了标准库里的ResponseWriter和*http.Request还有一些其它
介绍一些函数 // Query()	是匹配url上的参数，匹配不到就返回空字符串 // DefaultQuery() 也是匹配，如果匹配不到就用默认值 // 127.0.0.1:8000/post?id=111&amp;amp;page=222 // 如果用curl，则需要在&amp;amp;前面加\ id := c.Query(&amp;quot;id&amp;quot;) page := c.DefaultQuery(&amp;quot;page&amp;quot;, &amp;quot;0&amp;quot;) //这个是在表单上获取信息，通过POST方法发送过来的数据 name := c.PostForm(&amp;quot;name&amp;quot;) message := c.PostForm(&amp;quot;message&amp;quot;)  一个完整的路由 router.GET(&amp;quot;/welcome&amp;quot;, func(c *gin.Context) { firstname := c.DefaultQuery(&amp;quot;firstname&amp;quot;, &amp;quot;Guest&amp;quot;) lastname := c.Query(&amp;quot;lastname&amp;quot;) c.</description>
    </item>
    
    <item>
      <title>Linux命令笔记</title>
      <link>https://wushaoqiang.github.io/posts/linux-note/</link>
      <pubDate>Sun, 17 Mar 2019 01:52:15 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/linux-note/</guid>
      <description>Command 这里只是笔者对Linux常用命令的笔记，方便自己查询
ifconfig 查看网络连接
lsof -i:8000 查看端口8000占用情况
kill -9 PID 把某个PID的进程结束了，kill还有许多flag，1:挂起， 2:中断 ，3:退出
mkdir -p /1/2/3/4 可以一次创建多层文件夹
pkill -f &amp;lt;name&amp;gt; 可以直接kill掉一个已知名字的进程
把脚本放进/etc/init.d/里面就可以自启动
chown user:group &amp;lt;file&amp;gt; 改变文件持有
磁盘 du -hsc &amp;lt;path&amp;gt; 查看路径占用磁盘大小
ncdu 更友好的查看磁盘占用情况的一个命令，需要安装
df -h查看磁盘占用情况
别名 alias &amp;lt;name&amp;gt;=&amp;quot;&amp;lt;command&amp;gt;&amp;quot; 用别名调用命令(适用于长命令)，如果需要持久化的话，需要写入.bashrc
查找文件 find &amp;lt;path&amp;gt; -name &amp;quot;*.log&amp;quot; 寻找在路径里面结尾为.log的文件，同理，想要查找一类文件可以用这个命令
find &amp;lt;path&amp;gt; ! -name &amp;quot;*.log&amp;quot; 与上面刚好相反
find -mtime &amp;lt;number&amp;gt;这个命令还可以根据修改时间
匹配 grep -r &amp;quot;error&amp;quot; &amp;lt;path or file&amp;gt; 会打印出所有含有error的字段
查看CPU&amp;amp;内存占用情况 top 这个命令对界面不太友好
htop 这个对阅读更加友好
update 能够看到电脑持续开机时间</description>
    </item>
    
    <item>
      <title>Hugo建博客</title>
      <link>https://wushaoqiang.github.io/posts/learn-hugo/</link>
      <pubDate>Sat, 16 Mar 2019 22:33:20 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/learn-hugo/</guid>
      <description>笔者用的是Hugo来搭建个人博客，表示Hugo实在太强，而且可扩展性很高，这也代表文档也很长。。。
所以笔者收录一些比较常用的作为笔记，也希望能够帮到别人
以下命令都是以我自己建博客的为例
创建一个网站 hugo new site blog 这个命令会在目录里创建一个新的blog目录
这个blog目录包含以下：
 archetypes/ content/ data/ layouts/ static/ themes/ config.toml  archetypes/ 这里一开始会有一个default文件，后面再讲有什么用，先看看文件
--- title: &amp;quot;{{ replace .Name &amp;quot;-&amp;quot; &amp;quot; &amp;quot; | title }}&amp;quot; date: {{ .Date }} draft: true ---  content/ 这里就是博客的主要内容的根目录，我们创建的博客文章就应该放在这个文件夹里(不是直接)
创建一个博客文章hugo new posts/learn-hugo.md，创建完后会发现文件在content/posts/learn-hugo.md
打开文件看一下，可以发现创建的新文件里面是有内容的
--- title: &amp;quot;Learn Hugo&amp;quot; date: 2019-03-16T22:33:20+08:00 draft: true ---  这就和我们上面说到的archetypes/default.md有关，这里可以自动填充一些信息，方便我们写博客
theme/ 这里是放置博客主题的文件夹，Hugo有很多开源的主题，可以去官网找找看，笔者用的是飞雪无情这位博主开源出来的Maupassant，笔者刚开始也按照这位博主的配置方法来配置博客，等后面对Hugo的配置了解更加深入时，再尝试配置。Maupassant的仓库地址，大家还可以顺手点个星，表示支持
具体如何安装也很简单，可以参照github的使用方法
config.toml 这个文件是配置我们的一些博客信息以及Hugo的配置
## 这个是我们主页的地址 baseURL = &amp;quot;https://wushaoqiang.github.io&amp;quot; languageCode = &amp;quot;en-us&amp;quot; ## 博客的标题(不是某篇文章，是整个博客) title = &amp;quot;Gavin&#39;s Blog&amp;quot; ## 这里就是设定你要的主题，而且主题必须要下载到theme/目录 theme = &amp;quot;maupassant&amp;quot; ## 保持分类的原始名字（false会做转小写处理） preserveTaxonomyNames = true ## 是否禁止URL Path转小写 disablePathToLower = true ## 这个会配置每一篇文章最后面的Copyright的作者名字 ## © 2019 Gavin&#39;s Blog By Gavin [author] name = &amp;quot;Gavin&amp;quot; [params] author = &amp;quot;Gavin&amp;quot; ## 这是一个副标题，在主标题的下方 subtitle = &amp;quot;Gopher，后端开发，网络基础，WEB协议、架构、存储、缓冲、安全，学习笔记&amp;quot; keywords = &amp;quot;Golang,Gavin,Blog&amp;quot; ## 这个是对阅读量的计数 busuanzi = true ## 这个是为了开评论区 [params.</description>
    </item>
    
    <item>
      <title>Git用法总结</title>
      <link>https://wushaoqiang.github.io/posts/learn-git/</link>
      <pubDate>Fri, 15 Mar 2019 18:02:59 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/learn-git/</guid>
      <description>这篇博客是笔者总结学习git的过程，不是一篇专业性很强的文章，主要是笔记
主要参考廖雪峰的博客学习
笔者之前对Git有错误的理解(因为之前没学过，也只是听过)，总以为Github就是Git，其实Github是Git出来后才被创建的，为开源项目免费提供Git存储。
无Github,纯属本地的Git &amp;mdash; 那么什么是Git呢？ Git是目前世界上最先进的分布式版本控制系统
分布式：Git和其它集中式版本控制系统最大的区别，Git也可以有一个24小时开机的服务器来充当中央服务器，但这个服务器仅仅是为了让大家方便交换各自修改的。
版本控制：因为我们的代码要不断的完善，所以就有版本之分啦。
就算是我们自己在电脑上开发，也可以为自己代码创建版本库，用来记录修改和方便管理。
&amp;mdash; 创建版本库 在想要创建版本库的文件夹里面，输入命令
git init  就可以看到文件夹里面多了一个隐藏的文件夹.git
添加文件到我们新建的版本库里面用
//将某一个文件添加进缓冲区 git add &amp;lt;file&amp;gt; //将.git文件夹 所在的文件 里所有的文件添加进缓冲区 //所以不管你是在某一个子文件夹用这个命令，执行效果是一样的 git add -A //这个就是将缓冲区的提交到版本库里，并且携带提交信息 //(强烈推荐要写message，这样可以提醒那个时候修改了什么) git commit -m &amp;lt;message&amp;gt;  我们可以把代码所在区域分成
 工作区 缓冲区 当前分支  理解这几个工作区域会有助于理解命令的作用。
工作区：我们自己电脑编辑代码的地方
缓冲区：就是我们把修改过的文件放到一个区域装着，如果后面我又对这个文件做修改了，就可以继续往里面添加(同文件覆盖)
当前分支：就是我们使用commit后将缓冲区的文件提交上去的地方
&amp;mdash; 查看状态 git status  这个命令会告诉我们哪些被修改过的文件被添加到了缓冲去，哪些被修改的文件没有。
On branch master Your branch is behind &#39;origin/master&#39; by 1 commit, and can be fast-forwarded. (use &amp;quot;git pull&amp;quot; to update your local branch) Untracked files (use &amp;quot;git add &amp;lt;file&amp;gt;.</description>
    </item>
    
    <item>
      <title>Go琐碎笔记</title>
      <link>https://wushaoqiang.github.io/posts/learningGo/</link>
      <pubDate>Thu, 14 Mar 2019 16:10:59 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/learningGo/</guid>
      <description>在test文件要是以_test.go结尾，或者是在文件开头加上// +build (tag) 其中tag是自己定的，然后测试的时候在Terminal输入
2019.2.16 go test -tags tagname
构造数组可以先 make([]int,0)
然后 再使用函数：func append(slice []Type, elems ...Type) []Type
unicode.IsLetter(r rune) bool是判断是否为字母，而不是ASCII
res, ok := map[...] 中的ok变量可以用来判断key是否存在
[]rune可以直接转换为字符串string([]rune)
2019.2.17 谨记！ ： 切片和Map在函数传递都是指针传递(引用)
func normalize(cleartext string) string { var b strings.Builder for _, r := range cleartext { if unicode.IsLetter(r) || unicode.IsDigit(r) { b.WriteRune(unicode.ToLower(r)) } } return b.String() }  b.WriteRune(unicode.ToLower(r)) :可以用这种方式代替append()
norm = fmt.Sprintf(&amp;quot;%-[1]*s&amp;quot;, c*r, norm): 其实就是将出c*r代入到[1]*形成的在右侧填充空格
|类型 |默认值 | |int | 0 | |string|“” | | bool | false |  定义一个常量：const name type = value value是必须要有的 枚举：Go没有枚举，用const构造，有两种方法(参考这里的)</description>
    </item>
    
  </channel>
</rss>