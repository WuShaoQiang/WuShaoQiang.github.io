<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on Gavin&#39;s Blog</title>
    <link>https://wushaoqiang.github.io/posts/</link>
    <description>Recent content in Posts on Gavin&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 29 Apr 2019 00:38:18 +0800</lastBuildDate>
    
	<atom:link href="https://wushaoqiang.github.io/posts/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Leetcode 121</title>
      <link>https://wushaoqiang.github.io/posts/leetcode-121/</link>
      <pubDate>Mon, 29 Apr 2019 00:38:18 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/leetcode-121/</guid>
      <description>题目 Say you have an array for which the ith element is the price of a given stock on day i. If you were only permitted to complete at most one transaction (i.e., buy one and sell one share of the stock), design an algorithm to find the maximum profit. Note that you cannot sell a stock before you buy one. Example 1: Input: [7,1,5,3,6,4] Output: 5 Explanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.</description>
    </item>
    
    <item>
      <title>Leetcode 119</title>
      <link>https://wushaoqiang.github.io/posts/leetcode-119/</link>
      <pubDate>Mon, 29 Apr 2019 00:38:14 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/leetcode-119/</guid>
      <description>题目 Given a non-negative index k where k ≤ 33, return the kth index row of the Pascal&#39;s triangle. Note that the row index starts from 0. In Pascal&#39;s triangle, each number is the sum of the two numbers directly above it. Example: Input: 3 Output: [1,3,3,1] Follow up: Could you optimize your algorithm to use only O(k) extra space?  我的解答 func getRow(rowIndex int) []int { result := make([]int, rowIndex+1) result[0] = 1 for i := 0; i &amp;lt; rowIndex; i++ { result[i+1] = result[i] for j := i; j &amp;gt; 0; j-- { result[j] = result[j] + result[j-1] } } return result }  最优解答 无</description>
    </item>
    
    <item>
      <title>Leetcode 118</title>
      <link>https://wushaoqiang.github.io/posts/leetcode-118/</link>
      <pubDate>Mon, 29 Apr 2019 00:38:11 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/leetcode-118/</guid>
      <description>题目 Given a non-negative integer numRows, generate the first numRows of Pascal&#39;s triangle. In Pascal&#39;s triangle, each number is the sum of the two numbers directly above it.  我的解答 func generate(numRows int) [][]int { if numRows == 0 { return nil } result := make([][]int, numRows) for i := 0; i &amp;lt; numRows; i++ { result[i] = make([]int, i+1) result[i][0] = 1 result[i][i] = 1 for j := 1; j &amp;lt; i; j++ { result[i][j] = result[i-1][j-1] + result[i-1][j] } } return result }  最优解答 无</description>
    </item>
    
    <item>
      <title>Leetcode 112</title>
      <link>https://wushaoqiang.github.io/posts/leetcode-112/</link>
      <pubDate>Mon, 29 Apr 2019 00:38:06 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/leetcode-112/</guid>
      <description>题目 Given a binary tree and a sum, determine if the tree has a root-to-leaf path such that adding up all the values along the path equals the given sum. Note: A leaf is a node with no children. Example: Given the below binary tree and sum = 22, 5 / \ 4 8 / / \ 11 13 4 / \ \ 7 2 1 return true, as there exist a root-to-leaf path 5-&amp;gt;4-&amp;gt;11-&amp;gt;2 which sum is 22.</description>
    </item>
    
    <item>
      <title>Leetcode 111</title>
      <link>https://wushaoqiang.github.io/posts/leetcode-111/</link>
      <pubDate>Mon, 29 Apr 2019 00:38:02 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/leetcode-111/</guid>
      <description>题目 Given a binary tree, find its minimum depth. The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node. Note: A leaf is a node with no children. Example: Given binary tree [3,9,20,null,null,15,7], 3 / \ 9 20 / \ 15 7 return its minimum depth = 2.  我的解答 func minDepth(root *TreeNode) int { return findMinDepth(root) } func findMinDepth(root *TreeNode) int { if root == nil { return 0 } return 1 + min(findMinDepth(root.</description>
    </item>
    
    <item>
      <title>Leetcode 110</title>
      <link>https://wushaoqiang.github.io/posts/leetcode-110/</link>
      <pubDate>Mon, 29 Apr 2019 00:38:00 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/leetcode-110/</guid>
      <description>题目 Given a binary tree, determine if it is height-balanced. For this problem, a height-balanced binary tree is defined as: a binary tree in which the depth of the two subtrees of every node never differ by more than 1. Example 1: Given the following tree [3,9,20,null,null,15,7]: 3 / \ 9 20 / \ 15 7 Return true. Example 2: Given the following tree [1,2,2,3,3,null,null,4,4]: 1 / \ 2 2 / \ 3 3 / \ 4 4 Return false.</description>
    </item>
    
    <item>
      <title>TenToSeventeen</title>
      <link>https://wushaoqiang.github.io/posts/tenToSeventeen/</link>
      <pubDate>Sun, 28 Apr 2019 16:25:41 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/tenToSeventeen/</guid>
      <description>代码 func findHighBit(num int) (tmp, b int) { tmp = 1 b = 0 for { if tmp*16 &amp;gt; num { return tmp, b } tmp = tmp * 16 b++ } } func tenToSeventeen(num int) []int { tmp, b := findHighBit(num) result := make([]int, 0) for i := b; i &amp;gt;= 0; i-- { j := 0 for { if tmp*j &amp;lt;= num { j++ } else { break } } result = append(result, j-1) num = num - tmp*(j-1) tmp = tmp / 16 } return result } func intToString(result []int) []string { strs := make([]string, 0) for _, num := range result { switch { case num &amp;lt; 10: strs = append(strs, strconv.</description>
    </item>
    
    <item>
      <title>Data Structure</title>
      <link>https://wushaoqiang.github.io/posts/data-structure/</link>
      <pubDate>Sun, 28 Apr 2019 11:03:57 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/data-structure/</guid>
      <description> 前段时间复习了一些数据结构，一直没来得及总结一下
链表(双向) 单向链表和循环链表思路是差不多的
结构体 type LinkListNode struct { Value interface{} Next *LinkListNode Prev *LinkListNode } type LinkList struct { len int head *LinkListNode tail *LinkListNode }  </description>
    </item>
    
    <item>
      <title>Web请求历程</title>
      <link>https://wushaoqiang.github.io/posts/web-request-process/</link>
      <pubDate>Sun, 28 Apr 2019 10:19:02 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/web-request-process/</guid>
      <description>这几乎是做后端开发面试的时候必问的一道题，答案可以说得很简单，也可以是很复杂，当然面试官喜欢看到你对此有所深入，因此这篇文章就从头到尾详细的讲一遍这个历程
参考 《计算机网络》
1 当一台电脑将网线插上，网线的另一端是以太网的交换机(交换机能够知道连接它的机器的MAC地址，如果不清楚交换机是什么，建议自己搜一下，这里不做解释)
首先，刚开始电脑是没有IP地址的，这个时候电脑会生成一个DHCP请求报文，这个报文是一个UDP报文，目的端口为67，源端口为68。这个UDP报文被装载到IP报文，有目的IP地址是255.255.255.255，因为电脑不知道可以从哪个IP请求到自己的IP地址，源IP地址是0.0.0.0。再次往下传递就到了链路层，我们这里假设用的是以太网，所以链路层会将网络层的数据包放置在以太网帧中，目的MAC地址为FF:FF:FF:FF:FF:FF，源MAC地址就是你电脑网卡的MAC地址了，这个我们不用关心。这个时候一个广播的报文就做好了
报文被发送到交换机上，因为这是一个广播报文，因此在交换机上连接的所有设备都应该能收到这个报文，包括了DHCP服务器
这里说多一句，现阶段，一般DHCP服务器集成在了路由器上，而这个路由器一般来说是我们的网关(至少在我这边是这样的)，具体如何查的，用wireshark抓包看看吧，抓到DHCP包你就知道了(记得先拔网线再插上)
2 我们假设这个DHCP包已经完整到达了路由，这个路由生成了一个UDP-IP-以太网报文，这个时候数据报里包含了
 分配给电脑的IP
 DNS服务器IP
 默认网关路由器IP
 网络掩码
  这个数据包是具有一个准确的目的MAC地址的(也就是电脑的MAC，我们之前发送的报文里有记录)
所以交换机能够将这个DHCP的响应报文发给电脑
3 刚插上网线呢，就做了这么多东西了
这个时候我们打开浏览器，输入网址域名
这个时候我们需要得到这个域名的IP地址才能与其建立连接
再次构造一个UDP报文，目的端口为53，源端口任意
封装到IP数据包，源和目的IP地址在上面已经得到了，填上
到了链路层需要两个MAC地址，好像我们只有自己的MAC地址，目的MAC地址未知
这个时候电脑会生成一个ARP报文寻找默认网关的MAC地址(这个就不详细说了)
关于DNS报文的所有要的东西都齐全了，发送DNS报文
4 一般来说，常用的域名的IP都会存储在DNS缓存里，因此会比较快速
关于更多的DNS相关的，不在这次范围内
因此我们假设已经在某DNS服务器上拿到了DNS回答报文，这个报文就包括了我们要访问的URL的IP
5 这个时候电脑以及具备和远程的服务器建立TCP连接了
首先先是TCP的三次握手，三次握手在别的文章里讲到
握手成功后，发送请求报文，经过互联网路由器的一系列转发到达了相应的服务器
服务器收到了电脑发送的请求，并做出相应的处理，将结果写入响应报文，按照原来的TCP连接返回给电脑
6 电脑的浏览器通过处理渲染以及加载就呈现出了看到的网页</description>
    </item>
    
    <item>
      <title>Leetcode 108</title>
      <link>https://wushaoqiang.github.io/posts/leetcode-108/</link>
      <pubDate>Sat, 27 Apr 2019 23:13:54 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/leetcode-108/</guid>
      <description>题目 Given an array where elements are sorted in ascending order, convert it to a height balanced BST. For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1. Example: Given the sorted array: [-10,-3,0,5,9], One possible answer is: [0,-3,9,-10,null,5], which represents the following height balanced BST: 0 / \ -3 9 / / -10 5  我的解答 func sortedArrayToBST(nums []int) *TreeNode { if len(nums) == 0 { return nil } mid := (len(nums) - 1) / 2 head := &amp;amp;TreeNode{Val: nums[mid]} heightHalancedTree(head, nums, 0, mid-1) heightHalancedTree(head, nums, mid+1, len(nums)-1) return head } func heightHalancedTree(t *TreeNode, nums []int, left, right int) { if left &amp;lt;= right { mid := (left + right) / 2 // fmt.</description>
    </item>
    
    <item>
      <title>Leetcode 107</title>
      <link>https://wushaoqiang.github.io/posts/leetcode-107/</link>
      <pubDate>Sat, 27 Apr 2019 21:36:47 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/leetcode-107/</guid>
      <description>题目 Given a binary tree, return the bottom-up level order traversal of its nodes&#39; values. (ie, from left to right, level by level from leaf to root). For example: Given binary tree [3,9,20,null,null,15,7], 3 / \ 9 20 / \ 15 7 return its bottom-up level order traversal as: [ [15,7], [9,20], [3] ]  我的解答 没做出来
最优解答 func levelOrderBottom(root *TreeNode) [][]int { var ret [][]int if root == nil { return nil } que := []*TreeNode{root} for len(que) &amp;gt; 0 { //先记录这一层的长度 len := len(que) var level []int //只要遍历完len长度就退出循环 for i := 0; i &amp;lt; len; i++ { // 每次遍历取队列第一个元素，因此队列遍历了一个元素之后要立即删除 node := que[0] que = que[1:] level = append(level, node.</description>
    </item>
    
    <item>
      <title>Leetcode 104</title>
      <link>https://wushaoqiang.github.io/posts/leetcode-104/</link>
      <pubDate>Sat, 27 Apr 2019 21:36:42 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/leetcode-104/</guid>
      <description>题目 Given a binary tree, find its maximum depth. The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node. Note: A leaf is a node with no children. Example: Given binary tree [3,9,20,null,null,15,7], 3 / \ 9 20 / \ 15 7 return its depth = 3.  我的解答 func maxDepth(root *TreeNode) int { if root == nil { return 0 } if root.</description>
    </item>
    
    <item>
      <title>Leetcode 101</title>
      <link>https://wushaoqiang.github.io/posts/leetcode-101/</link>
      <pubDate>Sat, 27 Apr 2019 21:36:39 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/leetcode-101/</guid>
      <description>题目 Given a binary tree, check whether it is a mirror of itself (ie, symmetric around its center). For example, this binary tree [1,2,2,3,4,4,3] is symmetric: 1 / \ 2 2 / \ / \ 3 4 4 3 But the following [1,2,2,null,3,null,3] is not: 1 / \ 2 2 \ \ 3 3 Note: Bonus points if you could solve it both recursively and iteratively.  我的解答 这题做的比较蠢，没有任何参考价值，就不放了</description>
    </item>
    
    <item>
      <title>Leetcode 100</title>
      <link>https://wushaoqiang.github.io/posts/leetcode-100/</link>
      <pubDate>Sat, 27 Apr 2019 21:36:35 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/leetcode-100/</guid>
      <description>题目 Given two binary trees, write a function to check if they are the same or not. Two binary trees are considered the same if they are structurally identical and the nodes have the same value. Example 1: Input: 1 1 / \ / \ 2 3 2 3 [1,2,3], [1,2,3] Output: true Example 2: Input: 1 1 / \ 2 2 [1,2], [1,null,2] Output: false Example 3: Input: 1 1 / \ / \ 2 1 1 2 [1,2,1], [1,1,2] Output: false  我的解答 /** * Definition for a binary tree node.</description>
    </item>
    
    <item>
      <title>Leetcode 88</title>
      <link>https://wushaoqiang.github.io/posts/leetcode-88/</link>
      <pubDate>Sat, 27 Apr 2019 21:33:45 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/leetcode-88/</guid>
      <description>题目 Given two sorted integer arrays nums1 and nums2, merge nums2 into nums1 as one sorted array. Note: The number of elements initialized in nums1 and nums2 are m and n respectively. You may assume that nums1 has enough space (size that is greater or equal to m + n) to hold additional elements from nums2. Example: Input: nums1 = [1,2,3,0,0,0], m = 3 nums2 = [2,5,6], n = 3 Output: [1,2,2,3,5,6]  我的解答 func merge(nums1 []int, m int, nums2 []int, n int) { for m &amp;gt; 0 &amp;amp;&amp;amp; n &amp;gt; 0 { if nums1[m-1] &amp;gt;= nums2[n-1] { nums1[n+m-1] = nums1[m-1] m-- } else { nums1[n+m-1] = nums2[n-1] n-- } } if m == 0 { for n &amp;gt; 0 { nums1[n-1] = nums2[n-1] n-- } return } }  解法思路是归并排序，这相当于归并排序的最后一步了</description>
    </item>
    
    <item>
      <title>Golang GC</title>
      <link>https://wushaoqiang.github.io/posts/golang-GC/</link>
      <pubDate>Sat, 27 Apr 2019 12:48:58 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/golang-GC/</guid>
      <description>用了Golang有一段时间了，知道Golang能够自动回收内存也有一段时间了，对于我这种不搞明白原理不甘心系列，今天就来搞明白什么是GC
参考  legendtkl
 Golang UK Conference 2017 | Will Sewell &amp;amp; Jim Fisher - Golang&amp;rsquo;s Realtime GC in Theory and Practice
  算法模型 三色标记算法(Mark-and-sweep)
三色分别为(黑色，灰色，白色)，其中黑色不能够有指针指向白色的数据
 这个算法实现广度优先(BF)
 重复选取一个灰色，将它的所指向的所有对象都变成灰色，自己变成黑色
 这个重复选取直到没有灰色的对象为止
  在上面三个步骤能体会到各个颜色代表的意思(运行阶段)
 黑色：已经遍历过这个对象的所有对象
 灰色：这个对象所指向的对象还没有被遍历过
 白色：它被指向的节点是灰色、或者它根本没有被指向(这就是垃圾)
  结束阶段里，按算法所解释的，是不会再有灰色了，只有
 黑色：有用的数据
 白色：已经不可能到达的数据(垃圾，会被清理)
  回收时主要的流程  从root开始找到所有可达的对象，标记灰色
 执行我们前面所说的模型里的循环
 在处理完循环后，清理所有白色标记的对象
  小结 其实GC还有很多很多的细节，笔者只是在这里先建立一个概念，等后面到达一定阶段再去看看具体的实现</description>
    </item>
    
    <item>
      <title>Golang 依赖注入</title>
      <link>https://wushaoqiang.github.io/posts/golang-dependency-injection/</link>
      <pubDate>Fri, 26 Apr 2019 21:05:43 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/golang-dependency-injection/</guid>
      <description>面试时遇到一道题，问依赖注入带来了什么好处。。。？？？我连啥是依赖注入都不知道，真是打扰了，赶紧补回来
没有DI 把所有创建变量放在New函数里面
type Person struct{ name string age int } type Student struct{ person *Person } func NewPerson() *Person{ return &amp;amp;Person{} } func NewStudent() *Student{ return &amp;amp;Student{ person:&amp;amp;Person{}, } } func main(){ s := NewStudent() }  我们不能按照自己的意愿传入想要的参数,这样main函数比较简单
有DI type Person struct{ name string age int } type Student struct{ person *Person } func NewPerson(name string,age int) *Person{ return &amp;amp;Person{ name:name, age:age, } } func NewStudent(person *Person) *Student{ return &amp;amp;Student{ person:person, } } func main(){ p := NewPerson(&amp;quot;abc&amp;quot;,12) s := NewStudent(p) }  这里我们就是有依赖注入，能够按照我们的需要传入参数，但是main的代码会随着结构体的传递变得很长</description>
    </item>
    
    <item>
      <title>Golang 泛型</title>
      <link>https://wushaoqiang.github.io/posts/golang-generic/</link>
      <pubDate>Fri, 26 Apr 2019 19:55:21 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/golang-generic/</guid>
      <description>笔者今天参加了一个面试，笔试第一题泛型，因为Go里没有泛型，因此对此毫无概念，开这篇文章解决这个问题
泛型是什么 类型的参数化，在静态语言里，类型尤为重要，虽然Go里interface{}接口可以传入任何类型，但这不利于错误检查(程序不会在编译的时候检查到错误，而是在运行时出错，这就很不爽了)
比如我们需要一个int双向链表，这个时候我们就要写一个结构体大概是
type LinkListNode struct { Value int Next *LinkListNode Prev *LinkListNode } type LinkList struct { len int head *LinkListNode tail *LinkListNode }  如果我们还要写一个字符串的链表，这个时候将Value的类型改成string就行了，其它不用变，如果我们还要..balabala，可能就要定义上百个结构体了，到时候代码全是结构体
有些同学说，用接口不就可以了吗？用接口不就无法实现类型的判断了吗，万一程序哪个地方本应该收到int，却收了一个string，然后程序boom
关于网上很多网友使用interface来达到所谓的泛型，我是越看越像多态呀，并且还是达不到泛型所能提供的类型保护啊，虽然算法确实可以复用了(有些)
泛型的目的是减少代码的重复性，也就是增加重用性，还能够确定数据类型，比如Java中的一个例子
class Factory&amp;lt;T&amp;gt;{ private T value; public T getValue() { return value; } public void setValue(T v) { this.value = v; } }  T我可以是字符串，也可以是整数等，或者是自己定义的结构体。但是一旦定下来，创建了的变量类型就不能变了
所以我说了那么多。。怎么实现啊
实现 Go2草稿中有提到这个话题Go 2 Draft Designs
目前只是一个草稿，并且是由Gopher们共同推进的一个话题，所以说现在Go内置里面还未实现泛型
笔者也去看了一些关于泛型的讨论，到最后都还是建议不要在现阶段写泛型程序，因为Go有一个很本质的特点，就是简单写、简单读，如果通过一些自己的&amp;rdquo;创造&amp;rdquo;而造成别人阅读代码困难，那是得不偿失
所以真香，还是用回多态吧，有机会再详细阅读一下草稿
对此Go2还对错误处理进行了强烈的讨论，笔者也希望以后写Go不用一大堆错误处理了。。真的看到眼花
这里是Go2官方对这些修改的想法视频</description>
    </item>
    
    <item>
      <title>Effective Go</title>
      <link>https://wushaoqiang.github.io/posts/effective-go/</link>
      <pubDate>Thu, 25 Apr 2019 23:46:13 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/effective-go/</guid>
      <description>参考Effective Go中英双语版
 It&amp;rsquo;s also important to know the established conventions for programming in Go, such as naming, formatting, program construction, and so on, so that programs you write will be easy for other Go programmers to understand.
 Go的一个好处就是，大家的代码风格基本一致，看别人代码就不会显得很痛苦了(前提是开发者遵守)
所以我们今天来谈谈代码规范吧，这里只记录了我自己有时候会忽略的点，有一些规范我以及掌握并且时刻用在编写Golang程序上了，因此不记录，想看完整的请阅读上面的开源书本
格式化 Go的gofmt为我们做好了，所以安装这个程序，在保存的时候就可以自动帮你调整代码布局
注释 行注释更为常用，而块注释则主要用作包的注释
每个包都应包含一段包注释，即放置在包子句前的一个块注释。对于包含多个文件的包， 包注释只需出现在其中的任一文件中即可。包注释应在整体上对该包进行介绍，并提供包的相关信息。 它将出现在 godoc 页面中的最上面，并为紧随其后的内容建立详细的文档。
每个可导出（首字母大写）的名称都应该有文档注释。
命名 我记得有一个叫go-lint会检查这个
Go 中约定使用驼峰记法 MixedCaps 或 mixedCaps 而非下划线的方式来对多单词名称进行命名。
只包含一个方法的接口应当以该方法的名称加上 - er 后缀来命名，如 Reader
若你有个名为 owner （小写，未导出）的字段，其获取器应当名为 Owner（大写，可导出）而非 GetOwner。大写字母即为可导出的这种规定为区分方法和字段提供了便利。 若要提供设置器方法，SetOwner 是个不错的选择</description>
    </item>
    
    <item>
      <title>Interview2</title>
      <link>https://wushaoqiang.github.io/posts/interview2/</link>
      <pubDate>Thu, 25 Apr 2019 22:05:12 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/interview2/</guid>
      <description>最大连续子数组和  线程之间共享数据的方式  Go encourages the use of channels to pass references to data between goroutines
 这里应该用channel来达到通信
在Go里面，推荐使用数据交换来达到共享的效果，可能和别的编程语言有很大的不同
进程和线程的区别 进程：操作系统对一个正在运行的程序的一种抽象，一个系统上可以运行多个进程，这些进程在单核的处理器下一样可以显得好像的并发的一样，这是通过处理器在进程之间的切换实现的，这种交错执行的机制称为上下文切换
线程：一个进程可以由多个线程的执行单元组成，每个线程都运行在进程的上下文中
区别：
 进程在系统上运行，线程在进程上运行，因此进程是独立的地址空间、线程共享进程的地址空间
 线程比进程的开销要小
 线程一般来说比进程更高效
 线程之间的数据共享比进程的简单
 线程必须依赖在进程上执行
  临界区是啥 临界区从通俗层面来讲就是我们锁-解锁之间的代码，通常会写在程序(或者说资源)无法同时被使用的地方
这个区域只能允许一个线程或进程进入，其它后来的需要等待解锁
死锁是啥。死锁产生的条件是什么 在我理解里，线程A占用了资源C，这个时候线程A还要申请资源D(占用且申请)，但线程B这时占用着资源D，而且线程A无法将资源抢过来，所以现在线程A就在等待线程B释放资源D。线程B在这个时候也需要使用资源C，并且不得到就不离开(一直等待)，所以现在局面就是A在等B释放D，B在等A释放C(循环等待)，并且都不肯让资源(不可抢占)，并且资源CD都是只能有一个线程占有的(互斥)
若干进程竞争有限资源，但顺序或者决策不当，使得大家都在无限循环等待，就形成了死锁
 互斥条件
 不可抢占条件
 占有且申请条件(这个的意思是在占有资源的情况下还要去申请别的资源)
 循环等待条件
  只要上述条件有一个不满足，就可以避免死锁
给出很多串信息 包含ip url info 等信息 info包含error等状态码 用Linux命令统计出每个url对应的error概率 占时还不太清除这个
Linux命令 如何杀死占用指定端口的进程 这个可能可以分解为两个问题，如果从端口找到进程pid，如何杀死指定pid的进程
所以查找pid有lsof -i:port和netstat -p |grep port</description>
    </item>
    
    <item>
      <title>Linux 网络管理</title>
      <link>https://wushaoqiang.github.io/posts/linux-network-management/</link>
      <pubDate>Thu, 25 Apr 2019 20:29:02 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/linux-network-management/</guid>
      <description>ping -c 发送一定数量的报文
ifconfig 其中输出信息里
enp0s31f6：以太网(有线)
lo：回传
wlp4s0：无线网
tcpdump 这是一个类似wireshark抓包的命令,需要权限
-c：指定抓取包的数量
-i：指定接口(上面说到有3个接口)
port：指定端口
netstat -r：显示路由
-i：显示接口
-n：显示IP
-t：tcp
-u：udp</description>
    </item>
    
    <item>
      <title>Linux 进程管理</title>
      <link>https://wushaoqiang.github.io/posts/linux-process-management/</link>
      <pubDate>Thu, 25 Apr 2019 17:04:19 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/linux-process-management/</guid>
      <description>进程状态  R 正在运行或在运行队列
 D 不可中断，进程不会因为信号被唤醒，只能等待中断发生
 S 中断，等待某个事件完成或者被信号唤醒
 Z 僵死，进程已经终止但其父进程没有用wait()或在waitpid()来释放它
 T 停止，可能是收到控制信号，也可能是被跟踪
  相关命令 ps,pstree,top(htop),jobs,kill，nice，nohup
Crtl+c:终结进程
Ctrl+z:暂停进程
ps(Process Status) ps 只会给当前终端中运行的进程
ps -a Select all processes except both session leaders (see getsid(2)) and processes not associated with a terminal.
ps -u root显示root用户的process，这里root也可以是别的用户名
ps -l 相对ps，会显示父PID等信息
ps aux 显示所有process
ps -ef 详细显示所有process
pstree pstree 进程树
pstree -p 显示PID
pstree (username) 显示用户的进程
jobs jobs 查看后台运行的进程
fg %num 将后台程序转移到前台</description>
    </item>
    
    <item>
      <title>Golang Vscode Problem</title>
      <link>https://wushaoqiang.github.io/posts/golang-vscode-problem/</link>
      <pubDate>Wed, 24 Apr 2019 20:56:13 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/golang-vscode-problem/</guid>
      <description>今天Vscode用着用着，突然自动补全不能用了，不仅没有自动导入，也没有函数提示等
突然觉得自己被打入地狱(没有自动补全就像手写代码一样，很不是滋味)
在Google上找了别人的方法也都没用，最后瞎搞一下搞好了
方法 删掉gocode
go get github.com/nsf/gocode,这是一个老版本的gocode，现在已经被新的替代了
这个时候vscode会提示你下载推荐版本的gocode，按下载就可以了
疑问 我也曾经重试下载最新版gocode，但是没用，不知道为什么直接在vscode更新就有用</description>
    </item>
    
    <item>
      <title>Golang Context</title>
      <link>https://wushaoqiang.github.io/posts/golang-context/</link>
      <pubDate>Wed, 24 Apr 2019 19:07:52 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/golang-context/</guid>
      <description>Context又名上下文，在一开始接触这个词的时候就有点迷惑了，开一篇文章把这个困扰了我有一阵子的迷惑解开吧
参考博客理解Go Context机制
Golang的执行单元是goroutine，main也是一个goroutine
上下文，上下则是存在上下层的传递，我们在编写Web后端的时候，接收到一个请求可能会执行一些列的goroutine(数据库，业务层处理)来达到并发效果
这个时候，如果客户端那边取消了呢？如果我们在服务器端检测不到这个信号，那么我们服务器还是会继续服务，直到完成所有服务的时候，发现客户端已经不见了(资源就被浪费了)
所以我们需要在每一个由Request产生的goroutine里面装一个监控，这个监控会告诉程序客户端是否还在等待返回，如果客户端离开，那么程序立即停止对客户端的服务
Context接口 type Context interface { Deadline() (deadline time.Time, ok bool) Done() &amp;lt;-chan struct{} Err() error Value(key interface{}) interface{} }   Deadline会返回一个超时时间，Goroutine获得了超时时间后，例如可以对某些io操作设定超时时间。
 Done方法返回一个信道（channel），当Context被撤销或过期时，该信道是关闭的，即它是一个表示Context是否已关闭的信号。
 当Done信道关闭后，Err方法表明Context被撤的原因。
 Value可以让Goroutine共享一些数据，当然获得数据是协程安全的。但使用这些数据的时候要注意同步，比如返回了一个map，而这个map的读写则要加锁。
  每当我们处理一个Request的时候，都应该从Request里拿一个Context
req,err := http.NewRequest(http.MethodGet,&amp;quot;http://127.0.0.1:8080&amp;quot;,nil) if err != nil { log.Fatalln(err) } ctx := req.Context()   the context is canceled when the client&amp;rsquo;s connection closes
 如果Request的context是nil，那么它会返回一个context.Background()
var ( background = new(emptyCtx) todo = new(emptyCtx) )  方法 我们前面说了，Context是要上下传递的，我们需要达到一种效果： 上面的Context收到了中断信号，下面的也要进行中断</description>
    </item>
    
    <item>
      <title>Interview</title>
      <link>https://wushaoqiang.github.io/posts/interview/</link>
      <pubDate>Wed, 24 Apr 2019 15:32:21 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/interview/</guid>
      <description>本文是笔者自己收集他人面经，顺便检查一下自己的知识状况，找目标进一步提升
go的调度 这里应该指的是goroutine的调度模式
读过Go Web编程那本书的人可能知道，go的并发是由线程、处理器、调度器和一个个的goroutine
简单说一下运行的一些规则
 每一个线程里面有一个的协程，从微观角度来看是顺序执行的，但是从宏观角度来看，因为执行速度快，线程里的协程不断切换，因此可以看作是并行
 处理器主要就是用来执行goroutine的，它也维护了一个goroutine的队列，里面有在等待的goroutine
 只有线程和处理器结合起来才能构造一个goroutine执行环境
 调度器，当协程阻塞的时候，会保存上下文，直到下次可以恢复运行
  这是一些比较浅显运行的规则，如果要深入goroutine的源码分析，推荐一篇文章
go struct能不能比较 如果是值类型，是可以比较的，比如
p1 := Person{Name: &amp;quot;SQ&amp;quot;, Age: 1} p2 := Person{Name: &amp;quot;SQ&amp;quot;, Age: 1} if p1 == p2 { fmt.Println(&amp;quot;same&amp;quot;) }  这样是有输出的
那如果是嵌套呢？也是一样的，只要是具有可比性的，如string,int这些类型，都能直接比较。如果结构体含有引用类型，因为是地址，所以肯定不一样，给个例子
type Person struct { Name string Age int } type Student struct { *Person ID int }  由于Student里面的Person是一个引用类型，所以比较是比较了地址，因此是不同的
go defer defer这个要注意的点有两个
 执行顺序，先进后出
 参数还是闭包
  参数传递会根据传递参数时的值进行执行</description>
    </item>
    
    <item>
      <title>关于加密 --基础</title>
      <link>https://wushaoqiang.github.io/posts/encryption-basic/</link>
      <pubDate>Wed, 24 Apr 2019 11:03:38 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/encryption-basic/</guid>
      <description> 我们现在接触较多的两种加密方式
 对称加密
 公钥加密
  对称加密 利用一样的秘钥，在持有者双方进行加密和解密
但是第一次建立连接并且传输秘钥的时候不安全(当然可以通过其它方式传输)
速度快
公钥加密 用对方的公钥加密，发送给对方，因为只要对方有自己的私钥，因此就算密文半路被拦截，也不会泄露信息
安全性好，但速度慢
结合 结合两种加密方式，创建一个既安全又快的连接
 利用对方公钥加密对称秘钥，发送给对方
 对方收到用自己秘钥解密，得到对称秘钥
 双方用对称秘钥进行接下来的通信
  </description>
    </item>
    
    <item>
      <title>Leetcode 83</title>
      <link>https://wushaoqiang.github.io/posts/leetcode-83/</link>
      <pubDate>Tue, 23 Apr 2019 22:21:39 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/leetcode-83/</guid>
      <description>题目 给定一个排序链表，删除所有重复的元素，使得每个元素只出现一次。 示例 1: 输入: 1-&amp;gt;1-&amp;gt;2 输出: 1-&amp;gt;2 示例 2: 输入: 1-&amp;gt;1-&amp;gt;2-&amp;gt;3-&amp;gt;3 输出: 1-&amp;gt;2-&amp;gt;3  我的解答 type ListNode struct { Val int Next *ListNode } func deleteDuplicates(head *ListNode) *ListNode { c := head for c != nil { if c.Next == nil { return head } if c.Val == c.Next.Val { c.Next = c.Next.Next } else { c = c.Next } } return head }  因为是个排序的链表，因此只要前后对比，再根据指针的指向来改变链表
最优解答 /** * Definition for singly-linked list.</description>
    </item>
    
    <item>
      <title>Leetcode 70</title>
      <link>https://wushaoqiang.github.io/posts/leetcode-70/</link>
      <pubDate>Tue, 23 Apr 2019 22:21:35 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/leetcode-70/</guid>
      <description>题目 假设你正在爬楼梯。需要 n 阶你才能到达楼顶。 每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？ 注意：给定 n 是一个正整数。 示例 1： 输入： 2 输出： 2 解释： 有两种方法可以爬到楼顶。 1. 1 阶 + 1 阶 2. 2 阶 示例 2： 输入： 3 输出： 3 解释： 有三种方法可以爬到楼顶。 1. 1 阶 + 1 阶 + 1 阶 2. 1 阶 + 2 阶 3. 2 阶 + 1 阶  我的解答 func climbStairs(n int) int { if n == 1 || n == 2 { return n } count2 := n / 2 result := 0 for ; count2 &amp;gt;= 0; count2-- { result += calc(n-count2, count2) } return result } //注意float的运算可能会出现一些.</description>
    </item>
    
    <item>
      <title>Leetcode 69</title>
      <link>https://wushaoqiang.github.io/posts/leetcode-69/</link>
      <pubDate>Tue, 23 Apr 2019 22:21:31 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/leetcode-69/</guid>
      <description>题目 实现 int sqrt(int x) 函数。 计算并返回 x 的平方根，其中 x 是非负整数。 由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。 示例 1: 输入: 4 输出: 2 示例 2: 输入: 8 输出: 2 说明: 8 的平方根是 2.82842..., 由于返回类型是整数，小数部分将被舍去。  我的解答 func mySqrt(x int) int { return int(math.Floor(math.Sqrt(float64(x)))) }  向下取整
最优解答 func mySqrt(x int) int { if x == 0 || x == 1 { return x } i := x / 2.0 for i*i &amp;gt; x { i = (i + x/i) / 2 } return i }  数学公式</description>
    </item>
    
    <item>
      <title>Leetcode 67</title>
      <link>https://wushaoqiang.github.io/posts/leetcode-67/</link>
      <pubDate>Tue, 23 Apr 2019 22:21:26 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/leetcode-67/</guid>
      <description>题目 给定两个二进制字符串，返回他们的和（用二进制表示）。 输入为非空字符串且只包含数字 1 和 0。 示例 1: 输入: a = &amp;quot;11&amp;quot;, b = &amp;quot;1&amp;quot; 输出: &amp;quot;100&amp;quot; 示例 2: 输入: a = &amp;quot;1010&amp;quot;, b = &amp;quot;1011&amp;quot; 输出: &amp;quot;10101&amp;quot;  我的解答 func addBinary(a string, b string) string { lengthLonger, lengthShorter := 0, 0 tmp := &amp;quot;&amp;quot; if len(a) &amp;gt; len(b) { lengthLonger = len(a) lengthShorter = len(b) } else { lengthLonger = len(b) lengthShorter = len(a) tmp = b b = a a = tmp } resultArray := make([]int, lengthLonger+1) carry := 0 for i := lengthLonger; i &amp;gt;= 0; i-- { if i &amp;gt; (lengthLonger - lengthShorter) { currentA, _ := strconv.</description>
    </item>
    
    <item>
      <title>Leetcode 66</title>
      <link>https://wushaoqiang.github.io/posts/leetcode-66/</link>
      <pubDate>Tue, 23 Apr 2019 22:21:23 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/leetcode-66/</guid>
      <description>题目 给定一个由整数组成的非空数组所表示的非负整数，在该数的基础上加一。 最高位数字存放在数组的首位， 数组中每个元素只存储一个数字。 你可以假设除了整数 0 之外，这个整数不会以零开头。 示例 1: 输入: [1,2,3] 输出: [1,2,4] 解释: 输入数组表示数字 123。 示例 2: 输入: [4,3,2,1] 输出: [4,3,2,2] 解释: 输入数组表示数字 4321。  我的解答 func plusOne(digits []int) []int { for i := len(digits) - 1; i &amp;gt;= 0; i-- { if digits[i] != 9 { digits[i]++ return digits } digits[i] = 0 } digits = append([]int{1}, digits...) return digits }  比较简单
最优解答 无
难疑点&amp;amp;核心 无</description>
    </item>
    
    <item>
      <title>Leetcode 58</title>
      <link>https://wushaoqiang.github.io/posts/leetcode-58/</link>
      <pubDate>Tue, 23 Apr 2019 22:21:19 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/leetcode-58/</guid>
      <description> 题目 给定一个仅包含大小写字母和空格 &#39; &#39; 的字符串，返回其最后一个单词的长度。 如果不存在最后一个单词，请返回 0 。 说明：一个单词是指由字母组成，但不包含任何空格的字符串。 示例: 输入: &amp;quot;Hello World&amp;quot; 输出: 5  我的解答 func lengthOfLastWord(s string) int { if s == &amp;quot;&amp;quot; { return 0 } if !strings.Contains(s, &amp;quot; &amp;quot;) { return len(s) } s = strings.TrimSpace(s) lastSpaceIndex := strings.LastIndex(s, &amp;quot; &amp;quot;) return len(s) - lastSpaceIndex - 1 }  前面两个判断是为了能够快速判断简单情况
要注意去掉头尾的空格，不然索引查找会出错
这里也调用了标准库，可能在算法上不算合规
最优解答 无
难疑点&amp;amp;核心  容易把头尾的空格忽略掉  </description>
    </item>
    
    <item>
      <title>Leetcode 53</title>
      <link>https://wushaoqiang.github.io/posts/leetcode-53/</link>
      <pubDate>Tue, 23 Apr 2019 22:21:16 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/leetcode-53/</guid>
      <description>题目 给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。 示例: 输入: [-2,1,-3,4,-1,2,1,-5,4], 输出: 6 解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。 进阶: 如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的分治法求解。  我的解答 func maxSubArray(nums []int) int { if len(nums) == 0 { return 0 } if len(nums) == 1 { return nums[0] } total := nums[0] max := nums[0] for i := 1; i &amp;lt; len(nums); i++ { if total &amp;lt; 0 { total = 0 } total += nums[i] if max &amp;lt; total { max = total } } return max }  暴力法的话，时间复杂度是O(N^2)，这里使用的方法时间复杂度O(N)</description>
    </item>
    
    <item>
      <title>Leetcode 35</title>
      <link>https://wushaoqiang.github.io/posts/leetcode-35/</link>
      <pubDate>Tue, 23 Apr 2019 22:21:07 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/leetcode-35/</guid>
      <description>题目 给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。 你可以假设数组中无重复元素。 示例 1: 输入: [1,3,5,6], 5 输出: 2 示例 2: 输入: [1,3,5,6], 2 输出: 1 示例 3: 输入: [1,3,5,6], 7 输出: 4 示例 4: 输入: [1,3,5,6], 0 输出: 0  我的解答 func searchInsert(nums []int, target int) int { isFound, idx := binarySearch(nums, 0, len(nums)-1, target) if isFound { return idx } if nums[idx] &amp;gt; target { return idx } else { return idx + 1 } } func binarySearch(nums []int, left, right, target int) (found bool, idx int) { if left &amp;lt; right { mid := (left + right) / 2 if nums[mid] == target { return true, mid } else if nums[mid] &amp;gt; target { return binarySearch(nums, left, mid-1, target) } else { return binarySearch(nums, mid+1, right, target) } } else if nums[left] == target { return true, left } else { return false, left } }  因为是个有序的数组，因此可以不用暴力搜索，这里使用比较简单的二分法，找到索引(就算没有相等的，也找到最后一个查找的索引)</description>
    </item>
    
    <item>
      <title>Leetcode 28</title>
      <link>https://wushaoqiang.github.io/posts/leetcode-28/</link>
      <pubDate>Tue, 23 Apr 2019 22:21:04 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/leetcode-28/</guid>
      <description>题目 实现 strStr() 函数。 给定一个 haystack 字符串和一个 needle 字符串，在 haystack 字符串中找出 needle 字符串出现的第一个位置 (从0开始)。如果不存在，则返回 -1。 示例 1: 输入: haystack = &amp;quot;hello&amp;quot;, needle = &amp;quot;ll&amp;quot; 输出: 2 示例 2: 输入: haystack = &amp;quot;aaaaa&amp;quot;, needle = &amp;quot;bba&amp;quot; 输出: -1 说明: 当 needle 是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。 对于本题而言，当 needle 是空字符串时我们应当返回 0 。这与C语言的 strstr() 以及 Java的 indexOf() 定义相符。  我的解答 func strStr(haystack string, needle string) int { return strings.Index(haystack, needle) }  这里可能有点赖皮，直接调用了标准库，看网上说还有一种KMP的算法，比较难，按笔者现在的进度，先刷60简单题吧，后面再考虑实现。
当然还有暴力算法，但是我宁愿使用标准库吧
最优解答 无</description>
    </item>
    
    <item>
      <title>Leetcode 27</title>
      <link>https://wushaoqiang.github.io/posts/leetcode-27/</link>
      <pubDate>Tue, 23 Apr 2019 22:21:01 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/leetcode-27/</guid>
      <description>题目 给定一个数组 nums 和一个值 val，你需要原地移除所有数值等于 val 的元素，返回移除后数组的新长度。 不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。 元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。 示例 1: 给定 nums = [3,2,2,3], val = 3, 函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。 你不需要考虑数组中超出新长度后面的元素。 示例 2: 给定 nums = [0,1,2,2,3,0,4,2], val = 2, 函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。 注意这五个元素可为任意顺序。 你不需要考虑数组中超出新长度后面的元素。 说明: 为什么返回数值是整数，但输出的答案是数组呢? 请注意，输入数组是以“引用”方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。 你可以想象内部操作如下: // nums 是以“引用”方式传递的。也就是说，不对实参作任何拷贝 int len = removeElement(nums, val); // 在函数里修改输入数组对于调用者是可见的。 // 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。 for (int i = 0; i &amp;lt; len; i++) { print(nums[i]); }  我的解答 func removeElement(nums []int, val int) int { if len(nums) == 0 { return 0 } i := 0 j := len(nums) - 1 for i &amp;lt; j { if nums[i] == val { nums[i] = nums[j] j-- } else { i++ } } if nums[i] == val { return j } return j+1 }  因为题目说只需要给索引就可以了，因此不需要创建新的内存存放，只需要用一个索引将符合要求的值和不符合要求的值划分开(所以要交换它们位置)</description>
    </item>
    
    <item>
      <title>Leetcode 26</title>
      <link>https://wushaoqiang.github.io/posts/leetcode-26/</link>
      <pubDate>Tue, 23 Apr 2019 22:20:55 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/leetcode-26/</guid>
      <description>题目 给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。 不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。 示例 1: 给定数组 nums = [1,1,2], 函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 你不需要考虑数组中超出新长度后面的元素。 示例 2: 给定 nums = [0,0,1,1,1,2,2,3,3,4], 函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。 你不需要考虑数组中超出新长度后面的元素。 说明: 为什么返回数值是整数，但输出的答案是数组呢? 请注意，输入数组是以“引用”方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。 你可以想象内部操作如下: // nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝 int len = removeDuplicates(nums); // 在函数里修改输入数组对于调用者是可见的。 // 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。 for (int i = 0; i &amp;lt; len; i++) { print(nums[i]); }  我的解答 func removeDuplicates(nums []int) int { if len(nums) == 0 || len(nums) == 1 { return len(nums) } count := 0 existMap := make(map[int]bool) for _, num := range nums { if _, exist := existMap[num]; !</description>
    </item>
    
    <item>
      <title>Leetcode 21</title>
      <link>https://wushaoqiang.github.io/posts/leetcode-21/</link>
      <pubDate>Tue, 23 Apr 2019 22:20:50 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/leetcode-21/</guid>
      <description>题目 将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 示例： 输入：1-&amp;gt;2-&amp;gt;4, 1-&amp;gt;3-&amp;gt;4 输出：1-&amp;gt;1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;4  我的解答 /** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode { l4 := &amp;amp;ListNode{} l3 := &amp;amp;ListNode{} l4.Next = l3 for l1 != nil || l2 != nil { if l1 == nil { return l2 } if l2 == nil { return l1 } if l1.</description>
    </item>
    
    <item>
      <title>SQL 进阶</title>
      <link>https://wushaoqiang.github.io/posts/SQL-highlevel/</link>
      <pubDate>Tue, 23 Apr 2019 10:25:40 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/SQL-highlevel/</guid>
      <description>只针对Mysql的SQL语句
##创建TABLE
CREATE TABLE user ( id int PRIMARY KEY, username varchar(255) NOT NULL UNIQUE, password varchar(255) NOT NULL );  约束也可以这样写
CREATE TABLE user ( id int, username varchar(255) NOT NULL, password varchar(255) NOT NULL City varchar(255) DEFAULT &#39;Sandnes&#39; UNIQUE(username) PRIMARY KEY(id) FOREIGN KEY (P_id) REFERENCES Persons(P_id) )  约束  NOT NULL
 UNIQUE
 PRIMARY KEY(NOT NULL和UNIQUE的结合)
 FOREIGN KEY:保证一个表中的数据匹配另一个表中的值的参照完整性
 CHECK
 DEFAULT 默认值，在没有赋值的情况下就是默认值
  NOT NULL 强制不接受NULL，如果不向该字段添加值，就无法插入新纪录或者更新记录</description>
    </item>
    
    <item>
      <title>SQL 基础</title>
      <link>https://wushaoqiang.github.io/posts/SQL-basic/</link>
      <pubDate>Mon, 22 Apr 2019 23:05:06 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/SQL-basic/</guid>
      <description>笔者之前学了一些基础的Mysql的语法，现在进一步学习
关系型数据库用的语言标准就是SQL，只是不同的数据库有自己的拓展，所以学SQL标准可以说是一举多得吧
非关系型数据库有自己的一套语言
只针对Mysql的SQL语句
SELECT 选定要输出的列
SELECT column_name,column_name FROM table_name;  将所有列输出
SELECT * FROM table_name;  SELECT DISTINCT 如果一个列中包含了很多相同的，比如国家里面有很多人是中国的、日本的等等，我们指向查看有多少种的话，这样看起来很费劲
介绍一个解决这种问题的命令
和SELECT语法基本一样，只是这里不会输出相同的字段
SELECT DISTINCT column_name,column_name FROM table_name;  WHERE WHERE子句用于提取那些满足指定标准的记录
SELECT column_name,column_name FROM table_name WHERE column_name operator value;  例如，我要id大于3的user的id和name字段
SELECT id,name FROM user WHERE id &amp;gt; 3  这里提醒一点，当实例是文本字段需要加单引号，如果是数值字段，就像上面一样直接写就好
WHERE的运算符 WHERE column_name operator value  这里的operator就是运算符的位置
运算符有：
 =,&amp;gt;,&amp;gt;=,&amp;lt;,&amp;lt;= 这些就比较好理解了
 &amp;lt;&amp;gt; 不等于
 BETWEEN 在某个范围，用法WHERE column_name BETWEEN value1 AND value2</description>
    </item>
    
    <item>
      <title>DHCP 和 NAT</title>
      <link>https://wushaoqiang.github.io/posts/DHCP-and-NAT/</link>
      <pubDate>Mon, 22 Apr 2019 20:59:55 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/DHCP-and-NAT/</guid>
      <description>DHCP(动态主机配置协议) 我们在上网的时候，其实是向某一个ISP请求一个IP地址，这个IP地址是临时的，到期是要被回收的
四个步骤  让DHCP服务器发现客户端：客户端创建一个请求报文，请求端口号为67，但这个时候它连自己的IP地址都不知道(因为还没分配)，就用0.0.0.0:68来代替，但是它也不知道目标地址，所以用广播地址255.255.255.255:67
 DHCP服务器提供：DHCP收到了请求，做出响应，目标地址仍然使用255.255.255.255:68(这里端口号为68.因为客户68端口是接收这个包的)，这个时候客户端已经知道DHCP的位置了
 再次对准确地址发出请求
 DHCP响应
  到这里交互就完成了
NAT(网络地址转换) 这个是普遍使用在学校，家庭，公司等，因为现在IPv4的资源已经枯竭，利用NAT能够使得大家共用一个对外的IP，而内部会有不同的IP(局域网内IP)
比如我在学习请求百度这个网页，百度实际上看到的IP地址是我学校的IP地址，并且将内容返回给这个IP地址，学校再通过NAT转换表把东西转给我
有些人也说道，NAT实质上很大阻碍了IPv6的发展</description>
    </item>
    
    <item>
      <title>IPv4 数据报格式与分片</title>
      <link>https://wushaoqiang.github.io/posts/ip-message-field/</link>
      <pubDate>Mon, 22 Apr 2019 20:21:55 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/ip-message-field/</guid>
      <description>直接上图  版本号
 首部长度：一般为20
 服务类型：为了区分数据报，有点想女士优先这种
 数据报长度(首部加数据，一般不超过1500字节)
 标识、标志、片偏移：与IP数据报分片有关(别的篇幅讲)
 寿命：每经过一台路由器，TTL减1，若为0的时候，这个数据报就要丢掉了
 上层协议：6代表TCP；17代表UDP
 首部校验和(检验IP数据报比特错误)
 源和目的IP地址
 选项(很少用)
 数据(TCP or UDP报文段)
  IP数据报分片 发送方与目的地路径上的每段链路可能使用不同的链路层协议，且每种协议可能具备不同的MTU
比如以太网的MTU为1500
所以在通过MTU比较小的链路段时，就需要分片了
为了让目的主机执行重装任务，IPv4的设计者将标识、标志、片偏移字段放在IP数据报首部
分别解释这三个字段 标识 发送主机在发送IP数据报的时候，通常会将它发送的每个数据报的标识号加1
所以目的地址收到了很多片，这些片上标识号是同一个数字的，那么它们就是可以组合的
标志 最后一个片的标志比特被设为0，表明已经接收到某个标识的最后一个片
偏移量 毫无疑问，是为了将片重新组织回去的</description>
    </item>
    
    <item>
      <title>HTTP 报文</title>
      <link>https://wushaoqiang.github.io/posts/http-message-field/</link>
      <pubDate>Mon, 22 Apr 2019 19:17:47 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/http-message-field/</guid>
      <description> 客户向它的套接字接口发送HTTP请求报文和向它的套接字接口接收HTTP响应报文
HTTP是一个无状态协议
报文格式 响应报文格式 常见状态码 //Success 200 OK ：表示请求成功 201 Created ：表示请求成功且新建了资源 202 Accepted ：请求成功，但还没创建资源 //Redirection 301 Moved Permanently ：永久转移，服务器会自动转到新的位置 302 Found ：暂时转移，下次还是用这个URI 304 Not Modified ：服务端已经执行了GET，但文件未变化 //Client Error 400 Bad Request ：报文中存在语法错误 401 Unauthorized ：未认证 403 Forbidden ：对请求资源的访问被服务器拒绝了 404 Not Found ：无法找到指定的资源 //Server Error 500 Internal Server Error :服务器端在执行请求时发生了错误 503 Service Unavailable :服务器暂时处于超负载或正在进行停机维护  </description>
    </item>
    
    <item>
      <title>UDP</title>
      <link>https://wushaoqiang.github.io/posts/udp/</link>
      <pubDate>Mon, 22 Apr 2019 16:35:03 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/udp/</guid>
      <description>  UDP无连接建立
 不需要维护连接状态
 报文头比TCP小
 能尽可能的快，没有速度限制
  应用场景 对丢包不是很看重，对速度很敏感
 DNS
 SNMP
  报文结构 </description>
    </item>
    
    <item>
      <title>TCP 流量控制</title>
      <link>https://wushaoqiang.github.io/posts/tcp-flow-control/</link>
      <pubDate>Mon, 22 Apr 2019 15:17:17 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/tcp-flow-control/</guid>
      <description>流量控制是为了匹配发送方和接收方的数据交换速度，如果发送方发的太快，接收方的缓存可能会溢出
还要提醒一下流量控制和拥塞控制是两码事
TCP通过让发送方维护一个称为接收窗口的变量来提供流量控制
在接收方一定要满足
LastByteRcvd - LastByteRead &amp;lt;= RcvBuffer
用rwnd表示还有多少空间可以用，所以rwnd = RcvBuffer - (LastByteRcvd - LastByteRead)
在TCP报文首部里有一个叫做接收窗口，这个就是接收者告诉发送者rwnd的
在发送方，通过将未确认的数据量控制在值rwnd以内，就可以保证接收者不会缓存溢出了
UDP是不提供流量控制的，所以UDP很有可能会出现缓存溢出</description>
    </item>
    
    <item>
      <title>TCP 拥塞控制</title>
      <link>https://wushaoqiang.github.io/posts/tcp-congestion-control/</link>
      <pubDate>Mon, 22 Apr 2019 13:11:08 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/tcp-congestion-control/</guid>
      <description> TCP必须使用端到端拥塞控制而不是网络辅助的拥塞控制
TCP所采用的方法是让每一个发送方根据所感知到的网络拥塞程度来限制其能向连接发送流量的速率
三个问题 我们如何知道网络开始拥塞？
我们如何限制发送方发送速率
当发送方感受到拥塞时，用什么算法去限制其发送速率
如何知道网络拥塞 TCP是不会有一种特殊的包叫“我拥塞啦”
接收到Ack 没有拥塞，可以提速
没接收到Ack 可能拥塞，降速
如何限制发送方速率 改变cwnd
当一切顺利，cwnd增加；丢包，cwnd减少
我们发送方被限制在min(rwnd,cwnd)
LastByteSent - LastByteAcked &amp;lt;= cwnd
rwnd和cwnd是不同的，前者是表示接收方的buffer还有多少能用，后者是改变在网络上的容量
用什么算法来限制速度 我们希望TCP能在不发生拥塞情况上利用最大的带宽
所以发送方速率有点像三角波，上上下下，因为要尽可能利用带宽又不要制造拥塞
慢启动 在包被收到的情况下 cwnd每次是之前的两倍1,2,4,8,16...，直到大于或等于阈值，切换到拥塞避免
在包没有被收到的情况下 三次冗余Ack 进入快速恢复
超时 阈值=cwnd/2
把cwnd变为1
阈值(threhold) 记录上一次拥塞时一半的cwnd
拥塞避免 在包被接收到的情况下 线性增长，每次在所有分片的Ack被接收到的情况下(一个RTT)，增加一个MSS
在包没有被接收到的情况下 三次冗余Ack 进入快速恢复
超时 切换到慢启动
快速恢复 每个冗余的Ack对cwnd增加一个MSS，当丢失报文段的Ack最终回到时，再减少一个MSS
进入拥塞避免状态
出现超时，进入慢启动
出现丢包，cwnd设置为1，阈值设置为cwnd的一半
总结一下 三次冗余ACK  阈值设置为cwnd/2
 cwnd设置为阈值(有快速恢复的情况下)
  超时  阈值设置为cwnd/2
 cwnd设置为1(MSS)
  </description>
    </item>
    
    <item>
      <title>TCP 连接 --三次握手和四次挥手</title>
      <link>https://wushaoqiang.github.io/posts/tcp-connect/</link>
      <pubDate>Mon, 22 Apr 2019 12:52:03 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/tcp-connect/</guid>
      <description> 首先这里所说的握手，是进程之间的握手
三次握手 简单来说就是
A --&amp;gt; B 不承载有效负荷 B --&amp;gt; A 不承载有效负荷 A --&amp;gt; B 可以承载有效负荷  再细致点说就是
 客户端应用程序发起一个TCP连接
 发送报文里有SYN
 收到来自服务器端的SYN&amp;amp;ACK
 再次向服务器端发送ACK
  这里面总共有3次报文，所以为三次握手
最大报文段长度&amp;amp;最大传输单元 最大报文段长度(MSS):一般为1460
最大传输单元(MTU):一般为1500
之说以说一般，是因为一般来说TCP/IP的首部字段加起来是40字节
1500-40=1460
清除认识 当进程通过套接字把数据给到TCP的时候，数据就和进程没关系了，已经全权交给TCP了
为什么不是两次握手？ 这是书本上的一个问题
在我理解，握手其实是为了双方知道对方的初始序列号
 客户端给服务器端发送初始序列号
 服务器端收到了客户端的初始序列号，并且发送服务器端的初始序列号
  如果客户端不产生第三次握手，那么服务器端不知道客户端到底拿到了初始序列号没
 客户端看到回复后就知道服务器端拿到了自己的初始序列号，于是也和服务器端说明，已经拿到它的初始序列号了  四次挥手  客户端应用程序发起关闭连接
 发送报文里包含FIN
 服务器端发送一个ACK表示接收到了
 服务器端再次发一个FIN
 客户端给服务器端发一个ACK
 等待一会，资源就释放了
  </description>
    </item>
    
    <item>
      <title>TCP --报文</title>
      <link>https://wushaoqiang.github.io/posts/tcp-message-field/</link>
      <pubDate>Mon, 22 Apr 2019 12:14:31 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/tcp-message-field/</guid>
      <description> 之间写过一个关于《计算机网络(原书第六版)：自顶向下方法》的一部分笔记，当时没继续写下去是因为觉得一个篇幅太多了，决定分开写，这样可能可以更加详细点，也算是第二次的复习吧
这篇主要讲报文
先看看报文的格式
首先，TCP是运输层的协议，IP是网络层的协议，一般运输层协议会确定端口号，网络层协议则确定IP地址
 源/目的端口号
 序号/确认号：是用来双方实现可靠传输的(下面详细讲)
 接收窗口字段：用于流量控制(可能会在别的篇幅讲)
 首部长度：由于有选项这个字段，使得TCP的首部长度是可以变化的，不过通常就是20字节
 标志字段/紧急指针：标志字段包括确认字段有效、建立和拆除连接、紧急数据。紧急指针指向紧急数据
  序号/确认号 一条TCP连接的双发均可随机地选择初始序号，可能是0和4294967295之间的任意值
我们假设初始序号为0
A --&amp;gt; B Seq=42,ACK=79,data=1 B --&amp;gt; A Seq=79,ACK=43,data=2 A --&amp;gt; B Seq=43,ACK=80,data=3 ...  在我理解
序号是标识我要发送给对方的数据
确认号是标识我需要对方发送给我的数据
所以上面场景就是
A给B发序号为42的数据，并且向B要序号为79的数据 B收到了A的数据，并且返回A所要的序号为79的数据，并且B还想要A序号为43的数据 以此类推...  </description>
    </item>
    
    <item>
      <title>Leetcode 20</title>
      <link>https://wushaoqiang.github.io/posts/leetcode-20/</link>
      <pubDate>Mon, 22 Apr 2019 00:46:01 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/leetcode-20/</guid>
      <description>题目 给定一个只包括 &#39;(&#39;，&#39;)&#39;，&#39;{&#39;，&#39;}&#39;，&#39;[&#39;，&#39;]&#39; 的字符串，判断字符串是否有效。 有效字符串需满足： 左括号必须用相同类型的右括号闭合。 左括号必须以正确的顺序闭合。 注意空字符串可被认为是有效字符串。 示例 1: 输入: &amp;quot;()&amp;quot; 输出: true 示例 2: 输入: &amp;quot;()[]{}&amp;quot; 输出: true 示例 3: 输入: &amp;quot;(]&amp;quot; 输出: false 示例 4: 输入: &amp;quot;([)]&amp;quot; 输出: false 示例 5: 输入: &amp;quot;{[]}&amp;quot; 输出: true  我的解答 笔者在做这道题的时候想的稍微复杂了点，用了递归的方法做，但速度什么的非常慢，所以不值得参考，只能说一路摸坑吧
var ( relation = map[string]string{&amp;quot;(&amp;quot;: &amp;quot;)&amp;quot;, &amp;quot;[&amp;quot;: &amp;quot;]&amp;quot;, &amp;quot;{&amp;quot;: &amp;quot;}&amp;quot;} ) func isValid(s string) bool { if len(s) == 0 { return true } if (len(s)+2)%2 != 0 { return false } if len(s) == 2 { return string(s[1]) == relation[string(s[0])] } // l := len(s) for { idx := getLastIndex(s) if idx == -1 { return false } if !</description>
    </item>
    
    <item>
      <title>Leetcode 14</title>
      <link>https://wushaoqiang.github.io/posts/leetcode-14/</link>
      <pubDate>Mon, 22 Apr 2019 00:45:56 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/leetcode-14/</guid>
      <description>题目 编写一个函数来查找字符串数组中的最长公共前缀。 如果不存在公共前缀，返回空字符串 &amp;quot;&amp;quot;。 示例 1: 输入: [&amp;quot;flower&amp;quot;,&amp;quot;flow&amp;quot;,&amp;quot;flight&amp;quot;] 输出: &amp;quot;fl&amp;quot; 示例 2: 输入: [&amp;quot;dog&amp;quot;,&amp;quot;racecar&amp;quot;,&amp;quot;car&amp;quot;] 输出: &amp;quot;&amp;quot; 解释: 输入不存在公共前缀。 说明: 所有输入只包含小写字母 a-z 。  我的解答 func longestCommonPrefix(strs []string) string { if len(strs) == 0 { return &amp;quot;&amp;quot; } if len(strs) == 1 { return strs[0] } shortestLen := len(strs[0]) for _, str := range strs { if len(str) &amp;lt; shortestLen { shortestLen = len(str) } } var finalStr string for i := 0; i &amp;lt; shortestLen; i++ { tmp := strs[0][i] for j := 1; j &amp;lt; len(strs); j++ { if tmp !</description>
    </item>
    
    <item>
      <title>Leetcode 13</title>
      <link>https://wushaoqiang.github.io/posts/leetcode-13/</link>
      <pubDate>Mon, 22 Apr 2019 00:45:53 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/leetcode-13/</guid>
      <description>题目 罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。 字符 数值 I 1 V 5 X 10 L 50 C 100 D 500 M 1000 例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做 XXVII, 即为 XX + V + II 。 通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况： I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。 X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。 给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。 示例 1: 输入: &amp;quot;III&amp;quot; 输出: 3 示例 2: 输入: &amp;quot;IV&amp;quot; 输出: 4 示例 3: 输入: &amp;quot;IX&amp;quot; 输出: 9 示例 4: 输入: &amp;quot;LVIII&amp;quot; 输出: 58 解释: L = 50, V= 5, III = 3.</description>
    </item>
    
    <item>
      <title>Leetcode 9</title>
      <link>https://wushaoqiang.github.io/posts/leetcode-9/</link>
      <pubDate>Mon, 22 Apr 2019 00:45:41 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/leetcode-9/</guid>
      <description>题目 判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。 示例 1: 输入: 121 输出: true 示例 2: 输入: -121 输出: false 解释: 从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。 示例 3: 输入: 10 输出: false 解释: 从右向左读, 为 01 。因此它不是一个回文数。 进阶: 你能不将整数转为字符串来解决这个问题吗？  我的解答 func isPalindrome(x int) bool { str := strconv.Itoa(x) for i := 0; i &amp;lt; len(str)/2; i++ { if str[i] != str[len(str)-1-i] { return false } } return true }  转换为字符串进行比较就简单很多了,直接头尾比较，时间复杂度为O(N/2),N为字符串长度</description>
    </item>
    
    <item>
      <title>Leetcode 1</title>
      <link>https://wushaoqiang.github.io/posts/leetcode-1/</link>
      <pubDate>Mon, 22 Apr 2019 00:19:11 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/leetcode-1/</guid>
      <description>题目 给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。
你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。
示例:
给定 nums = [2, 7, 11, 15], target = 9 因为 nums[0] + nums[1] = 2 + 7 = 9 所以返回 [0, 1]  我的解答 func twoSum(nums []int, target int) []int { myMap := make(map[int]int) for idx,num := range nums{ myMap[num] = idx } for idx,num := range nums{ tmp := target - num if pos,exist := myMap[tmp]; exist{ if idx &amp;gt; pos{ return []int{pos,idx} } else if idx &amp;lt; pos{ return []int{idx,pos} }else{ continue } } } return nil }  方法是通过map来达到快速查找，而不像暴力法需要每次都遍历整个数组</description>
    </item>
    
    <item>
      <title>Leetcode 7</title>
      <link>https://wushaoqiang.github.io/posts/leetcode-7/</link>
      <pubDate>Mon, 22 Apr 2019 00:19:11 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/leetcode-7/</guid>
      <description>题目 给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。 示例 1: 输入: 123 输出: 321 示例 2: 输入: -123 输出: -321 示例 3: 输入: 120 输出: 21 注意: 假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为 [−2^31, 2^31 − 1]。请根据这个假设，如果反转后整数溢出那么就返回 0。  我的解答 func reverse(x int) int { var rev int for x != 0 { lastNum := x % 10 x = x / 10 if rev &amp;gt; math.MaxInt32/10 || rev == math.MaxInt32/10 &amp;amp;&amp;amp; lastNum &amp;gt; 7 { return 0 } if rev &amp;lt; math.</description>
    </item>
    
    <item>
      <title>Leetcode 开篇</title>
      <link>https://wushaoqiang.github.io/posts/leetcode-before-start/</link>
      <pubDate>Mon, 22 Apr 2019 00:00:37 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/leetcode-before-start/</guid>
      <description> 不积跬步无以至千里，不积小流无以成江海
 作为Leetcode的开篇作，在这里希望自己能够坚持每天code一两道题(视难度而定)
以后博客应该是以这样的方式呈现
### 题目 ### 我的解答 ### 最优解答 ### 难疑点&amp;amp;核心  </description>
    </item>
    
    <item>
      <title>Golang Pipeline</title>
      <link>https://wushaoqiang.github.io/posts/golang-pipeline/</link>
      <pubDate>Sun, 21 Apr 2019 10:59:13 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/golang-pipeline/</guid>
      <description>根据官网博客学习Pipeline
什么是Pipeline 管道其实就是一系列的Channel连接起来
 通过channel(可能不止一个)来接收数据
 处理数据
 用Channel向下传递数据(也可能不止一个)
  代码演示 package main import ( &amp;quot;fmt&amp;quot; &amp;quot;sync&amp;quot; ) func main() { // Set up a done channel that&#39;s shared by the whole pipeline, // and close that channel when this pipeline exits, as a signal // for all the goroutines we started to exit. done := make(chan struct{}) defer close(done) in := gen(done, 2, 3) // Distribute the sq work across two goroutines that both read from in.</description>
    </item>
    
    <item>
      <title>Golang make vs new</title>
      <link>https://wushaoqiang.github.io/posts/golang-makevsnew/</link>
      <pubDate>Sun, 21 Apr 2019 00:30:06 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/golang-makevsnew/</guid>
      <description>make和new的对象  make只能对slice、map、channel作用，比如不能make(int)
 new可以对任何类型作用
  make和new的返回值  make返回主体
 new也是返回指针，比如new(int)，返回一个int的指针，这个指针的内容是0
  初始化 两者都会初始化为“0”值
总结 所以我觉得它们最大的区别还是返回值的区别，以及作用对象</description>
    </item>
    
    <item>
      <title>Golang Map</title>
      <link>https://wushaoqiang.github.io/posts/golang-map/</link>
      <pubDate>Sat, 20 Apr 2019 20:03:42 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/golang-map/</guid>
      <description>Construct: m:=map[key]value{}
 Insert: m[k] = v
 Lookup: v = m[k]
 Delete: delete(m,k)
 lterate: for k,v := range m
 Size: len(m)
  Key不能为 maps,slices,funcs. 因为它们不可比较
Map底层 map header
len lg(#buckets) bucket array hash seed  流程  接收到一个key
 对key进行hash
 通过hash找到是哪一个bucket
 取hash前8bit作为extra(作为快速检查)
 找到bucket的内存(对不同的类型，大小会有不同)
  扩容  新创建一个两倍的空间
 复制entries到新的bucket，但是这里的复制是递增式的，因为如果一次性将很大的数据复制到一块内存，它会很耗费时间，但是这种方法就代表着，在扩容的时候，查找会变得慢了，因为要查找两块内存空间。这也决定了我们不能直接用指针指向map的某一个value，因为这个value可能扩容后就不在那了
 用新的bucket
  和其它Map比较  Go map不能用指针指向单个value
 迭代的时候，go map是可以修改的</description>
    </item>
    
    <item>
      <title>Golang Channel</title>
      <link>https://wushaoqiang.github.io/posts/golang-channel/</link>
      <pubDate>Sat, 20 Apr 2019 17:19:20 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/golang-channel/</guid>
      <description>这里就不再赘述重要性了
Channel特性  goroutine-safe
 两个goroutine之间传递数据
 FIFO
 cause goroutine to block and unblock
  What is the inside of channel  mutex
 send-index and recieve index
 buf
  Create a channel ch := make(chan int,3) //buffered chan ch := make(chan int) //sync chan  ch is a pointer
How it work Send  When it is going to send data to the channel, it will acquire the lock because it is going to modify.</description>
    </item>
    
    <item>
      <title>Golang Interface</title>
      <link>https://wushaoqiang.github.io/posts/golang-interface/</link>
      <pubDate>Sat, 20 Apr 2019 13:36:59 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/golang-interface/</guid>
      <description>在说接口之前，我们先说一下类型，类型在Go语言里面可以大致分为
 concrete type(具体类型,int,string&amp;hellip;)
 abstract type(抽象类型 io.Writer,io.Reader&amp;hellip;)
  具体类型我们知道它到底长什么样子，比如说int64，我们知道它在底层有8个字节
抽象类型我们不知道或者说我们不关注它长什么样，但我们知道它的用处，比如io.Writer是用来写的
具体化谈Interface 举个非常简单的例子，我们在读文件的时候，可能会这样做
func main() { f, err := os.Open(&amp;quot;abc.txt&amp;quot;) if err != nil { fmt.Println(err) } byte, _ := ioutil.ReadAll(f) fmt.Println(string(byte)) }  看一下ioutil.ReadAll()
func ReadAll(r io.Reader) ([]byte, error) { return readAll(r, bytes.MinRead) }  这里需要传入的是一个io.Reader接口，为什么*File类型传入一样可以呢
这里io.Reader是一个接口，接口里面只要一个函数
type Reader interface { Read(p []byte) (n int, err error) }  而*File里面也实现了这个接口的函数
func (f *File) Read(b []byte) (n int, err error) { if err := f.</description>
    </item>
    
    <item>
      <title>Golang Tips</title>
      <link>https://wushaoqiang.github.io/posts/golang-tips/</link>
      <pubDate>Thu, 18 Apr 2019 22:56:20 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/golang-tips/</guid>
      <description>关于select case runtime.GOMAXPROCS(1) int_chan := make(chan int, 1) string_chan := make(chan string, 1) int_chan &amp;lt;- 1 string_chan &amp;lt;- &amp;quot;hello&amp;quot; select { case value := &amp;lt;-string_chan: fmt.Println(value) case value := &amp;lt;-int_chan: panic(value) }  上面代码两个case都满足，会伪随机的执行一个
关于defer func DeferCalc() { a := 1 b := 2 defer calc(&amp;quot;1&amp;quot;, a, calc(&amp;quot;10&amp;quot;, a, b)) a = 0 defer calc(&amp;quot;2&amp;quot;, a, calc(&amp;quot;20&amp;quot;, a, b)) b = 1 time.Sleep(1 * time.Second) } func calc(index string, a, b int) int { ret := a + b fmt.</description>
    </item>
    
    <item>
      <title>Algorithm 排序</title>
      <link>https://wushaoqiang.github.io/posts/algorithm-sort/</link>
      <pubDate>Mon, 15 Apr 2019 20:03:27 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/algorithm-sort/</guid>
      <description>排序时间复杂度 堆排序 参考dreamcatcher-cx博客
最好最坏的平均时间复杂度都为O(NlogN)
代码 func HeapSortUp(a []int) []int { for i := len(a)/2 - 1; i &amp;gt;= 0; i-- { adjustHeapUp(a, i, len(a)) } for j := len(a) - 1; j &amp;gt; 0; j-- { a[0], a[j] = a[j], a[0] adjustHeapUp(a, 0, j) } return a } func adjustHeapUp(a []int, i int, length int) { tmp := a[i] for k := 2*i + 1; k &amp;lt; length; k = 2*k + 1 { if k+1 &amp;lt; length &amp;amp;&amp;amp; a[k+1] &amp;gt; a[k] { k++ } if a[k] &amp;gt; tmp { a[i] = a[k] i = k } else { break } } a[i] = tmp }  思路  先将数组变换为一个大顶堆</description>
    </item>
    
    <item>
      <title>Golang Gin</title>
      <link>https://wushaoqiang.github.io/posts/golang-gin/</link>
      <pubDate>Sun, 14 Apr 2019 23:12:41 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/golang-gin/</guid>
      <description> 中间件 在Gin的中间件可以这样定义，这是Gin定义的中间件的接口
func JWT() gin.HandlerFunc { return func(c *gin.Context){ //这个就和我们平时编写的路由函数一样了 } }  然后利用Use()函数注册进去
gin函数 //这三步和gin.Default()返回的Engine一样,之说gin.Default()会有一个输出消息 debugPrintWARNINGDefault() r := gin.New() r.Use(gin.Logger()) r.Use(gin.Recovery()) gin.SetMode(setting.RunMode)  分组 apiv1 := r.Group(&amp;quot;/api/v1&amp;quot;)  gin.HandlerFunc func GetTags(c *gin.Context){ }  Context方法 </description>
    </item>
    
    <item>
      <title>Golang Validation</title>
      <link>https://wushaoqiang.github.io/posts/golang-validation/</link>
      <pubDate>Sun, 14 Apr 2019 14:43:43 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/golang-validation/</guid>
      <description>Validation项目地址
创建 valid := validation.Validation{}  Validation方法 valid是创建过的对象
 valid.Required(name,&amp;quot;name&amp;quot;)：检验变量不能为空，字符串不能为&amp;quot;&amp;quot;,后面的&amp;quot;name&amp;quot;是用来标识而已
 valid.MaxSize(name,100,&amp;quot;name&amp;quot;)：最大长度
 valid.Range(state,0,1,&amp;quot;state&amp;quot;)：范围
 valid.HasErrors()：这个会返回布尔值，是否有不符合限定的内容
 valid.Errors：这个是一个Error数组，其中Error是这个包自带的，并不是标准库的error
 valid.Min(id,1,&amp;quot;id&amp;quot;)：id最小为1
  以上这些都返回*Result
Result方法 我们拿上面一个返回*Result对象做例子
 valid.Required(name,&amp;quot;name&amp;quot;).Message(&amp;quot;name不能为空&amp;quot;)  当加了Message后，发生错误返回*Error对象，Error.key就是name Error.Message就是上面的信息</description>
    </item>
    
    <item>
      <title>Golang Build blog with gin</title>
      <link>https://wushaoqiang.github.io/posts/golang-blog/</link>
      <pubDate>Sun, 14 Apr 2019 13:47:15 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/golang-blog/</guid>
      <description> Package  ini &amp;mdash;配置文件的读取
 com &amp;mdash;功能性
 validation &amp;mdash;做验证
 jwt-go &amp;mdash;Token
 endless &amp;mdash;服务器热启动
 swag &amp;mdash;API文档
  </description>
    </item>
    
    <item>
      <title>Golang标准库--os</title>
      <link>https://wushaoqiang.github.io/posts/golangstd-os/</link>
      <pubDate>Fri, 12 Apr 2019 20:24:48 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/golangstd-os/</guid>
      <description>Open与OpenFile的区别 笔者在某天遇到一个情况，用Open打开文件并且想写入发生了错误
bad file descriptor  检查过后发现Open在底层是调用了OpenFile，并且默认是只读的形式
// Open opens the named file for reading. If successful, methods on // the returned file can be used for reading; the associated file // descriptor has mode O_RDONLY. // If there is an error, it will be of type *PathError. func Open(name string) (*File, error) { return OpenFile(name, O_RDONLY, 0) }  所以要是想要自己定义打开的文件限制的话，就用OpenFile吧
// Flags to OpenFile wrapping those of the underlying system.</description>
    </item>
    
    <item>
      <title>Golang Path Problem</title>
      <link>https://wushaoqiang.github.io/posts/golang-path-problem/</link>
      <pubDate>Fri, 12 Apr 2019 17:28:21 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/golang-path-problem/</guid>
      <description>笔者在学习的路上遇到了一些关于路径的奇怪问题，想着这个问题都埋了这么久了，赶紧出来总结一下，以防下次再出现这类型错误
直接用相对路径 在os.Open()直接输入相对路径，这个相对路径决定于你的工作目录，如果工作目录发生改变，就不行了
filepath.Abs() filepath.Abs()是根据当前工作目录返回的绝对路径，这个和上面的不同在于，这个可以打开工作目录之前的文件，而上面的只能打开后面的文件
所谓前后是值文件夹的前后
所以写在程序里面，你在这个目录执行成功了，你退一个目录就不行了，因为这个时候工作路径改变了
笔者感觉这种方法不安全，或者我们写应用的时候指定要在某某目录执行，我有见过类似的项目
同一目录下，package都为main，不能调用 如果我们有两个文件，package都为main，比如是这样的
-main.go | -file.go  main.go想调用file.go的函数，会返回未定义的错误
有两种解决方法
 go install Or go build 转换为二进制文件执行
 go run *.go Or go run main.go file.go 这个表达意思一样的，把包含的文件都包含进去
  解决相对路径的最稳的方法 来自外国友人icza</description>
    </item>
    
    <item>
      <title>Nice Sentences</title>
      <link>https://wushaoqiang.github.io/posts/nice-sentences/</link>
      <pubDate>Fri, 12 Apr 2019 16:13:54 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/nice-sentences/</guid>
      <description> Don&amp;rsquo;t assume that you are right, just because nobody has proved you wrong
The bigger the interface, the weaker the abstraction &amp;ndash;Rob Pike
 </description>
    </item>
    
    <item>
      <title>Opinion</title>
      <link>https://wushaoqiang.github.io/posts/opinion/</link>
      <pubDate>Fri, 12 Apr 2019 16:13:32 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/opinion/</guid>
      <description> 关于在百度搜索问题 笔者在很早就体会到一点，百度搜出来的东西，理论价值真的不高
我开发遇到Bug第一时间去的都是google，基本第一页搞定我的问题
我在安装东西，工具最基本的使用，我会百度，因为这些东西肯定一大堆人在写
这也让我开始反思，写博客的人，应该以一种什么样的心态去写呢？
下面我总结出了两个点
 理论性较强的文章，应该多权威性的网站或者论坛(比如stackoverflow这类型的)，对比大家的意见，再结合自己对这些的想法和理解，写出一篇有深度的文章，而不仅仅停留在发现问题&amp;ndash;解决问题&amp;ndash;完事
 工具类型的文章，为了让自己能够在忘记怎么使用某一个工具时翻阅，属于一种笔记类型，不算文章
  </description>
    </item>
    
    <item>
      <title>Golang Log</title>
      <link>https://wushaoqiang.github.io/posts/golang-log/</link>
      <pubDate>Fri, 12 Apr 2019 01:34:09 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/golang-log/</guid>
      <description>笔者上面总结了一下网上关于错误处理和异常处理的资料，发现不知道什么时候要记录一个信息，什么时候不应该，再去找找别人的经验，总结到这篇博客。当然，笔者对标准库的log的接口表示有点少，而且输出的信息看起来有点累(虽然很多人喜欢标准库的log，但这里不讨论这个)，我将尝试着用用第三方库
我们做后台开发，无论有什么语言，都有相应的一套日志记录系统，并且日志记录的信息可能是一些小小的问题，也可能是一些大问题，这个时候就要分级处理了，很多人(包括我之前)都对分级这个界限划分的认识模糊，不知道什么时候该用什么级别的信息
在很多时候，log给我们提供的级别种类非常多，例如info、warning、debug、error等等，其实我对这些有些难以区分
在一些论坛上，大家也为这些发表意见，都有各自的道理，我把我觉得有道理的记录下来，以后我就会按照这样的一套标准(并非所有人的标准)来实现我的日志记录
先讲标准，在来简单分析一下第三方库的使用
warning  Nobody needs a warning log level
 警告是什么意思？出错了吗，还是没出错，不知道，有点模棱两可的感觉
所以要么是正常的信息输出(INFO)，要么就是错误
其实笔者后来觉得，warning可以在下面情况使用
 对，是出错了，但是经过我们的错误处理，在合适的尝试次数中成功了，这样我们可以给出警告，告诉开发者，这里曾经出过错  fatal 首先，在Go里面，Fatal是会调用os.Exit(1)的
这代表着什么样的结果(灾难)呢
 在其它线程的defer没有得到调用(比如一个文件的关闭在defer里，这样这个文件就未关闭，程序就挂了)
 缓冲区没有刷新(flush)，我们都知道，缓冲区要刷新，数据才能真正流入到我们想它到达的地方
 临时文件或者文件夹不会被移除(程序可能会生成临时文件，这是我们在结果中不想要的东西)
   It is commonly accepted that libraries should not use panic, but if calling log.Fatal has the same effect, surely this should also be outlawed.
 网上看到别人这样说，称panic,fatal应该属于违规操作
stackoverflow上赞同较多的答案说
 You should assume that a panic will be immediately fatal, for the entire program, or at the very least for the current goroutine.</description>
    </item>
    
    <item>
      <title>Golang Errandpanic</title>
      <link>https://wushaoqiang.github.io/posts/golang-errandpanic/</link>
      <pubDate>Thu, 11 Apr 2019 21:28:42 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/golang-errandpanic/</guid>
      <description>笔者在自己做一个小项目的时候，从0开始写呀写呀写，忽然发现代码里充满了错误处理，异常处理，乱七八糟，心情非常不好，所以是时候学习一下这方面的知识了，于是在网上搜索别的博主的总结
本文参考了张伯雨的博客 飞雪无情的博客 外国友人的博客
直观理解 虽然我一开始也知道错误和异常是两码事，但我处理起来就把它们当成一码事了，这是不对的，我们先从直观上去判断什么是错误，什么是异常
错误是我们意料之中的，比如我们在做一个Get请求，我们知道这个操作是有可能发生错误的(比如超时等)，意料之中的事情
异常是我们意料之外的事情，比如空指针、数组越界等，程序在编译阶段是无法辨认出数组越界，或者空指针的
 but unable to check mistakes like an out-of-bounds array, access or nil pointer deference which require checks at run time
 defer 说到异常就要提一下defer，它是一个关键字，用于延迟函数的执行，我们常见的是
... defer file1.Close() defer file2.Close() ...  当一个函数触发panic，或者正常的return，总之它所在的函数执行完毕了，这个时候就轮到defer的函数了
并且它是按照一个栈的形式来执行，也就是先进后出，在上面的例子中，file2会比file1先执行Close()
如果是panic，那么这个panic将会一直被传递上去，直到最后一个defer执行完毕
同样的功能，不同的设计 比如说，许多标准库里的函数，会有两种设计
 一般设计，如果输入有误，则返回错误
 异常设计，如果输入有误，直接抛出异常
  怎么看都觉得第二种好恐怖啊，动不动就抛出异常
其实不然，我们在编写程序的时候，有些时候是硬编码的，也就是说这个部分是很大概率不会出错的，比如说我们在调用template标准库时，我们写好的网页(H5)，一般来说到上线的时候都是固定死了的,所以在读取模板的时候基本不会出错，这个时候就不用再写错误处理了
凡事要有规则 异常处理的作用域
 空指针引用
 下标越界
 除数为0
 不应该出现的分支，比如我们在switch的时候，没有一个符合，就会到default分支
 输入不应该引起函数错误
  错误处理正确姿势 1.失败原因只有一个时，不用error 比如只是一些简单的判断，这个时候输出bool会更好</description>
    </item>
    
    <item>
      <title>Golang Crawler</title>
      <link>https://wushaoqiang.github.io/posts/golang-crawler/</link>
      <pubDate>Thu, 11 Apr 2019 17:35:02 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/golang-crawler/</guid>
      <description>笔者最近用了几天时间用Golang写一个爬虫并且做数据分析，先记录一下用了哪些包，方便后面总结
goquery --处理HTML标签 viper --读取配置文件 go-echarts --图表显示 gorm --Mysql数据库 golang-proxy --代理IP pkg/errors --更好追踪错误 logrus --美化log lfhook --为了生成log本地文件，与logrus配合使用  过程中遇到的错误(不分顺序)
 first path segment in URL cannot contain colon 这里把IP地址当做协议了，但是程序一样能运行，只要在IP地址前面加上//即可，就像//127.0.0.1:1080
 invalid memory address or nil pointer dereference 在我把IP替换成代理后，出现了这个情况，初步估计是resp.Body搞的鬼，在后面我多尝试几次后，也成功过。我在这里的做法是将函数重新调用(递归)，设置好递归的最大次数，如果超过这个次数就终止，或者使用下面的错误处理
  defer func () { if resp != nil { resp.Body.Close() } }()  单元测试 func TestCrawler(t *testing.T) { // keywords := []string{&amp;quot;golang&amp;quot;, &amp;quot;java&amp;quot;} keywords := &amp;quot;golang,java&amp;quot; refresh := &amp;quot;on&amp;quot; value := url.</description>
    </item>
    
    <item>
      <title>Golang Handle</title>
      <link>https://wushaoqiang.github.io/posts/golang-handle/</link>
      <pubDate>Thu, 11 Apr 2019 11:14:34 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/golang-handle/</guid>
      <description>本文主要解释Golang中http-handler几个容易混淆的概念
HandleFunc 源代码
在源码文件(net/http/server.go)中定义了一个默认的路由管理器(Mux)，我们如果直接调用
http.HandleFunc(...)  其实就用了默认的路由管理器，然后通过这个默认的路由器来调用路由管理器的方法
当然我们也可以自己定义一个路由管理器，然后通过这个对象来调用这些方法,和调用默认Mux不同的是
myMux.HandleFunc(...)  来看一下源码的这两个函数，验证上面所说的。
// HandleFunc registers the handler function for the given pattern // in the DefaultServeMux. // The documentation for ServeMux explains how patterns are matched. func HandleFunc(pattern string, handler func(ResponseWriter, *Request)) { DefaultServeMux.HandleFunc(pattern, handler) }  利用DefaultServeMux来调用HandleFunc()方法
// HandleFunc registers the handler function for the given pattern. func (mux *ServeMux) HandleFunc(pattern string, handler func(ResponseWriter, *Request)) { if handler == nil { panic(&amp;quot;http: nil handler&amp;quot;) } mux.</description>
    </item>
    
    <item>
      <title>Golang goquery</title>
      <link>https://wushaoqiang.github.io/posts/golang-goquery/</link>
      <pubDate>Mon, 08 Apr 2019 23:10:14 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/golang-goquery/</guid>
      <description>goquery是一个开源的库，针对解析HTML
今天在做爬虫的时候用到了一些功能，记录下来方便查阅
创建Document对象 doc, err := goquery.NewDocumentFromReader(resp.Body) if err != nil { log.Fatalf(&amp;quot;go query Error %s\n&amp;quot;, err) }  doc对象就包含了我们要解析的HTML主体
一般我们这样用，Find()里面的字符串就是我们要填写的规则
doc.Find(&amp;quot;div&amp;quot;).Each(func(i int, s *goquery.Selection) { fmt.Println(i,s.Text()) })  规则 我们可以根据HTML的源码分析对应的属性id，class等等
 div#id #id是某个div的id属性，筛选出此id的div标签
 div.class .class 同理，是class属性
 div[class],div[lang] 这个也是属性的筛选
 div&amp;gt;p div嵌套的p标签，这里规定只有一级标签，一级以后的p标签不会被筛选出来
 div p div嵌套的p标签，这里无论第几级都会被筛选出来
  属性可以和嵌套一起使用，例如div.class&amp;gt;p&amp;gt;li
Size num := doc.Find(&amp;quot;ul&amp;gt;li&amp;gt;div.job-primary&amp;quot;).Size()  取出标签内的属性 doc.Find(&amp;quot;ul&amp;gt;li&amp;gt;div.job-primary&amp;gt;div&amp;gt;h3&amp;gt;a&amp;quot;).Each(func(i int, s *goquery.Selection) { detail := s.Get(0).Attr[0].Val // fmt.Println(i, nextPage) jobs[i].Detail = detail })  我在这里踩过一个坑</description>
    </item>
    
    <item>
      <title>Golangstd Request</title>
      <link>https://wushaoqiang.github.io/posts/golangstd-request/</link>
      <pubDate>Mon, 08 Apr 2019 11:37:38 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/golangstd-request/</guid>
      <description>最近笔者看了一些源代码，也找了一些Web示例跟着学习，这次是Go源代码的request.go的学习总结
我们知道，在处理Web后端的时候，都会有两个参数http.ResponseWriter和*http.Request
所以Request是我们处理用户请求的接口，学习这个对Web开发也相当重要
Request结构体 type Request struct { Method string URL *url.URL Proto string // &amp;quot;HTTP/1.0&amp;quot; ProtoMajor int // 1 ProtoMinor int // 0 Header Header Body io.ReadCloser GetBody func() (io.ReadCloser, error) ContentLength int64 TransferEncoding []string Close bool Host string Form url.Values PostForm url.Values MultipartForm *multipart.Form Trailer Header RemoteAddr string RequestURI string TLS *tls.ConnectionState Cancel &amp;lt;-chan struct{} Response *Response ctx context.Context }  下面详细介绍每个字段的意义
Method 这就是一个请求的方法(如GET、POST)
但是Go的HTTP客户端不支持发送方法为CONNECT的请求
URL  // URL specifies either the URI being requested (for server // requests) or the URL to access (for client requests).</description>
    </item>
    
    <item>
      <title>Golang Gorm</title>
      <link>https://wushaoqiang.github.io/posts/golang-gorm/</link>
      <pubDate>Fri, 05 Apr 2019 20:37:11 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/golang-gorm/</guid>
      <description>连接数据库 Mysql db, err := gorm.Open(&amp;quot;mysql&amp;quot;, &amp;quot;root:123456@tcp/test?charset=utf8&amp;amp;parseTime=True&amp;quot;) if err != nil { panic(&amp;quot;连接数据库失败&amp;quot;) } defer db.Close() db.SingularTable(true)  选定好数据库后一般会配上
db.SingularTable(true)  如果不调用这个函数，当在数据库加入某个表单的时候，名字会自动加一个s
比如db.CreateTable(&amp;amp;Product{})，在数据库表单里面会得到一个名字为products
所以一般都会加上这个函数
创建Table db.CreateTable(&amp;amp;Product{})  创建多个table
db.CreateTable(&amp;amp;Product{},&amp;amp;User{})  删除Table 关于删除，有两个
db.DropTableIfExist(interface{}) db.DropTable(interface{})  这里可以传入字符串，也可以传入一个结构体
接着上面的例子
db.DropTableIfExist(&amp;quot;product&amp;quot;) db.DropTableIfExist(&amp;amp;Product{})  删除Column 删除Column是要指定Table，所以不能这样
db.DropColumn(&amp;quot;created_at&amp;quot;)  要定位Table，则需要
db.Model(&amp;amp;Product).DropColumn(&amp;quot;created_at&amp;quot;)  创建数据 db.Create(&amp;amp;Product{Code: &amp;quot;L1213&amp;quot;, Price: 1002})  查询数据 // 最后一个符合条件，默认id最后的那个 // Get last record, order by primary key db.Last(&amp;amp;user) //// SELECT * FROM users ORDER BY id DESC LIMIT 1; // 将所有符合条件的返回，这里要传一个结构体数组 // Get all records db.</description>
    </item>
    
    <item>
      <title>Golang Viper</title>
      <link>https://wushaoqiang.github.io/posts/golang-viper/</link>
      <pubDate>Fri, 05 Apr 2019 17:41:18 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/golang-viper/</guid>
      <description>Github
 Viper is a complete configuration solution for Go applications
 这是一个帮组我们读取配置文件的包，总结一些方法，方便以后使用
Reading Config Files  a single Viper instance only supports a single configuration file
 一个Viper对象只能对应一个配置文件，是一个一一对应的映射关系
但是我们在搜索配置文件的时候，可以设置多个路径，如果没有设置路径，则当前程序的目录上寻找，所以我们要设置好路径
这是Github上的一个例子
viper.SetConfigName(&amp;quot;config&amp;quot;) // name of config file (without extension) viper.AddConfigPath(&amp;quot;/etc/appname/&amp;quot;) // path to look for the config file in viper.AddConfigPath(&amp;quot;$HOME/.appname&amp;quot;) // call multiple times to add many search paths viper.AddConfigPath(&amp;quot;.&amp;quot;) // optionally look for config in the working directory err := viper.</description>
    </item>
    
    <item>
      <title>Learn Gitflow</title>
      <link>https://wushaoqiang.github.io/posts/learn-gitflow/</link>
      <pubDate>Wed, 03 Apr 2019 23:27:50 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/learn-gitflow/</guid>
      <description>gitflow是一种规范，适合大项目开发
Github上开源了一个遵循这样规范的一个Git工具gitflow
初始化一个git git flow init  然后会提醒一系列创建操作，类似
Which branch should be used for bringing forth production releases? Branch name for production releases: [master] Which branch should be used for integration of the &amp;quot;next release&amp;quot;? Branch name for &amp;quot;next release&amp;quot; development: [develop] How to name your supporting branch prefixes? Feature branches? [feature/] Bugfix branches? [bugfix/] Release branches? [release/] Hotfix branches? [hotfix/] Support branches? [support/] Version tag prefix? [] Hooks and filters directory?</description>
    </item>
    
    <item>
      <title>Golang Mega</title>
      <link>https://wushaoqiang.github.io/posts/golang-mega/</link>
      <pubDate>Mon, 01 Apr 2019 15:12:46 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/golang-mega/</guid>
      <description>不积跬步无以至千里，不积小流无以成江海
 本文是博主在学习基础记录的笔记
2019-04-01到2019-04-04，后面会自己DIY一些内容上去(想做成一个小小的技术论坛)
先来总体看一下整个项目的目录吧
. ├── cmd │ └── db_init │ └── main.go ├── config │ └── g.go ├── config.yml ├── controller │ ├── g.go │ ├── home.go │ ├── middle.go │ └── utils.go ├── main.go ├── model │ ├── g.go │ ├── post.go │ ├── user.go │ └── utils.go ├── templates │ ├── 404.html │ ├── _base.html │ ├── content │ │ ├── explore.html │ │ ├── index.</description>
    </item>
    
    <item>
      <title>Questions Network</title>
      <link>https://wushaoqiang.github.io/posts/questions-network/</link>
      <pubDate>Tue, 26 Mar 2019 17:27:44 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/questions-network/</guid>
      <description>这篇文章是要记录在学习网络基础相关知识的时候遇到的问题与解答
IP Q: 为什么我电脑的IP(172.29.15.243)可以访问外面的网络
A: 我们知道某些专用网络的地址在外部是访问不到的，比如学校内部网不可以直接从外部访问，要通过VPN。我们之所以能够用专用网络分配给我们的地址访问外部网络，是因为我们在访问因特网时，IP地址会被NAT转换。
Session 在mega项目里遇到一个问题
首先，我访问服务器，服务器将会返回一个Session给我，那么我在这个网页游走都可以用这个Session，没毛病
现在我Logout，这个时候服务器调用函数将Session的期限变为-1，也就是将Session过期
这个时候我把之前服务器给我的Session自己存起来，用Postman构造一个请求，并且附上这个Session(其实是通过Cookie传)，这个时候服务器不会因为将Session期限改为-1而不认识这个Session
所以这个现象表明所谓的清除只是服务器给浏览器发送的Cookie期限设置为-1，然后浏览器看到Cookie已经过期了，因此就不用了
这样也就验证了，一个用户在服务器上只有一个Session id？
resp.Body resp, err := http.DefaultClient.Do(req) if err != nil { log.Fatalf(&amp;quot;Do Error %s\n&amp;quot;, err) } defer resp.Body.Close() body, err := ioutil.ReadAll(resp.Body) if err != nil { log.Fatalf(&amp;quot;ReadAll Error %s\n&amp;quot;, err) } // fmt.Println(string(body)) file, err := os.Create(path + keyword + &amp;quot;.html&amp;quot;) if err != nil { log.Fatalf(&amp;quot;Create File Error %s\n&amp;quot;, err) } defer file.Close() _, err = file.</description>
    </item>
    
    <item>
      <title>Golang标准库--http</title>
      <link>https://wushaoqiang.github.io/posts/golangstd-net-http/</link>
      <pubDate>Tue, 19 Mar 2019 20:52:05 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/golangstd-net-http/</guid>
      <description>这篇文章是为了探索Golang中net/http包的实现，笔者暂时只会把主要脉络摸清，具体某些实现逻辑暂不考究，是一篇比较基础的源码阅读文章。
Package http doc.go 先来看看官方对这个包的一个解释
这里说到，这个包是为HTTP提供客户端和服务器端的实现的。
这里还举了一些方法的例子
// Copyright 2011 The Go Authors. All rights reserved. // Use of this source code is governed by a BSD-style // license that can be found in the LICENSE file. /* Package http provides HTTP client and server implementations. Get, Head, Post, and PostForm make HTTP (or HTTPS) requests: resp, err := http.Get(&amp;quot;http://example.com/&amp;quot;) ... resp, err := http.Post(&amp;quot;http://example.com/upload&amp;quot;, &amp;quot;image/jpeg&amp;quot;, &amp;amp;buf) ... resp, err := http.</description>
    </item>
    
    <item>
      <title>一些名词的定义</title>
      <link>https://wushaoqiang.github.io/posts/definition/</link>
      <pubDate>Tue, 19 Mar 2019 20:07:44 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/definition/</guid>
      <description>这里是为了记录一些常用名词的定义，大多参照百度百科和Wiki
句柄 句柄是一种特殊的智能指针 。当一个应用程序要引用其他系统（如数据库、操作系统）所管理的内存块或对象时，就要使用句柄
在Golang里面，我们使用函数打开一个文件得到的就是一个文件句柄(打开的文件就是操作系统所管理的内存块)
在Golang里面，我们使用数据库的驱动连接数据库时，返回的也是一个句柄，这个返回值只是一个对象，并不是一个连接
Redis  redis是一个key-value存储系统。和Memcached类似，它支持存储的value类型相对更多，包括string(字符串)、list(链表)、set(集合)、zset(sorted set &amp;ndash;有序集合)和hash（哈希类型）。这些数据类型都支持push/pop、add/remove及取交集并集和差集及更丰富的操作，而且这些操作都是原子性的。在此基础上，redis支持各种不同方式的排序。与memcached一样，为了保证效率，数据都是缓存在内存中。区别的是redis会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件，并且在此基础上实现了master-slave(主从)同步。
 TLS  传输层安全性协议（英语：Transport Layer Security，缩写作TLS），及其前身安全套接层（Secure Sockets Layer，缩写作SSL）是一种安全协议，目的是为互联网通信提供安全及数据完整性保障。
安全传输层协议（TLS）用于在两个通信应用程序之间提供保密性和数据完整性。 该协议由两层组成： TLS 记录协议（TLS Record）和 TLS 握手协议（TLS Handshake）。
 Cookie&amp;amp;Session Cookie Cookie是客户端保持状态
Cookie的内容主要包括：名字，值，过期时间，路径和域
若不设置过期时间，则表示这个cookie的生命期为浏览器会话期间，关闭浏览器窗口，cookie就消失。这种生命期为浏览器会话期的cookie被称为会话cookie
Session Session是服务器端保持状态
一个用户在服务器上拥有唯一的一个session Id
如果一个用户不断在请求同一个东西或者行为异常(爬虫？)，则可以对这个用户进行相应操作
Session能够记录用户的动作，比如淘宝能够记录你购物车有多少东西
Difference 我们拿淘宝作例子
我们登录淘宝不用账号密码的时候用的就是Cookie
但是我们在挑选商品加入购物车，淘宝的服务器也在记录我们的动作信息(比如添加商品)，这个时候用的是Session
所以我们可以用Session来跟踪用户的动作。
安全性 Session会比Cookie安全，因为Cookie可能会被欺骗(Cookie在一定程度上就算是你的用户名和密码，被人获取后，别人就可以用你的身份来做事了)</description>
    </item>
    
    <item>
      <title>Golang Exercism</title>
      <link>https://wushaoqiang.github.io/posts/golang-exercism/</link>
      <pubDate>Sun, 17 Mar 2019 02:15:05 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/golang-exercism/</guid>
      <description>Exercism &amp;ndash; Bob 我的方法：(总之非常愚蠢就是了)
func Hey(remark string) string { // Write some code here to pass the test suite. // Then remove all the stock comments. // They&#39;re here to help you get started but they only clutter a finished solution. // If you leave them in, reviewers may protest! if strings.EqualFold(remark, &amp;quot;&amp;quot;) { return &amp;quot;Fine. Be that way!&amp;quot; } whitespace := true for _, item := range []byte(remark) { if !</description>
    </item>
    
    <item>
      <title>Mysql学习笔记</title>
      <link>https://wushaoqiang.github.io/posts/mysql-basic/</link>
      <pubDate>Sun, 17 Mar 2019 02:14:18 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/mysql-basic/</guid>
      <description>安装 sudo apt-get install mysql-server mysql-client
查询是否安装了： sudo netstat -tap grep mysql
安装成功
tcp 0 0 localhost:mysql 0.0.0.0:* LISTEN 31238/mysqld  整个安装过程没有叫输入密码
登录 打开debian.cnf文件： sudo nano /etc/mysql/debian.cnf
# Automatically generated for Debian scripts. DO NOT TOUCH! [client] host = localhost user = debian-sys-maint password = x7McPCywm2p7SsnZ socket = /var/run/mysqld/mysqld.sock [mysql_upgrade] host = localhost user = debian-sys-maint password = x7McPCywm2p7SsnZ socket = /var/run/mysqld/mysqld.sock  这里面有一个叫debian-sys-maint的user
登录debian-sys-maint： mysql -u debian-sys-maint -p</description>
    </item>
    
    <item>
      <title>Go圣经读书笔记</title>
      <link>https://wushaoqiang.github.io/posts/golang-bible/</link>
      <pubDate>Sun, 17 Mar 2019 02:13:08 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/golang-bible/</guid>
      <description>第一章 入门 命令行参数 os.Args变量是一个字符串的切片，并且它的第一个元素是命令本身的名字
func main() { var s, sep string for i := 0; i &amp;lt; len(os.Args); i++ { s += sep + os.Args[i] sep = &amp;quot; &amp;quot; } fmt.Println(s) }  运行go run main.go 123
输出/tmp/go-build115927302/b001/exe/main 123
查找重复的行  input := bufio.NewScanner(os.stdin) ~ func NewScanner(r io.Reader) *Scanner  返回一个从r读取的Scanner
 func (s *Scanner) Scan() bool  逐行扫描，当scan停止的时候，或者是到了读取的终点，又或者是发生了错误，这里都会返回false
 func (s *Scanner) Text() string  返回scanner所在行的文本
counts := make(map[string]int) input := bufio.</description>
    </item>
    
    <item>
      <title>Go语言实战</title>
      <link>https://wushaoqiang.github.io/posts/golang-inaction/</link>
      <pubDate>Sun, 17 Mar 2019 02:11:56 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/golang-inaction/</guid>
      <description>Go语言优点：
 Go语言可以说是夹在C/C++和Python这两类语言之间，即提供了较高的性能，又使得开发更加迅速了。
 Go语言内置并发机制，对并发有着更好的性能
 Go语言自带垃圾回收器
 goroutine使用的内存比线程要少，所以常常能够成千上万个goroutine并发
  第六章 并发 概念  进程：当运行一个应用程序时，操作系统会为这个应用程序启动一个进程，可以将这个进程看作一个包含了应用程序在运行中需要用到和维护的各种资源 线程：一个线程是一个空间，这个空间会被操作系统调度来运行函数中所写的代码，线程会被调度到CPU上运行。 每个逻辑处理器绑定在一个线程上 逻辑处理器可以调度goroutine 并发：某一个事情的停止，另一个事情就开始(单线程) 并行：同时开始做(多线程)  goroutine 一个创建goroutine的示例 package main import ( &amp;quot;fmt&amp;quot; &amp;quot;runtime&amp;quot; &amp;quot;sync&amp;quot; ) // main is the entry point for all Go programs. func main() { // Allocate 1 logical processor for the scheduler to use. runtime.GOMAXPROCS(1) // wg is used to wait for the program to finish. // Add a count of two, one for each goroutine.</description>
    </item>
    
    <item>
      <title>Go语言高级编程</title>
      <link>https://wushaoqiang.github.io/posts/golang-highlevel/</link>
      <pubDate>Sun, 17 Mar 2019 02:09:45 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/golang-highlevel/</guid>
      <description>感谢 在文章开头感谢两位作者:柴树杉和曹春晖
这篇文章是开源的，欢迎大家去阅读
本篇博客是笔者对这篇文章的理解，引用的图片也是来自原文，如有侵权请告知！
第一章 基础 1.3 数组、字符串和切片  Go语言的数组是一种值类型，虽然数组的元素可以被修改，但是数组本身的赋值和函数传参都是以整体复制的方式处理的
 Go语言字符串底层数据也是对应的字节数组，但是字符串的只读属性禁止了在程序中对底层字节数组的元素的修改字符串赋值只是复制了数据地址和对应的长度，而不会导致底层数据的复制
 切片头含有底层数据的指针，所以它的赋值也不会导致底层数据的复制
  字符串  字符串的元素不可修改，是一个只读的字节数组
 字符串虽然不是切片，但是支持切片操作
type StringHeader struct { Data uintptr Len int }  字符串结构由两个信息组成：第一个是字符串指向的底层字节数组，第二个是字符串的字节的长度。
  切片 type SliceHeader struct { Data uintptr Len int Cap int }  a = append(a, 0) // 切片扩展1个空间 copy(a[i+1:], a[i:]) // a[i:]向后移动1个位置 a[i] = x // 设置新添加的元素  copy将a[i:]直接搬到了a[i+1:]这个时候就可以在a[i]插入
这种做法可以减少中间创建的临时切片
copy append可以完成切片的添加 删除 插入操作</description>
    </item>
    
    <item>
      <title>Golang--Leetcode</title>
      <link>https://wushaoqiang.github.io/posts/golang-leetcode/</link>
      <pubDate>Sun, 17 Mar 2019 02:07:37 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/golang-leetcode/</guid>
      <description>此文章为做题时发现的不足
 Go语言中的结构体直接赋值是==值传递==，如果要用引用传递，需要这样struct1 := &amp;amp;struct2，也就是要使用取地址符号。但是如果本来struct2就是一个指针，那么就可以直接赋值了。 go func addTwoNumbers(l1 *ListNode, l2 *ListNode) *ListNode { Head := ListNode{} curr := &amp;amp;Head  &amp;mdash;-  给定一个字符串，找出其中不含有重复字符的最长子串的长度方法 - 穷举法：
func lengthOfLongestSubstring(s string) int { var max = 0 for i := 0; i &amp;lt; len(s); i++ { m := make(map[string]bool) for j := i; j &amp;lt; len(s); j++ { if _, ok := m[s[j:j+1]]; !ok { m[s[j:j+1]] = true if j == len(s)-1 { if max &amp;lt; j-i+1 { max = j - i + 1 } } } else { if max &amp;lt; j-i { max = j - i } break } } } return max }   另一个方法： ```go func lengthOfLongestSubstring(s string) int { var max = 0 i := 0 m := make(map[string]int) for j := 0; j &amp;lt; len(s); j++ {  	if _, ok := m[s[j:j+1]]; ok {</description>
    </item>
    
    <item>
      <title>Golang标准库--Unicode</title>
      <link>https://wushaoqiang.github.io/posts/golangstd-unicode/</link>
      <pubDate>Sun, 17 Mar 2019 02:06:01 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/golangstd-unicode/</guid>
      <description>unicode package utf8 utf8.go 这里就不详细分析源码了，只说函数的作用
&amp;mdash; FullRune(p []byte) bool  FullRune报告p中的字节是否以一个rune的完整UTF-8编码开始。
 无效的编码被认为是完整的rune，因为它将转换为宽度为1的错误符文rune。
&amp;mdash; FullRuneInString(s string) bool 和FullRune一样，只是传入了字符串
&amp;mdash; DecodeRune(p []byte) (r rune, size int) 这个函数将切片p中第一个rune返回，并且返回这个rune的大小。
如果p是空的，那么会返回RuneError,0
如果切片中的编码是无效的，那么会返回RuneError,1,对应上一个函数，当编码无效时依然返回true
&amp;mdash; DecodeRuneInString(s string) (r rune, size int) 同上，只是参数变成了字符串
&amp;mdash; func DecodeLastRune(p []byte) (r rune, size int) 只是从后面开始了，功能一样。
&amp;mdash; DecodeLastRuneInString(s string) (r rune, size int) 如上，参数换了字符串
&amp;mdash; RuneLen(r rune) int 返回一个rune的长度，也就是其大小
&amp;mdash; EncodeRune(p []byte, r rune) int 这个就是将rune写入到byte切片上
&amp;mdash; RuneCount(p []byte) int 返回整个切片里面rune的个数</description>
    </item>
    
    <item>
      <title>Golang标准库--String</title>
      <link>https://wushaoqiang.github.io/posts/golangstd-string/</link>
      <pubDate>Sun, 17 Mar 2019 02:04:07 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/golangstd-string/</guid>
      <description>目录 strings builder.go Builder 结构体 noescape(p unsafe.Pointer) unsafe.Pointer &amp;amp; copyCheck() (b *Builder) String() string &amp;amp; (b *Builder) Len() int &amp;amp; (b *Builder) Reset() (b *Builder) Grow(n int) 关于Write的方法 reader.go Reader 结构体 (r *Reader) Len() int &amp;amp; (r *Reader) Size() int64 关于读的方法 (r *Reader) UnreadRune() error (r *Reader) Seek(offset int64, whence int) (int64, error) strings.go  strings builder.go Builder 相当于bytes里面的buffer，并且方法也差不多。但是buffer更加全面
&amp;mdash; 结构体 // A Builder is used to efficiently build a string using Write methods.</description>
    </item>
    
    <item>
      <title>Golang标准库--Bytes</title>
      <link>https://wushaoqiang.github.io/posts/golangstd-bytes/</link>
      <pubDate>Sun, 17 Mar 2019 02:03:03 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/golangstd-bytes/</guid>
      <description>目录 bytes buffer.go Buffer 结构体 const of readOp (b *Buffer) Bytes() []byte (b *Buffer) String() string (b *Buffer) empty() bool (b *Buffer) Len() int (b *Buffer) Cap() int (b *Buffer) Truncate(n int) (b *Buffer) Reset() (b *Buffer) tryGrowByReslice(n int) (int, bool) (b *Buffer) grow(n int) int (b *Buffer) Grow(n int) (b *Buffer) Write(p []byte) (n int, err error) (b *Buffer) WriteString(s string) (n int, err error) makeSlice(n int) []byte (b *Buffer) WriteTo(w io.</description>
    </item>
    
    <item>
      <title>Golang标准库--Bufio</title>
      <link>https://wushaoqiang.github.io/posts/golangstd-bufio/</link>
      <pubDate>Sun, 17 Mar 2019 01:59:52 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/golangstd-bufio/</guid>
      <description>目录 bufio bufio.go 常量 Reader 结构体 常量 NewReaderSize(rd io.Reader, size int) *Reader NewReader(rd io.Reader) *Reader (r *Reader) Size() int (b *Reader) Reset(r io.Reader) &amp;amp; (b *Reader) reset(buf []byte, r io.Reader) (b *Reader) fill() (b *Reader) Peek(n int) ([]byte, error) (b *Reader) Discard(n int) (discarded int, err error) (b *Reader) Read(p []byte) (n int, err error) (b *Reader) ReadByte() (byte, error) (b *Reader) UnreadByte() (b *Reader) ReadRune() (r rune, size int, err error) (b *Reader) UnreadRune() error (b *Reader) Buffered() int (b *Reader) ReadSlice(delim byte) (line []byte, err error) (b *Reader) ReadLine() (line []byte, isPrefix bool, err error) (b *Reader) ReadBytes(delim byte) ([]byte, error) (b *Reader) ReadString(delim byte) (string, error) (b *Reader) WriteTo(w io.</description>
    </item>
    
    <item>
      <title>网络协议基础</title>
      <link>https://wushaoqiang.github.io/posts/internet-protocal/</link>
      <pubDate>Sun, 17 Mar 2019 01:58:00 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/internet-protocal/</guid>
      <description>OSI模型把网络通信的工作分为7层，分别是物理层、数据链路层、网络层、传输层、会话层、表示层和应用层
一直觉得自己的基础很不牢固，事实也确实是这样，希望自己能够系统的总结好计算机网络这本书
二、应用层 Web、电子邮件、DNS和对等文件分发等
2.1 应用层协议原理 2.1.1 网络应用程序体系结构 应用程序体系结构
 客户-服务器体系结构
 对等体系结构(P2P)
  现在大多数应用都是以客户-服务器体系结构
P2P面临的挑战
 下载比上传多很多
 安全性
 用户是否能自愿提供带宽、存储和计算资源
  最近比较火的一个名词区块链就是倡导去中心化的网络，也就是P2P
2.1.2 进程通信 在同一个端系统上(可以理解为同一部电脑)，进程间通信的规则由端系统上的操作系统决定
在不同端系统上，通过跨越计算机网络交换报文来相互通信
2.1.2.1 客户和服务器进程 发起通信的进程就是客户
等待联系的进程是服务器
2.1.2.2 进程与计算机网络之间的接口 进程通过一个称为套接字的软件接口向网络发送报文和从网络接收报文
这个套接字就好比如一个房子的大门，发送或者接收都要先开门
而这里把进程比作房子，运输层协议(TCP等)比作两个房子的路
所以套接字是应用层和运输层的接口，也叫应用程序编程接口(API)
2.1.2.3 进程寻址 主机由IP地址标识
指定的进程由端口号标识
2.1.3 可供应用程序使用的运输服务 根据运输层所提供的服务来决定用哪种运输层协议
2.1.3.1 可靠数据传输 当一个运输协议提供这种服务时，发送进程只要将其数据传递进套接字，就可以完全相信该数据将能无差错地到达接收进程
有些能够容忍数据丢失的应用可以不使用可靠数据传输
2.1.3.2 吞吐量 吞吐量就是发送进程能够向接收进程交付比特的速率
具有吞吐量要求的应用被称为带宽敏感应用
否则就称为弹性应用
2.1.3.3 定时 对于实时要求较高的应用
2.1.3.4 安全性 防止数据以某种方式在两个进程之间被观察到
安全包括
 机密性
 完整性
 端点鉴别</description>
    </item>
    
    <item>
      <title>Web框架</title>
      <link>https://wushaoqiang.github.io/posts/web-strcuture/</link>
      <pubDate>Sun, 17 Mar 2019 01:53:57 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/web-strcuture/</guid>
      <description>这篇文章是参考人世间博主写的一篇文章，这里哪里作为自己了解Gin框架的例子，笔者想在这做初步了解后再去深入了解源码，到时候再写一篇博客来说说Gin源码。
Gin 路由常用方法 func (group *RouterGroup) POST(relativePath string, handlers ...HandlerFunc) IRoutes func (group *RouterGroup) GET(relativePath string, handlers ...HandlerFunc) IRoutes type HandlerFunc func(*Context)  可以看出路由需要的参数是
 相对路径
 处理函数
  这里面是Gin自己定义的一个HandlerFunc，和标准库里面的有所不同，这里的gin.*Context包含了标准库里的ResponseWriter和*http.Request还有一些其它
介绍一些函数 // Query()	是匹配url上的参数，匹配不到就返回空字符串 // DefaultQuery() 也是匹配，如果匹配不到就用默认值 // 127.0.0.1:8000/post?id=111&amp;amp;page=222 // 如果用curl，则需要在&amp;amp;前面加\ id := c.Query(&amp;quot;id&amp;quot;) page := c.DefaultQuery(&amp;quot;page&amp;quot;, &amp;quot;0&amp;quot;) //这个是在表单上获取信息，通过POST方法发送过来的数据 name := c.PostForm(&amp;quot;name&amp;quot;) message := c.PostForm(&amp;quot;message&amp;quot;)  一个完整的路由 router.GET(&amp;quot;/welcome&amp;quot;, func(c *gin.Context) { firstname := c.DefaultQuery(&amp;quot;firstname&amp;quot;, &amp;quot;Guest&amp;quot;) lastname := c.Query(&amp;quot;lastname&amp;quot;) c.</description>
    </item>
    
    <item>
      <title>Linux命令笔记</title>
      <link>https://wushaoqiang.github.io/posts/linux-note/</link>
      <pubDate>Sun, 17 Mar 2019 01:52:15 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/linux-note/</guid>
      <description>Command 这里只是笔者对Linux常用命令的笔记，方便自己查询
ifconfig 查看网络连接
lsof -i:8000 查看端口8000占用情况
kill -9 PID 把某个PID的进程结束了，kill还有许多flag，1:挂起， 2:中断 ，3:退出
mkdir -p /1/2/3/4 可以一次创建多层文件夹
pkill -f &amp;lt;name&amp;gt; 可以直接kill掉一个已知名字的进程
把脚本放进/etc/init.d/里面就可以自启动
chown user:group &amp;lt;file&amp;gt; 改变文件持有
磁盘 du -hsc &amp;lt;path&amp;gt; 查看路径占用磁盘大小
ncdu 更友好的查看磁盘占用情况的一个命令，需要安装
df -h查看磁盘占用情况
别名 alias &amp;lt;name&amp;gt;=&amp;quot;&amp;lt;command&amp;gt;&amp;quot; 用别名调用命令(适用于长命令)，如果需要持久化的话，需要写入.bashrc
查找文件 find &amp;lt;path&amp;gt; -name &amp;quot;*.log&amp;quot; 寻找在路径里面结尾为.log的文件，同理，想要查找一类文件可以用这个命令
find &amp;lt;path&amp;gt; ! -name &amp;quot;*.log&amp;quot; 与上面刚好相反
find -mtime &amp;lt;number&amp;gt;这个命令还可以根据修改时间
匹配 grep -r &amp;quot;error&amp;quot; &amp;lt;path or file&amp;gt; 会打印出所有含有error的字段
查看CPU&amp;amp;内存占用情况 top 这个命令对界面不太友好
htop 这个对阅读更加友好
update 能够看到电脑持续开机时间</description>
    </item>
    
    <item>
      <title>Hugo建博客</title>
      <link>https://wushaoqiang.github.io/posts/learn-hugo/</link>
      <pubDate>Sat, 16 Mar 2019 22:33:20 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/learn-hugo/</guid>
      <description>笔者用的是Hugo来搭建个人博客，表示Hugo实在太强，而且可扩展性很高，这也代表文档也很长。。。
所以笔者收录一些比较常用的作为笔记，也希望能够帮到别人
以下命令都是以我自己建博客的为例
创建一个网站 hugo new site blog 这个命令会在目录里创建一个新的blog目录
这个blog目录包含以下：
 archetypes/ content/ data/ layouts/ static/ themes/ config.toml  archetypes/ 这里一开始会有一个default文件，后面再讲有什么用，先看看文件
--- title: &amp;quot;{{ replace .Name &amp;quot;-&amp;quot; &amp;quot; &amp;quot; | title }}&amp;quot; date: {{ .Date }} draft: true ---  content/ 这里就是博客的主要内容的根目录，我们创建的博客文章就应该放在这个文件夹里(不是直接)
创建一个博客文章hugo new posts/learn-hugo.md，创建完后会发现文件在content/posts/learn-hugo.md
打开文件看一下，可以发现创建的新文件里面是有内容的
--- title: &amp;quot;Learn Hugo&amp;quot; date: 2019-03-16T22:33:20+08:00 draft: true ---  这就和我们上面说到的archetypes/default.md有关，这里可以自动填充一些信息，方便我们写博客
theme/ 这里是放置博客主题的文件夹，Hugo有很多开源的主题，可以去官网找找看，笔者用的是飞雪无情这位博主开源出来的Maupassant，笔者刚开始也按照这位博主的配置方法来配置博客，等后面对Hugo的配置了解更加深入时，再尝试配置。Maupassant的仓库地址，大家还可以顺手点个星，表示支持
具体如何安装也很简单，可以参照github的使用方法
config.toml 这个文件是配置我们的一些博客信息以及Hugo的配置
## 这个是我们主页的地址 baseURL = &amp;quot;https://wushaoqiang.github.io&amp;quot; languageCode = &amp;quot;en-us&amp;quot; ## 博客的标题(不是某篇文章，是整个博客) title = &amp;quot;Gavin&#39;s Blog&amp;quot; ## 这里就是设定你要的主题，而且主题必须要下载到theme/目录 theme = &amp;quot;maupassant&amp;quot; ## 保持分类的原始名字（false会做转小写处理） preserveTaxonomyNames = true ## 是否禁止URL Path转小写 disablePathToLower = true ## 这个会配置每一篇文章最后面的Copyright的作者名字 ## © 2019 Gavin&#39;s Blog By Gavin [author] name = &amp;quot;Gavin&amp;quot; [params] author = &amp;quot;Gavin&amp;quot; ## 这是一个副标题，在主标题的下方 subtitle = &amp;quot;Gopher，后端开发，网络基础，WEB协议、架构、存储、缓冲、安全，学习笔记&amp;quot; keywords = &amp;quot;Golang,Gavin,Blog&amp;quot; ## 这个是对阅读量的计数 busuanzi = true ## 这个是为了开评论区 [params.</description>
    </item>
    
    <item>
      <title>Git用法总结</title>
      <link>https://wushaoqiang.github.io/posts/learn-git/</link>
      <pubDate>Fri, 15 Mar 2019 18:02:59 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/learn-git/</guid>
      <description>这篇博客是笔者总结学习git的过程，不是一篇专业性很强的文章，主要是笔记
主要参考廖雪峰的博客学习
笔者之前对Git有错误的理解(因为之前没学过，也只是听过)，总以为Github就是Git，其实Github是Git出来后才被创建的，为开源项目免费提供Git存储。
无Github,纯属本地的Git &amp;mdash; 那么什么是Git呢？ Git是目前世界上最先进的分布式版本控制系统
分布式：Git和其它集中式版本控制系统最大的区别，Git也可以有一个24小时开机的服务器来充当中央服务器，但这个服务器仅仅是为了让大家方便交换各自修改的。
版本控制：因为我们的代码要不断的完善，所以就有版本之分啦。
就算是我们自己在电脑上开发，也可以为自己代码创建版本库，用来记录修改和方便管理。
&amp;mdash; 创建版本库 在想要创建版本库的文件夹里面，输入命令
git init  就可以看到文件夹里面多了一个隐藏的文件夹.git
添加文件到我们新建的版本库里面用
//将某一个文件添加进缓冲区 git add &amp;lt;file&amp;gt; //将.git文件夹 所在的文件 里所有的文件添加进缓冲区 //所以不管你是在某一个子文件夹用这个命令，执行效果是一样的 git add -A //这个就是将缓冲区的提交到版本库里，并且携带提交信息 //(强烈推荐要写message，这样可以提醒那个时候修改了什么) git commit -m &amp;lt;message&amp;gt;  我们可以把代码所在区域分成
 工作区 缓冲区 当前分支  理解这几个工作区域会有助于理解命令的作用。
工作区：我们自己电脑编辑代码的地方
缓冲区：就是我们把修改过的文件放到一个区域装着，如果后面我又对这个文件做修改了，就可以继续往里面添加(同文件覆盖)
当前分支：就是我们使用commit后将缓冲区的文件提交上去的地方
&amp;mdash; 查看状态 git status  这个命令会告诉我们哪些被修改过的文件被添加到了缓冲去，哪些被修改的文件没有。
On branch master Your branch is behind &#39;origin/master&#39; by 1 commit, and can be fast-forwarded. (use &amp;quot;git pull&amp;quot; to update your local branch) Untracked files (use &amp;quot;git add &amp;lt;file&amp;gt;.</description>
    </item>
    
    <item>
      <title>Go琐碎笔记</title>
      <link>https://wushaoqiang.github.io/posts/learningGo/</link>
      <pubDate>Thu, 14 Mar 2019 16:10:59 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/learningGo/</guid>
      <description>在test文件要是以_test.go结尾，或者是在文件开头加上// +build (tag) 其中tag是自己定的，然后测试的时候在Terminal输入
2019.2.16 go test -tags tagname
构造数组可以先 make([]int,0)
然后 再使用函数：func append(slice []Type, elems ...Type) []Type
unicode.IsLetter(r rune) bool是判断是否为字母，而不是ASCII
res, ok := map[...] 中的ok变量可以用来判断key是否存在
[]rune可以直接转换为字符串string([]rune)
2019.2.17 谨记！ ： 切片和Map在函数传递都是指针传递(引用)
func normalize(cleartext string) string { var b strings.Builder for _, r := range cleartext { if unicode.IsLetter(r) || unicode.IsDigit(r) { b.WriteRune(unicode.ToLower(r)) } } return b.String() }  b.WriteRune(unicode.ToLower(r)) :可以用这种方式代替append()
norm = fmt.Sprintf(&amp;quot;%-[1]*s&amp;quot;, c*r, norm): 其实就是将出c*r代入到[1]*形成的在右侧填充空格
|类型 |默认值 | |int | 0 | |string|“” | | bool | false |  定义一个常量：const name type = value value是必须要有的 枚举：Go没有枚举，用const构造，有两种方法(参考这里的)</description>
    </item>
    
  </channel>
</rss>