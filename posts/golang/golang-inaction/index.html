<!doctype html>
<html lang="en-us">
<head>

    <meta charset="utf-8">
    <meta name="generator" content="Hugo 0.40.1" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <title>Go语言实战 | Gavin&#39;s Blog</title>
    <meta property="og:title" content="Go语言实战 - Gavin&#39;s Blog">
    <meta property="og:type" content="article">
        
    <meta property="article:published_time" content="2019-03-17T02:11:56&#43;08:00">
        
        
    <meta property="article:modified_time" content="2019-03-17T02:11:56&#43;08:00">
        
    <meta name="Keywords" content="Golang,Gavin,Blog">
    <meta name="description" content="Go语言实战">
        
    <meta name="author" content="Gavin">
    <meta property="og:url" content="https://wushaoqiang.github.io/posts/golang/golang-inaction/">
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">

    <link rel="stylesheet" href="/css/normalize.css">
    
        <link rel="stylesheet" href="/css/prism.css">
    
    <link rel="stylesheet" href="/css/style.css">
    <script type="text/javascript" src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script>

    


    
    
</head>

<body>
<header id="header" class="clearfix">
    <div class="container">
        <div class="col-group">
            <div class="site-name ">
                
                    <a id="logo" href="https://wushaoqiang.github.io">
                        Gavin&#39;s Blog
                    </a>
                
                <p class="description">Gopher，后端开发，网络基础，WEB协议、架构、存储、缓冲、安全，学习笔记</p>
            </div>
            <div>
                <nav id="nav-menu" class="clearfix">
                    <a class="" href="https://wushaoqiang.github.io">首页</a>
                    
                    <a  href="https://wushaoqiang.github.io/archives/" title="归档">归档</a>
                    
                    <a  href="https://wushaoqiang.github.io/about/" title="关于">关于</a>
                    
                </nav>
            </div>
        </div>
    </div>
</header>


<div id="body">
    <div class="container">
        <div class="col-group">

            <div class="col-8" id="main">
                <div class="res-cons">
                    <article class="post">
                        <header>
                            <h1 class="post-title">Go语言实战</h1>
                        </header>
                        <date class="post-meta meta-date">
                            2019年3月17日
                        </date>
                        
                        <div class="post-meta">
                            <span>|</span>
                            
                                <span class="meta-category"><a href="https://wushaoqiang.github.io/categories/Golang">Golang</a></span>
                            
                        </div>
                        
                        
                        <div class="post-meta">
                            <span id="busuanzi_container_page_pv">|<span id="busuanzi_value_page_pv"></span><span> 阅读</span></span>
                        </div>
                        
                        <div class="post-content">
                            

<p><strong>Go语言优点</strong>：</p>

<ul>
<li><p>Go语言可以说是夹在C/C++和Python这两类语言之间，即提供了较高的性能，又使得开发更加迅速了。</p></li>

<li><p>Go语言内置并发机制，对并发有着更好的性能</p></li>

<li><p>Go语言自带垃圾回收器</p></li>

<li><p>goroutine使用的内存比线程要少，所以常常能够成千上万个goroutine并发</p></li>
</ul>

<h1 id="第六章-并发">第六章 并发</h1>

<h2 id="概念">概念</h2>

<ul>
<li>进程：当运行一个应用程序时，操作系统会为这个应用程序启动一个进程，可以将这个进程看作一个包含了应用程序在运行中需要用到和维护的各种资源</li>
<li>线程：一个线程是一个空间，这个空间会被操作系统调度来运行函数中所写的代码，线程会被调度到CPU上运行。</li>
<li>每个逻辑处理器绑定在一个线程上</li>
<li>逻辑处理器可以调度goroutine</li>
<li>并发：某一个事情的停止，另一个事情就开始(单线程)</li>
<li>并行：同时开始做(多线程)</li>
</ul>

<h2 id="goroutine">goroutine</h2>

<h3 id="一个创建goroutine的示例">一个创建goroutine的示例</h3>

<pre><code class="language-go">package main

import (
	&quot;fmt&quot;
	&quot;runtime&quot;
	&quot;sync&quot;
)

// main is the entry point for all Go programs.
func main() {
	// Allocate 1 logical processor for the scheduler to use.
	runtime.GOMAXPROCS(1)

	// wg is used to wait for the program to finish.
	// Add a count of two, one for each goroutine.
	var wg sync.WaitGroup
	wg.Add(5)

	fmt.Println(&quot;Start Goroutines&quot;)

	// Declare an anonymous function and create a goroutine.
	go func() {
		// Schedule the call to Done to tell main we are done.
		defer wg.Done()

		// Display the alphabet three times
		for count := 0; count &lt; 3; count++ {
			for char := 'a'; char &lt; 'a'+26; char++ {
				fmt.Printf(&quot;%c &quot;, char)
			}
		}
	}()

	// Declare an anonymous function and create a goroutine.
	go func() {
		// Schedule the call to Done to tell main we are done.
		defer wg.Done()

		// Display the alphabet three times
		for count := 0; count &lt; 3; count++ {
			for char := 'A'; char &lt; 'A'+26; char++ {
				fmt.Printf(&quot;%c &quot;, char)
			}
		}
	}()

	go func() {
		defer wg.Done()

		for count := 0; count &lt; 3; count++ {
			for i := 1; i &lt; 24; i++ {
				fmt.Print(&quot; ^ &quot;)
			}
			// time.Sleep(1 * time.Second)
		}
	}()

	go func() {
		defer wg.Done()

		for count := 0; count &lt; 3; count++ {
			for i := 1; i &lt; 24; i++ {
				fmt.Print(&quot; * &quot;)
			}
			// time.Sleep(1 * time.Second)
		}
	}()

	go func() {
		defer wg.Done()

		for count := 0; count &lt; 3; count++ {
			for i := 1; i &lt; 24; i++ {
				fmt.Print(&quot; - &quot;)
			}
			// time.Sleep(1 * time.Second)
		}
	}()

	// Wait for the goroutines to finish.
	fmt.Println(&quot;Waiting To Finish&quot;)
	wg.Wait()

	fmt.Println(&quot;\nTerminating Program&quot;)
}
</code></pre>

<p><strong>逻辑处理器处理顺序并非完成按照队列形式</strong></p>

<p>按队列应该从第一个goroutine开始执行(在没有被阻塞的情况下)，然后是第二个开始执行。但是结果告诉我们队列的第一个是程序中最后的一个goroutine，第二个是程序中的第一个goroutine，以此类推。</p>

<p>所以Goroutine并发的时候需要借助别的工具来达到同步或者顺序。</p>

<h3 id="tips">Tips</h3>

<ul>
<li><p>使用多个逻辑处理器并不意味着性能更好，在修改配置参数时，需要配合基准测试来评估程序的运行效果</p></li>

<li><p>基准测试可以测出性能效果</p></li>
</ul>

<h2 id="竞争状态-race-condition">竞争状态(race condition)</h2>

<p>示例程序</p>

<pre><code class="language-go">package main

import (
	&quot;fmt&quot;
	&quot;runtime&quot;
	&quot;sync&quot;
)

var (
	// counter is a variable incremented by all goroutines.
	counter int

	// wg is used to wait for the program to finish.
	wg sync.WaitGroup
)

// main is the entry point for all Go programs.
func main() {
	// Add a count of two, one for each goroutine.
	wg.Add(2)

	// Create two goroutines.
	go incCounter(1)
	go incCounter(2)

	// Wait for the goroutines to finish.
	wg.Wait()
	fmt.Println(&quot;Final Counter:&quot;, counter)
}

// incCounter increments the package level counter variable.
func incCounter(id int) {
	// Schedule the call to Done to tell main we are done.
	defer wg.Done()

	for count := 0; count &lt; 2; count++ {
		// Capture the value of Counter.
		value := counter

		// Yield the thread and be placed back in queue.
		runtime.Gosched()

		// Increment our local value of Counter.
		value++

		// Store the value back into Counter.
		counter = value
	}
}
</code></pre>

<h3 id="tips-1">Tips</h3>

<ul>
<li>可以用<code>go build -race</code>来检测竟态</li>
</ul>

<h2 id="锁住共享资源">锁住共享资源</h2>

<h3 id="原子函数">原子函数</h3>

<p><code>atomic.AddInt64()</code></p>

<p><code>atomic.LoadInt64()</code></p>

<p><code>atomic.StoreInt64()</code></p>

<p>等等</p>

<h3 id="互斥锁-mutex">互斥锁(mutex)</h3>

<pre><code class="language-go">		mutex.Lock()
		{
			// Capture the value of counter.
			value := counter

			// Yield the thread and be placed back in queue.
			runtime.Gosched()

			// Increment our local value of counter.
			value++

			// Store the value back into counter.
			counter = value
		}
		mutex.Unlock()
</code></pre>

<p>临界区有<code>runtime.Gosched()</code>将goroutine退出，但由于临界区只能允许一个goroutine进入，所以在当前goroutine退出当前线程后，调度器会再次分配这个goroutine继续运行。</p>

<h2 id="通道">通道</h2>

<p>可以通过通道共享内置类型、命名类型、结构类型和引用类型的值或指针</p>

<h3 id="无缓冲通道">无缓冲通道</h3>

<p>阻塞条件：发送和接收有一个未准备好都会阻塞</p>

<p>创建 ： <code>unbuffered := make(chan int)</code></p>

<p>示例代码：</p>

<pre><code class="language-go">func main() {
	// Create an unbuffered channel.
	baton := make(chan int)

	// Add a count of one for the last runner.
	wg.Add(1)

	// First runner to his mark.
	go Runner(baton)

	// Start the race.
	baton &lt;- 1

	// Wait for the race to finish.
	wg.Wait()
}

// Runner simulates a person running in the relay race.
func Runner(baton chan int) {
	var newRunner int

	// Wait to receive the baton.
	runner := &lt;-baton

	// Start running around the track.
	fmt.Printf(&quot;Runner %d Running With Baton\n&quot;, runner)

	// New runner to the line.
	if runner != 4 {
		newRunner = runner + 1
		fmt.Printf(&quot;Runner %d To The Line\n&quot;, newRunner)
		go Runner(baton)
	}

	// Running around the track.
	time.Sleep(100 * time.Millisecond)

	// Is the race over.
	if runner == 4 {
		fmt.Printf(&quot;Runner %d Finished, Race Over\n&quot;, runner)
		wg.Done()
		return
	}

	// Exchange the baton for the next runner.
	fmt.Printf(&quot;Runner %d Exchange With Runner %d\n&quot;,
		runner,
		newRunner)

	baton &lt;- newRunner
}
</code></pre>

<p>当启动又一个goroutine的时候，新启动的goroutine会被阻塞，因为通道还没有传入数据，当前一个goroutine运行到最后一条代码才会把数据传入通道，新的goroutine才能在通道获得数据恢复运行。</p>

<h3 id="有缓冲的通道">有缓冲的通道</h3>

<p>阻塞条件
- 发送阻塞 ： 缓冲区满了
- 接收阻塞 ： 缓冲区空了</p>

<p>创建 ： <code>buffered := make(chan int)</code></p>

<p>示例代码：</p>

<pre><code class="language-go">// main is the entry point for all Go programs.
func main() {
	// Create a buffered channel to manage the task load.
	tasks := make(chan string, taskLoad)

	// Launch goroutines to handle the work.
	wg.Add(numberGoroutines)
	for gr := 1; gr &lt;= numberGoroutines; gr++ {
		go worker(tasks, gr)
	}

	// Add a bunch of work to get done.
	for post := 1; post &lt;= taskLoad; post++ {
		tasks &lt;- fmt.Sprintf(&quot;Task : %d&quot;, post)
	}

	// Close the channel so the goroutines will quit
	// when all the work is done.
	close(tasks)

	// Wait for all the work to get done.
	wg.Wait()
}

// worker is launched as a goroutine to process work from
// the buffered channel.
func worker(tasks chan string, worker int) {
	// Report that we just returned.
	defer wg.Done()

	for {
		// Wait for work to be assigned.
		task, ok := &lt;-tasks
		if !ok {
			// This means the channel is empty and closed.
			fmt.Printf(&quot;Worker: %d : Shutting Down\n&quot;, worker)
			return
		}

		// Display we are starting the work.
		fmt.Printf(&quot;Worker: %d : Started %s\n&quot;, worker, task)

		// Randomly wait to simulate work time.
		sleep := rand.Int63n(100)
		time.Sleep(time.Duration(sleep) * time.Millisecond)

		// Display we finished the work.
		fmt.Printf(&quot;Worker: %d : Completed %s\n&quot;, worker, task)
	}
}
</code></pre>

<ul>
<li>多个goroutine使用同一个通道获取task，当task缓冲完的时候关闭通道不会影响读取通道数据。当worker读取通道task的ok为false时就说明通道的task已经全部被取出了，所以worker就可以退出了。</li>
<li>当通道未被关闭时<code>task, ok := &lt;-tasks</code>会发生死锁<code>deadlock</code></li>
</ul>

<h1 id="第七章-并发模式">第七章 并发模式</h1>

<h2 id="runner">runner</h2>

<p>runner展示如何使用通道来监视程序的执行时间</p>

<p>示例代码 main.go</p>

<pre><code class="language-go">package main

import (
	&quot;log&quot;
	&quot;os&quot;
	&quot;time&quot;

	&quot;github.com/goinaction/code/chapter7/patterns/runner&quot;
)

// timeout is the number of second the program has to finish.
const timeout = 3 * time.Second

// main is the entry point for the program.
func main() {
	log.Println(&quot;Starting work.&quot;)

	// Create a new timer value for this run.
	r := runner.New(timeout)

	// Add the tasks to be run.
	r.Add(createTask(), createTask(), createTask())

	// Run the tasks and handle the result.
	if err := r.Start(); err != nil {
		switch err {
		case runner.ErrTimeout:
			log.Println(&quot;Terminating due to timeout.&quot;)
			os.Exit(1)
		case runner.ErrInterrupt:
			log.Println(&quot;Terminating due to interrupt.&quot;)
			os.Exit(2)
		}
	}

	log.Println(&quot;Process ended.&quot;)
}

// createTask returns an example task that sleeps for the specified
// number of seconds based on the id.
func createTask() func(int) {
	return func(id int) {
		log.Printf(&quot;Processor - Task #%d.&quot;, id)
		time.Sleep(time.Duration(id) * time.Second)
	}
}
</code></pre>

<p>runner.go</p>

<pre><code class="language-go">package runner

import (
	&quot;errors&quot;
	&quot;os&quot;
	&quot;os/signal&quot;
	&quot;time&quot;
)

// Runner runs a set of tasks within a given timeout and can be
// shut down on an operating system interrupt.
type Runner struct {
	// interrupt channel reports a signal from the
	// operating system.
	interrupt chan os.Signal

	// complete channel reports that processing is done.
	complete chan error

	// timeout reports that time has run out.
	timeout &lt;-chan time.Time

	// tasks holds a set of functions that are executed
	// synchronously in index order.
	tasks []func(int)
}

// ErrTimeout is returned when a value is received on the timeout channel.
var ErrTimeout = errors.New(&quot;received timeout&quot;)

// ErrInterrupt is returned when an event from the OS is received.
var ErrInterrupt = errors.New(&quot;received interrupt&quot;)

// New returns a new ready-to-use Runner.
func New(d time.Duration) *Runner {
	return &amp;Runner{
		interrupt: make(chan os.Signal, 1),
		complete:  make(chan error),
		timeout:   time.After(d),
	}
}

// Add attaches tasks to the Runner. A task is a function that
// takes an int ID.
func (r *Runner) Add(tasks ...func(int)) {
	r.tasks = append(r.tasks, tasks...)
}

// Start runs all tasks and monitors channel events.
func (r *Runner) Start() error {
	// We want to receive all interrupt based signals.
	signal.Notify(r.interrupt, os.Interrupt)

	// Run the different tasks on a different goroutine.
	go func() {
		r.complete &lt;- r.run()
	}()

	select {
	// Signaled when processing is done.
	case err := &lt;-r.complete:
		return err

	// Signaled when we run out of time.
	case &lt;-r.timeout:
		return ErrTimeout
	}
}

// run executes each registered task.
func (r *Runner) run() error {
	for id, task := range r.tasks {
		// Check for an interrupt signal from the OS.
		if r.gotInterrupt() {
			return ErrInterrupt
		}

		// Execute the registered task.
		task(id)
	}

	return nil
}

// gotInterrupt verifies if the interrupt signal has been issued.
func (r *Runner) gotInterrupt() bool {
	select {
	// Signaled when an interrupt event is sent.
	case &lt;-r.interrupt:
		// Stop receiving any further signals.
		signal.Stop(r.interrupt)
		return true

	// Continue running as normal.
	default:
		return false
	}
}

</code></pre>

<ul>
<li><code>interrupt</code>用缓冲通道是因为，当在系统输入<code>Ctrl + C</code>时，可以先将指令放在缓冲区里，这样当程序不在接收通道值的时候也能够传入数据，不发生阻塞，等到程序要读取系统有无输入终止命令，只用检查缓冲区就可以判断出。</li>
<li>注意，为了不让接收<code>interrupt</code>通道时发生阻塞，在<code>select</code>语句用了<code>default</code>，这样在<code>case &lt;-r.interrupt</code>的时候不会因为取不到值而发生阻塞。</li>
</ul>

<h2 id="pool">pool</h2>

<p>展示如何使用有缓冲通道实现资源池，来管理任意数量的goroutine之间共享及独立使用资源</p>

<p>为什么要用pool？因为当我们经常用的资源来来回回的创建和删除(内存回收)的时候，性能会大打折扣，所以我们用pool将资源放在里面，供程序取出使用，使用完后又放回(存储在通道缓冲区里)</p>

<p>示例代码 pool.go</p>

<pre><code class="language-go">// Example provided with help from Fatih Arslan and Gabriel Aszalos.
// Package pool manages a user defined set of resources.
package pool

import (
	&quot;errors&quot;
	&quot;io&quot;
	&quot;log&quot;
	&quot;sync&quot;
)

// Pool manages a set of resources that can be shared safely by
// multiple goroutines. The resource being managed must implement
// the io.Closer interface.
type Pool struct {
	m         sync.Mutex
	resources chan io.Closer
	factory   func() (io.Closer, error)
	closed    bool
}

// ErrPoolClosed is returned when an Acquire returns on a
// closed pool.
var ErrPoolClosed = errors.New(&quot;Pool has been closed.&quot;)

// New creates a pool that manages resources. A pool requires a
// function that can allocate a new resource and the size of
// the pool.
func New(fn func() (io.Closer, error), size uint) (*Pool, error) {
	if size &lt;= 0 {
		return nil, errors.New(&quot;Size value too small.&quot;)
	}

	return &amp;Pool{
		factory:   fn,
		resources: make(chan io.Closer, size),
	}, nil
}

// Acquire retrieves a resource	from the pool.
func (p *Pool) Acquire() (io.Closer, error) {
	select {
	// Check for a free resource.
	case r, ok := &lt;-p.resources:
		log.Println(&quot;Acquire:&quot;, &quot;Shared Resource&quot;)
		if !ok {
			return nil, ErrPoolClosed
		}
		return r, nil

	// Provide a new resource since there are none available.
	default:
		log.Println(&quot;Acquire:&quot;, &quot;New Resource&quot;)
		return p.factory()
	}
}

// Release places a new resource onto the pool.
func (p *Pool) Release(r io.Closer) {
	// Secure this operation with the Close operation.
	p.m.Lock()
	defer p.m.Unlock()

	// If the pool is closed, discard the resource.
	if p.closed {
		r.Close()
		return
	}

	select {
	// Attempt to place the new resource on the queue.
	case p.resources &lt;- r:
		log.Println(&quot;Release:&quot;, &quot;In Queue&quot;)

	// If the queue is already at cap we close the resource.
	default:
		log.Println(&quot;Release:&quot;, &quot;Closing&quot;)
		r.Close()
	}
}

// Close will shutdown the pool and close all existing resources.
func (p *Pool) Close() {
	// Secure this operation with the Release operation.
	p.m.Lock()
	defer p.m.Unlock()

	// If the pool is already close, don't do anything.
	if p.closed {
		return
	}

	// Set the pool as closed.
	p.closed = true

	// Close the channel before we drain the channel of its
	// resources. If we don't do this, we will have a deadlock.
	close(p.resources)

	// Close the resources
	for r := range p.resources {
		r.Close()
	}
}

</code></pre>

<p>Pool结构体的作用：</p>

<ul>
<li><p>互斥锁是为了保证在多个goroutine访问pool的时候能够在一些读取写入操作避免竟态</p></li>

<li><p>缓冲通道是为了保存共享资源的</p></li>

<li><p>factory是一个函数类型，当pool需要新的资源时，可以用这个函数创建</p></li>

<li><p>closed标志pool是否被关闭，当pool关闭时要将所有资源清空(包括还没来得及还的，在还的时候也要判断pool是否以及关了。)</p></li>
</ul>

<p>函数作用：</p>

<ul>
<li><p><code>New()</code>创建pool</p></li>

<li><p><code>Close()</code>关闭pool并且清空通道</p></li>

<li><p><code>Acquire()</code>获得资源，如果资源不够就创建资源</p></li>

<li><p><code>Release()</code>释放资源，如果池满就抛弃资源</p></li>
</ul>

<p>main.go</p>

<pre><code class="language-go">// This sample program demonstrates how to use the pool package
// to share a simulated set of database connections.
package main

import (
	&quot;io&quot;
	&quot;log&quot;
	&quot;math/rand&quot;
	&quot;sync&quot;
	&quot;sync/atomic&quot;
	&quot;time&quot;

	&quot;github.com/goinaction/code/chapter7/patterns/pool&quot;
)

const (
	maxGoroutines   = 25 // the number of routines to use.
	pooledResources = 2  // number of resources in the pool
)

// dbConnection simulates a resource to share.
type dbConnection struct {
	ID int32
}

// Close implements the io.Closer interface so dbConnection
// can be managed by the pool. Close performs any resource
// release management.
func (dbConn *dbConnection) Close() error {
	log.Println(&quot;Close: Connection&quot;, dbConn.ID)
	return nil
}

// idCounter provides support for giving each connection a unique id.
var idCounter int32

// createConnection is a factory method that will be called by
// the pool when a new connection is needed.
func createConnection() (io.Closer, error) {
	id := atomic.AddInt32(&amp;idCounter, 1)
	log.Println(&quot;Create: New Connection&quot;, id)

	return &amp;dbConnection{id}, nil
}

// main is the entry point for all Go programs.
func main() {
	var wg sync.WaitGroup
	wg.Add(maxGoroutines)

	// Create the pool to manage our connections.
	p, err := pool.New(createConnection, pooledResources)
	if err != nil {
		log.Println(err)
	}

	// Perform queries using connections from the pool.
	for query := 0; query &lt; maxGoroutines; query++ {
		// Each goroutine needs its own copy of the query
		// value else they will all be sharing the same query
		// variable.
		go func(q int) {
			performQueries(q, p)
			wg.Done()
		}(query)
		time.Sleep(1 * time.Second)
	}

	// Wait for the goroutines to finish.
	wg.Wait()

	// Close the pool.
	log.Println(&quot;Shutdown Program.&quot;)
	p.Close()
}

// performQueries tests the resource pool of connections.
func performQueries(query int, p *pool.Pool) {
	// Acquire a connection from the pool.
	conn, err := p.Acquire()
	if err != nil {
		log.Println(err)
		return
	}

	// Release the connection back to the pool.
	defer p.Release(conn)

	// Wait to simulate a query response.
	time.Sleep(time.Duration(rand.Intn(10)) * time.Millisecond)
	log.Printf(&quot;Query: QID[%d] CID[%d]\n&quot;, query, conn.(*dbConnection).ID)
}
</code></pre>

<p>在这里，我们创建25个goroutine</p>

<ul>
<li><p>如果创建的很快的话，就类似于这个程序一下子要很多个资源，因为资源池一开始是没有资源的，所以需要不断创建新的资源，等到了有资源用完想放回池的时候，因为池只能容纳2个，所以只能放最先被释放的两个，其它资源全部关闭，等到了主函数将池关闭时，才释放缓冲区的两个资源。但是程序可能还没释放资源就已经要创建25个资源了，所以并没有达到效果。</p></li>

<li><p>如果goroutine创建的比较慢，也就是说一个goroutine运行完了，另一个goroutine还没有开始，这个时候第一个goroutine用过的资源，释放放回到pool中，就可以被后面创建的goroutine使用，因此就达到了资源复用。</p></li>
</ul>

<h2 id="work">work</h2>

<p>work包的目的是展示如何使用无缓冲的通道来创建一个goroutine池，goroutine池就是一个可以把任务放进去跑的池</p>

<p>比如示例代码中的<code>Task()</code>，只要对象实现了<code>Task()</code>方法，那么它就实现了Worker接口，就可以放到池中去执行(只要池中还有位置)
示例代码 work.go</p>

<pre><code class="language-go">// Example provided with help from Jason Waldrip.
// Package work manages a pool of goroutines to perform work.
package work

import &quot;sync&quot;

// Worker must be implemented by types that want to use
// the work pool.
type Worker interface {
	Task()
}

// Pool provides a pool of goroutines that can execute any Worker
// tasks that are submitted.
type Pool struct {
	work chan Worker
	wg   sync.WaitGroup
}

// New creates a new work pool.
func New(maxGoroutines int) *Pool {
	p := Pool{
		work: make(chan Worker),
	}

	p.wg.Add(maxGoroutines)
	for i := 0; i &lt; maxGoroutines; i++ {
		go func() {
			for w := range p.work {
				w.Task()
			}
			p.wg.Done()
		}()
	}

	return &amp;p
}

// Run submits work to the pool.
func (p *Pool) Run(w Worker) {
	p.work &lt;- w
}

// Shutdown waits for all the goroutines to shutdown.
func (p *Pool) Shutdown() {
	close(p.work)
	p.wg.Wait()
}
</code></pre>

<ul>
<li>Worker是一个接口，用来表明只有实现了<code>Task()</code>函数才能够被当成池中的对象</li>
<li><code>New()</code>返回一个goroutine池，并且定义这个池中有多少个goroutine在进行(或者是在等待任务)，<code>for w:= range p.work</code>只有当通道关闭时才会退出<code>for</code>，所以goroutine在通道没有任务的时候会发生阻塞，但是阻塞并不意味着不能返回<code>&amp;p</code>，因为我们在创建goroutine过程中，程序就是在和其它goroutine并发执行，所以阻塞只是某个goroutine的阻塞，不会影响到别的。</li>
<li><code>Run()</code>给一个Worker参数，传入goroutine池中执行Task()</li>
<li><code>Shutdown()</code>关闭通道，等待WaitGroup的counter为0</li>
</ul>

<p>main.go</p>

<pre><code class="language-go">// This sample program demonstrates how to use the work package
// to use a pool of goroutines to get work done.
package main

import (
	&quot;log&quot;
	&quot;sync&quot;
	&quot;time&quot;

	&quot;github.com/goinaction/code/chapter7/patterns/work&quot;
)

// names provides a set of names to display.
var names = []string{
	&quot;steve&quot;,
	&quot;bob&quot;,
	&quot;mary&quot;,
	&quot;therese&quot;,
	&quot;jason&quot;,
}

// namePrinter provides special support for printing names.
type namePrinter struct {
	name string
}

// Task implements the Worker interface.
func (m *namePrinter) Task() {
	log.Println(m.name)
	time.Sleep(time.Second)
}

// main is the entry point for all Go programs.
func main() {
	// Create a work pool with 2 goroutines.
	p := work.New(2)

	var wg sync.WaitGroup
	wg.Add(100 * len(names))

	for i := 0; i &lt; 100; i++ {
		// Iterate over the slice of names.
		for _, name := range names {
			// Create a namePrinter and provide the
			// specific name.
			np := namePrinter{
				name: name,
			}

			go func() {
				// Submit the task to be worked on. When RunTask
				// returns we know it is being handled.
				p.Run(&amp;np)
				wg.Done()
			}()
		}
	}

	wg.Wait()

	// Shutdown the work pool and wait for all existing work
	// to be completed.
	p.Shutdown()
}

</code></pre>

<p>这里的Task()只是简单的输出Worker的name，namePrinter实现了Worker接口，所以创建示例，可以传入<code>Run()</code>，其实就是创建任务，把任务扔进池中执行，只是无缓冲通道的好处是，主函数在创建不同的goroutine想要将任务扔进池时，会因为池中的goroutine正在忙而导致主函数中的goroutine被阻塞，就很好的告诉我们池中什么时候在忙，什么时候是可以接收任务的。</p>

<h1 id="第八章-标准库">第八章 标准库</h1>

<h2 id="文档与源代码">文档与源代码</h2>

<p>Go语言的标准库很多，都可以在<a href="http://golang.org/pkg/">官网</a>上访问
归档文件(archive file) ： 标准库的源代码是经过预编译的</p>

<h2 id="记录日志">记录日志</h2>

<h3 id="log包-使用和配置">log包(使用和配置)</h3>

<p>示例代码：</p>

<pre><code class="language-go">package main

import (
	&quot;log&quot;
)

func init() {
	log.SetPrefix(&quot;TRACE: &quot;)
	log.SetFlags(log.Ldate | log.Lmicroseconds | log.Llongfile)
}

func main() {
	// Println writes to the standard logger.
	log.Println(&quot;message&quot;)

	// Fatalln is Println() followed by a call to os.Exit(1).
	log.Fatalln(&quot;fatal message&quot;)

	// Panicln is Println() followed by a call to panic().
	log.Panicln(&quot;panic message&quot;)
}
</code></pre>

<p><code>log.SetPrefix()</code>设置日志项的前缀</p>

<pre><code class="language-go">const(
	Ldate = 1 &lt;&lt; iota  	//1 &lt;&lt; 0
	Ltime				//1 &lt;&lt; 1
	Lmicroseconds		//1 &lt;&lt; 2
	Llongfile			//1 &lt;&lt; 3
	Lshortfile			//1 &lt;&lt; 4
	...
)
</code></pre>

<p>关键字<code>iota</code>在常量声明区有特殊作用。这个关键字让编译器为每个常量复制相同的表达式，直到声明区结束，或者遇到一个新的赋值语句。iota的初始值是0，之后每次都自增1。像上面代码，就是像注释那样，移位并且每次移位iota都自增1</p>

<p><code>log.SetFlags()</code>用上面代码中的常量来配置日志，例如示例代码，用<code>|</code>来合并多个常量</p>

<h3 id="定制的日志记录器">定制的日志记录器</h3>

<p>首先先要声明指针变量</p>

<pre><code class="language-go">var (
	Trace   *log.Logger // Just about anything
	Info    *log.Logger // Important information
	Warning *log.Logger // Be concerned
	Error   *log.Logger // Critical problem
)
</code></pre>

<p>然后在初始化函数<code>init()</code>初始化</p>

<pre><code class="language-go">func init() {
	file, err := os.OpenFile(&quot;errors.txt&quot;,
		os.O_CREATE|os.O_WRONLY|os.O_APPEND, 0666)
	if err != nil {
		log.Fatalln(&quot;Failed to open error log file:&quot;, err)
	}

	Trace = log.New(ioutil.Discard,
		&quot;TRACE: &quot;,
		log.Ldate|log.Ltime|log.Lshortfile)

	Info = log.New(os.Stdout,
		&quot;INFO: &quot;,
		log.Ldate|log.Ltime|log.Lshortfile)

	Warning = log.New(os.Stdout,
		&quot;WARNING: &quot;,
		log.Ldate|log.Ltime|log.Lshortfile)

	Error = log.New(io.MultiWriter(file, os.Stderr),
		&quot;ERROR: &quot;,
		log.Ldate|log.Ltime|log.Lshortfile)
}
</code></pre>

<p>可以容易看出
<code>func New(out io.Writer, prefix string, flag int) *Logger</code>这个函数的用法，返回一个新的log地址(指针)</p>

<ul>
<li><p><code>prefix</code>:前缀</p></li>

<li><p><code>flag</code>:之前描述的那些常量</p></li>
</ul>

<p>关于一些<code>io.Writer</code>接口有</p>

<ul>
<li><p><code>ioutil.Discard</code> 什么都不做</p></li>

<li><p><code>os.Stdout</code> 标准输出在命令行</p></li>

<li><p><code>func MultiWriter(writers ...Writer) Writer</code>可以将多个writer融合成一个</p></li>

<li><p><code>*file</code>也实现了这个接口</p></li>
</ul>

<h2 id="编码-解码-json">编码/解码(Json)</h2>

<h3 id="解码json">解码Json</h3>

<h4 id="使用decoder">使用Decoder</h4>

<pre><code class="language-go">// This sample program demonstrates how to decode a JSON response
// using the json package and NewDecoder function.
package main

import (
	&quot;encoding/json&quot;
	&quot;fmt&quot;
	&quot;log&quot;
	&quot;net/http&quot;
)

type (
	// gResult maps to the result document received from the search.
	gResult struct {
		GsearchResultClass string `json:&quot;GsearchResultClass&quot;`
		UnescapedURL       string `json:&quot;unescapedUrl&quot;`
		URL                string `json:&quot;url&quot;`
		VisibleURL         string `json:&quot;visibleUrl&quot;`
		CacheURL           string `json:&quot;cacheUrl&quot;`
		Title              string `json:&quot;title&quot;`
		TitleNoFormatting  string `json:&quot;titleNoFormatting&quot;`
		Content            string `json:&quot;content&quot;`
	}

	// gResponse contains the top level document.
	gResponse struct {
		ResponseData struct {
			Results []gResult `json:&quot;results&quot;`
		} `json:&quot;responseData&quot;`
	}
)

func main() {
	uri := &quot;http://ajax.googleapis.com/ajax/services/search/web?v=1.0&amp;rsz=8&amp;q=golang&quot;

	// Issue the search against Google.
	resp, err := http.Get(uri)
	if err != nil {
		log.Println(&quot;ERROR:&quot;, err)
		return
	}
	defer resp.Body.Close()

	// Decode the JSON response into our struct type.
	var gr gResponse
	err = json.NewDecoder(resp.Body).Decode(&amp;gr)
	if err != nil {
		log.Println(&quot;ERROR:&quot;, err)
		return
	}

	fmt.Println(gr)

	// Marshal the struct type into a pretty print
	// version of the JSON document.
	pretty, err := json.MarshalIndent(gr, &quot;&quot;, &quot;    &quot;)
	if err != nil {
		log.Println(&quot;ERROR:&quot;, err)
		return
	}

	fmt.Println(string(pretty))
}
</code></pre>

<ul>
<li>用单引号声明的一个字符串。这些字符串被称作<strong>标签(tag)</strong>，是提供每个字段的元信息的一种机制，将JSON文档和结构类型里的字段一一映射起来。如果不存在标签，编码和解码过程会试图以大小写无关的方式，直接使用字段的名字进行匹配。如果无法匹配，对应的结构类型里的字段就包含其零值。</li>
<li><code>err = json.NewDecoder(resp.Body).Decode(&amp;gr)</code>将响应的JSON的Reader接口传入函数得到一个<code>*Decoder</code>，然后调用其<code>Decode()</code>函数，并且将之前声明的<code>gResponse</code>类型指针传入，这样就会将解码出来的值写入到这个类型指针所指向的数据体</li>
</ul>

<h4 id="json为字符串时">JSON为字符串时</h4>

<h5 id="用结构类型存储">用结构类型存储</h5>

<p>示例代码：</p>

<pre><code class="language-go">// This sample program demonstrates how to decode a JSON string.
package main

import (
	&quot;encoding/json&quot;
	&quot;fmt&quot;
	&quot;log&quot;
)

// Contact represents our JSON string.
type Contact struct {
	Name    string `json:&quot;name&quot;`
	Title   string `json:&quot;title&quot;`
	Contact struct {
		Home string `json:&quot;home&quot;`
		Cell string `json:&quot;cell&quot;`
	} `json:&quot;contact&quot;`
}

// JSON contains a sample string to unmarshal.
var JSON = `{
	&quot;name&quot;: &quot;Gopher&quot;,
	&quot;title&quot;: &quot;programmer&quot;,
	&quot;contact&quot;: {
		&quot;home&quot;: &quot;415.333.3333&quot;,
		&quot;cell&quot;: &quot;415.555.5555&quot;
	}
}`

func main() {
	// Unmarshal the JSON string into our variable.
	var c Contact
	err := json.Unmarshal([]byte(JSON), &amp;c)
	if err != nil {
		log.Println(&quot;ERROR:&quot;, err)
		return
	}

	fmt.Println(c)
}
</code></pre>

<p>可以看到代码中给到的<code>JSON</code>是一段字符串，这个时候要将字符串转换为<code>[]byte</code>切片，用<code>Unmarshal()</code>函数进行反序列化处理，然后像前面一样存入到程序中创建的对应的结构体类型中。</p>

<ul>
<li><code>func Unmarshal(data []byte, v interface{}) error</code></li>
</ul>

<h5 id="解码到map里面">解码到map里面</h5>

<p>示例代码</p>

<pre><code class="language-go">// This sample program demonstrates how to decode a JSON string.
package main

import (
	&quot;encoding/json&quot;
	&quot;fmt&quot;
	&quot;log&quot;
)

// JSON contains a sample string to unmarshal.
var JSON = `{
	&quot;name&quot;: &quot;Gopher&quot;,
	&quot;title&quot;: &quot;programmer&quot;,
	&quot;contact&quot;: {
		&quot;home&quot;: &quot;415.333.3333&quot;,
		&quot;cell&quot;: &quot;415.555.5555&quot;
	}
}`

func main() {
	// Unmarshal the JSON string into our map variable.
	var c map[string]interface{}
	err := json.Unmarshal([]byte(JSON), &amp;c)
	if err != nil {
		log.Println(&quot;ERROR:&quot;, err)
		return
	}

	fmt.Println(&quot;Name:&quot;, c[&quot;name&quot;])
	fmt.Println(&quot;Title:&quot;, c[&quot;title&quot;])
	fmt.Println(&quot;Contact&quot;)
	fmt.Println(&quot;H:&quot;, c[&quot;contact&quot;].(map[string]interface{})[&quot;home&quot;])
	fmt.Println(&quot;C:&quot;, c[&quot;contact&quot;].(map[string]interface{})[&quot;cell&quot;])
}
</code></pre>

<p>一样是用<code>Unmarshal()</code>函数来反序列化，然后存入map中。
这里虽然用<code>interface{}</code>作为值增强了灵活性，但是有个小缺点，就是像<code>Contact</code>包含了<code>home</code> 和 <code>cell</code>这里要输出它们两个的时候要</p>

<pre><code class="language-go">	fmt.Println(&quot;H:&quot;, c[&quot;contact&quot;].(map[string]interface{})[&quot;home&quot;])
	fmt.Println(&quot;C:&quot;, c[&quot;contact&quot;].(map[string]interface{})[&quot;cell&quot;])
</code></pre>

<p>要将<code>contact</code>键的值转换为另一个键为<code>string</code>类型，值为<code>interface{}</code>的map类型。</p>

<h3 id="编码json">编码JSON</h3>

<p>序列化是指将数据转换为JSON字符串的过程
示例代码</p>

<pre><code class="language-go">// This sample program demonstrates how to marshal a JSON string.
package main

import (
	&quot;encoding/json&quot;
	&quot;fmt&quot;
	&quot;log&quot;
)

func main() {
	// Create a map of key/value pairs.
	c := make(map[string]interface{})
	c[&quot;name&quot;] = &quot;Gopher&quot;
	c[&quot;title&quot;] = &quot;programmer&quot;
	c[&quot;contact&quot;] = map[string]interface{}{
		&quot;home&quot;: &quot;415.333.3333&quot;,
		&quot;cell&quot;: &quot;415.555.5555&quot;,
	}

	// Marshal the map into a JSON string.
	data, err := json.MarshalIndent(c, &quot;&quot;, &quot;    &quot;)
	if err != nil {
		log.Println(&quot;ERROR:&quot;, err)
		return
	}

	fmt.Println(string(data))
}
</code></pre>

<p>这里的数据是由map存储，然后序列化成了JSON格式</p>

<p><code>func MarshalIndent(v interface{}, prefix, indent string) ([]byte, error)</code></p>

<p><code>func Marshal(v interface{}) ([]byte, error)</code></p>

<p>第二种更适用于网络响应
第一种多了前缀和缩进两个参数</p>

<h1 id="第九章-测试和性能">第九章 测试和性能</h1>

<h2 id="单元测试">单元测试</h2>

<h3 id="基础单元测试">基础单元测试</h3>

<p>单元测试是用来测试包或者程序的一部分代码或者一组代码的函数</p>

<p><code>go test -v</code>提供冗余输出</p>

<p>一些规则</p>

<ul>
<li><p>Go语言的测试工具只会认为以_test.go结尾的文件是测试文件</p></li>

<li><p>测试函数必须以Test单词开头</p></li>

<li><p>测试函数必须接收一个<code>*testing.T</code>类型的指针</p></li>
</ul>

<p>示例代码：</p>

<pre><code class="language-go">// Sample test to show how to write a basic unit test.
package listing01

import (
	&quot;net/http&quot;
	&quot;testing&quot;
)

const checkMark = &quot;\u2713&quot;
const ballotX = &quot;\u2717&quot;

// TestDownload validates the http Get function can download content.
func TestDownload(t *testing.T) {
	url := &quot;http://www.baidu.com&quot;
	statusCode := 200

	t.Log(&quot;Given the need to test downloading content.&quot;)
	{
		t.Logf(&quot;\tWhen checking \&quot;%s\&quot; for status code \&quot;%d\&quot;&quot;,
			url, statusCode)
		{
			resp, err := http.Get(url)
			if err != nil {
				t.Fatal(&quot;\t\tShould be able to make the Get call.&quot;,
					ballotX, err)
			}
			t.Log(&quot;\t\tShould be able to make the Get call.&quot;,
				checkMark)

			defer resp.Body.Close()

			if resp.StatusCode == statusCode {
				t.Logf(&quot;\t\tShould receive a \&quot;%d\&quot; status. %v&quot;,
					statusCode, checkMark)
			} else {
				t.Errorf(&quot;\t\tShould receive a \&quot;%d\&quot; status. %v %v&quot;,
					statusCode, ballotX, resp.StatusCode)
			}
		}
	}
}
</code></pre>

<ul>
<li><code>t.Fatal()</code>立刻停止这个测试函数的执行，但会继续别的测试函数。</li>
<li><code>t.Error()</code>需要报告失败，但不想停止当前测试函数的执行</li>
<li><code>t.Log()</code>输出信息</li>
</ul>

<h3 id="表组测试">表组测试</h3>

<p>如果测试可以接受一组不同的输入并产生不同的输出的代码，那么应该使用表组测试的方法进行测试。
表组测试除了会有一组不同的输入值和期望结果之外，其余部分都很像基础单元测试</p>

<p>示例代码：</p>

<pre><code class="language-go">// Sample test to show how to write a basic unit table test.
package listing08

import (
	&quot;net/http&quot;
	&quot;testing&quot;
)

const checkMark = &quot;\u2713&quot;
const ballotX = &quot;\u2717&quot;

// TestDownload validates the http Get function can download
// content and handles different status conditions properly.
func TestDownload(t *testing.T) {
	var urls = []struct {
		url        string
		statusCode int
	}{
		{
			&quot;http://www.goinggo.net/feeds/posts/default?alt=rss&quot;,
			http.StatusOK,
		},
		{
			&quot;http://rss.cnn.com/rss/cnn_topstbadurl.rss&quot;,
			http.StatusNotFound,
		},
	}

	t.Log(&quot;Given the need to test downloading different content.&quot;)
	{
		for _, u := range urls {
			t.Logf(&quot;\tWhen checking \&quot;%s\&quot; for status code \&quot;%d\&quot;&quot;,
				u.url, u.statusCode)
			{
				resp, err := http.Get(u.url)
				if err != nil {
					t.Fatal(&quot;\t\tShould be able to Get the url.&quot;,
						ballotX, err)
				}
				t.Log(&quot;\t\tShould be able to Get the url.&quot;,
					checkMark)

				defer resp.Body.Close()

				if resp.StatusCode == u.statusCode {
					t.Logf(&quot;\t\tShould have a \&quot;%d\&quot; status. %v&quot;,
						u.statusCode, checkMark)
				} else {
					t.Errorf(&quot;\t\tShould have a \&quot;%d\&quot; status. %v %v&quot;,
						u.statusCode, ballotX, resp.StatusCode)
				}
			}
		}
	}
}
</code></pre>

<p>可以看到程序测试内容基本没变，只是在测试数据上采用了遍历切片的形式，所以测试的数据可以比基本单元测试多，但是功能是和基本单元测试一样的。</p>

<h3 id="模仿调用">模仿调用</h3>

<p>在访问不到互联网的时候(或者被防火墙。。。)
通过<code>httptest</code>的包，模仿互联网资源的请求和响应</p>

<pre><code class="language-go">func mockServer() *httptest.Server {
	f := func(w http.ResponseWriter, r *http.Request) {
		w.WriteHeader(200)
		w.Header().Set(&quot;Content-Type&quot;, &quot;application/xml&quot;)
		fmt.Fprintln(w, feed)
	}

	return httptest.NewServer(http.HandlerFunc(f))
}
</code></pre>

<h3 id="测试服务端点">测试服务端点</h3>

<p>我们可以单独测试所有站点，而不用把整个网络服务打开</p>

<pre><code class="language-go">func init() {
	handlers.Routes()
}
</code></pre>

<p>只需要在这个函数里面对路由进行初始化</p>

<h3 id="示例">示例</h3>

<p>示例基于已经存在的函数或者方法。我们需要使用Example代替Test作为函数名的开始。
对于示例代码，需要遵守一个规则。示例代码的函数名字必须基于已经存在的公开的函数或者方法。如果没有使用已经存在的函数或者方法，这个示例就不会显示在包的Go文档里</p>

<p>比如</p>

<pre><code class="language-go">func SendJSON(rw http.ResponseWriter, r *http.Request) {
	u := struct {
		Name  string
		Email string
	}{
		Name:  &quot;Bill&quot;,
		Email: &quot;bill@ardanstudios.com&quot;,
	}

	rw.Header().Set(&quot;Content-Type&quot;, &quot;application/json&quot;)
	rw.WriteHeader(200)
	json.NewEncoder(rw).Encode(&amp;u)
}
</code></pre>

<p>和</p>

<pre><code class="language-go">func ExampleSendJSON() {
	r, _ := http.NewRequest(&quot;GET&quot;, &quot;/sendjson&quot;, nil)
	w := httptest.NewRecorder()
	http.DefaultServeMux.ServeHTTP(w, r)

	var u struct {
		Name  string
		Email string
	}

	if err := json.NewDecoder(w.Body).Decode(&amp;u); err != nil {
		log.Println(&quot;ERROR:&quot;, err)
	}

	fmt.Println(u)
	// Output:
	// {Bill bill@ardanstudios.com}
}
</code></pre>

<p>这样就是对应函数了。</p>

<p>注意 有一段带有<code>Output:</code>的注释是用来标记期望输出的，如果两者匹配，则示例作为测试就会通过，并加入到包的Go文档里。</p>

<p>我们可以在godoc的网页版上看到，所以这也是为什么写Go语言程序遵循规则会有很多方便之处</p>

<h2 id="基准测试">基准测试</h2>

<p>基准测试是一种测试代码性能的方法
许多开发人员会用基准测试来测试不同的并发模式，或者用基准测试来辅助配置工作池的数量，以保证能最大化系统的吞吐量</p>

<p>和单元测试文件一样，文件名必须以<code>_test.go</code>结尾</p>

<p>基准测试函数必须以<code>Beachmark</code> 接受一个指向<code>testing.B</code>类型的指针作为唯一参数。</p>

<p>示例代码：</p>

<pre><code class="language-go">// Sample benchmarks to test which function is better for converting
// an integer into a string. First using the fmt.Sprintf function,
// then the strconv.FormatInt function and then strconv.Itoa.
package listing05_test

import (
	&quot;fmt&quot;
	&quot;strconv&quot;
	&quot;testing&quot;
)

// BenchmarkSprintf provides performance numbers for the
// fmt.Sprintf function.
func BenchmarkSprintf(b *testing.B) {
	number := 10

	b.ResetTimer()

	for i := 0; i &lt; b.N; i++ {
		fmt.Sprintf(&quot;%d&quot;, number)
	}
}

// BenchmarkFormat provides performance numbers for the
// strconv.FormatInt function.
func BenchmarkFormat(b *testing.B) {
	number := int64(10)

	b.ResetTimer()

	for i := 0; i &lt; b.N; i++ {
		strconv.FormatInt(number, 10)
	}
}

// BenchmarkItoa provides performance numbers for the
// strconv.Itoa function.
func BenchmarkItoa(b *testing.B) {
	number := 10

	b.ResetTimer()

	for i := 0; i &lt; b.N; i++ {
		strconv.Itoa(number)
	}
}

</code></pre>

<p>注意，一定要将所有要进行基准测试的代码放入到循环里，并且循环要使用<code>b.N</code>，否知测试结果是不可靠的</p>

<p>运行基准测试的命令</p>

<p><code>go test -v -run=&quot;none&quot; -bench=. -benchtime=&quot;3s&quot; -benchmem</code></p>

<ul>
<li><p><code>-v</code>是显示细节</p></li>

<li><p><code>-run</code>表示需要执行的单元测试，这里用none是因为没人会将单元测试命名成这个个，所以表示不运行单元测试。</p></li>

<li><p><code>-bench</code>需要运行基准测试的文件名</p></li>

<li><p><code>-benchtime</code>需要运行的时间，一般三秒后的结果不会有太大改变</p></li>

<li><p><code>benchmem</code>提供每次操作分配的内存次数，以及总共分配内存的字节数</p></li>

<li><p><code>allocs/op</code>表示每次操作从堆上分配内存的次数</p></li>

<li><p><code>B/op</code>每次操作分配的字节数</p></li>
</ul>

<h1 id="附加">附加</h1>

<h2 id="go-unsafe包">Go unsafe包</h2>

<p>这个包可以绕过Go的内存安全机制，所以这个包不安全</p>

<h3 id="sizeof函数">Sizeof函数</h3>

<pre><code class="language-go">func main() {
	fmt.Println(unsafe.Sizeof(true))
	fmt.Println(unsafe.Sizeof(int8(0)))
	fmt.Println(unsafe.Sizeof(int16(10)))
	fmt.Println(unsafe.Sizeof(int32(10000000)))
	fmt.Println(unsafe.Sizeof(int64(10000000000000)))
	fmt.Println(unsafe.Sizeof(int(10000000000000000)))
}
</code></pre>

<p>会返回一个类型占用的字节大小，<code>int</code>由于我的电脑是64bit的，所以会返回8个字节</p>

<h3 id="alignof函数">Alignof函数</h3>

<p>返回一个类型的对齐值</p>

<pre><code class="language-go">func main() {
	var b bool
	var i8 int8
	var i16 int16
	var i64 int64

	var f32 float32

	var s string

	var m map[string]string

	var p *int32

	fmt.Println(unsafe.Alignof(b))
	fmt.Println(unsafe.Alignof(i8))
	fmt.Println(unsafe.Alignof(i16))
	fmt.Println(unsafe.Alignof(i64))
	fmt.Println(unsafe.Alignof(f32))
	fmt.Println(unsafe.Alignof(s))
	fmt.Println(unsafe.Alignof(m))
	fmt.Println(unsafe.Alignof(p))

}

</code></pre>

<p>对齐值对于内存分配有影响，后面再说。</p>

<h3 id="offsetof函数">Offsetof函数</h3>

<p>函数只适用于struct结构体中的字段相对结构体的内存位置偏移量。结构体的第一个字段的偏移量都是0</p>

<pre><code class="language-go">func main() {
	var u1 user1

	fmt.Println(unsafe.Offsetof(u1.b))
	fmt.Println(unsafe.Offsetof(u1.i))
	fmt.Println(unsafe.Offsetof(u1.j))
}


type user1 struct {
	b byte
	i int32
	j int64
}
</code></pre>

<p>这样，即使是私有变量，在我们知道结构体头的地址后，就能够根据偏移量和内存大小来访问变量</p>

<h3 id="解释为什么不同排列顺序的结构体占用内存大小不同">解释为什么不同排列顺序的结构体占用内存大小不同</h3>

<p>内存对齐规则：</p>

<ul>
<li>对于具体类型来说，对齐值=min(编译器默认对齐值，类型大小Sizeof长度)。也就是在默认设置的对齐值和类型的内存占用大小之间，取最小值为该类型的对齐值。我的电脑默认是8，所以最大值不会超过8.</li>
<li>struct在每个字段都内存对齐之后，其本身也要进行对齐，对齐值=min(默认对齐值，字段最大类型长度)。这条也很好理解，struct的所有字段中，最大的那个类型的长度以及默认对齐值之间，取最小的那个。</li>
</ul>

<p>我们知道byte，int32，int64的对齐值分别为1，4，8，占用内存大小也是1，4，8。</p>

<p>那么它的字段顺序是byte、int32、int64，我们先使用第1条内存对齐规则进行内存对齐，其内存结构如下</p>

<p><code>bxxx|iiii|jjjj|jjjj</code></p>

<p>为什么是这样子排列？</p>

<p>第1个字段byte，对齐值1，大小1，所以放在内存布局中的第1位。</p>

<p>第2个字段int32，对齐值4，大小4，所以它的内存偏移值必须是4的倍数，在当前的user1中，就不能从第2位开始了，必须从第5位开始，也就是偏移量为4。第2，3，4位由编译器进行填充，一般为值0，也称之为内存空洞。所以第5位到第8位为第2个字段i。</p>

<p>第3字段，对齐值为8，大小也是8。因为user1前两个字段已经排到了第8位，所以下一位的偏移量正好是8，是第3个字段对齐值的倍数，不用填充，可以直接排列第3个字段，也就是从第9位到第16位为第3个字段j。</p>

<hr />

<p>它的字段顺序是byte、int64、int32，内存大小为24
<code>bxxx|xxxx|jjjj|jjjj|iiii</code></p>

<p>第1个字段b偏移量为0，占用1个字节，放在第1位。</p>

<p>第2个字段j，是int64，对齐值和大小都是8，所以要从偏移量8开始，也就是第9到16位为j，这也就意味着第2到8位被编译器填充。</p>

<p>目前整个内存布局已经偏移了16位，正好是第3个字段i的对齐值4的倍数，所以不用填充，可以直接排列，第17到20位为i。</p>

<p>现在所有字段对齐好了，整个内存大小为1+7+8+4=20个字节，我们开始使用内存对齐的第2条规则，也就是结构体的对齐，通过默认对齐值和最大的字段大小，求出结构体的对齐值为8。</p>

<p>现在我们的整个内存布局大小为20，不是8的倍数，所以我们需要进行内存填充，补足到8的倍数，最小的就是24，所以对齐后整个内存布局为</p>

<p><code>bxxx|xxxx|jjjj|jjjj|iiii|xxxx</code></p>

<p>也就是说==每个字段在内存中的偏移量是对齐值的倍数即可。==</p>

<h3 id="pointer类型">Pointer类型</h3>

<p>Go语言是不允许两个指针类型进行转换的。</p>

<p><code>unsafe.Pointer</code>是一种特殊意义的指针，它可以包含任意类型的地址，有点类似于C语言里的void*指针，全能型的。</p>

<p>4个规则：</p>

<ul>
<li><p>任何指针都可以转换为unsafe.Pointer</p></li>

<li><p>unsafe.Pointer可以转换为任何指针</p></li>

<li><p>uintptr可以转换为unsafe.Pointer</p></li>

<li><p>unsafe.Pointer可以转换为uintptr</p></li>
</ul>

<pre><code class="language-go">func main() {
	u:=new(user)
	fmt.Println(*u)

	pName:=(*string)(unsafe.Pointer(u))
	*pName=&quot;张三&quot;

	pAge:=(*int)(unsafe.Pointer(uintptr(unsafe.Pointer(u))+unsafe.Offsetof(u.age)))
	*pAge = 20

	fmt.Println(*u)
}

type user struct {
	name string
	age int
}
</code></pre>

<p>利用<code>unsafe.Pointer()</code>的转换，可以利用结构体里面元素的偏移量进行定位到每一个具体的元素，然后用对应的类型将指针取出来，然后可以通过这样修改结构体中某个具体的元素。</p>

<h3 id="go语言实战-这本书的读书笔记就到这里啦-欢迎评论指正">《Go语言实战》这本书的读书笔记就到这里啦，欢迎评论指正。</h3>

                        </div>

                        


                        

<div class="post-archive">
    <h2>See Also</h2>
    <ul class="listing">
        
        <li><a href="/posts/golang/golang-highlevel/">Go语言高级编程</a></li>
        
        <li><a href="/posts/golang/golang-leetcode/">Golang--Leetcode</a></li>
        
        <li><a href="/posts/golang/golangstd-unicode/">Golang标准库--Unicode</a></li>
        
        <li><a href="/posts/golang/golangstd-string/">Golang标准库--String</a></li>
        
        <li><a href="/posts/golang/golangstd-bytes/">Golang标准库--Bytes</a></li>
        
    </ul>
</div>


                        <div class="post-meta meta-tags">
                            
                            <ul class="clearfix">
                                
                                <li><a href="https://wushaoqiang.github.io/tags/Golang">Golang</a></li>
                                
                                <li><a href="https://wushaoqiang.github.io/tags/%E5%9F%BA%E7%A1%80">基础</a></li>
                                
                            </ul>
                            
                        </div>
                    </article>
                    
    

    
    
    <div class="post bg-white">
      <script src="https://utteranc.es/client.js"
            repo= "wushaoqiang/blogcomment"
            issue-term="pathname"
            theme="github-light"
            crossorigin="anonymous"
            async>
      </script>
    </div>
    
                </div>
            </div>
            <div id="secondary">
    <section class="widget">
        <form id="search" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank" _lpchecked="1">
      
      <input type="text" name="q" maxlength="20" placeholder="Search">
      <input type="hidden" name="sitesearch" value="https://wushaoqiang.github.io">
      <button type="submit" class="submit icon-search"></button>
</form>
    </section>
    
    <section class="widget">
        <h3 class="widget-title">最近文章</h3>
<ul class="widget-list">
    
    <li>
        <a href="https://wushaoqiang.github.io/posts/gopher/gopher-2016-solid-design/" title="Gopher 2016 Solid Design">Gopher 2016 Solid Design</a>
    </li>
    
    <li>
        <a href="https://wushaoqiang.github.io/posts/design-pattern/design-pattern-basic/" title="Design Pattern Basic">Design Pattern Basic</a>
    </li>
    
    <li>
        <a href="https://wushaoqiang.github.io/posts/design-pattern/design-principle-basic/" title="Design Principle Basic">Design Principle Basic</a>
    </li>
    
    <li>
        <a href="https://wushaoqiang.github.io/posts/front-end/javascript-array/" title="Javascript Array">Javascript Array</a>
    </li>
    
    <li>
        <a href="https://wushaoqiang.github.io/posts/front-end/javascript-object/" title="Javascript Object">Javascript Object</a>
    </li>
    
    <li>
        <a href="https://wushaoqiang.github.io/posts/front-end/typescript-basic-primitive/" title="Typescript Basic Primitive">Typescript Basic Primitive</a>
    </li>
    
    <li>
        <a href="https://wushaoqiang.github.io/posts/linux/linux-account/" title="Linux Account">Linux Account</a>
    </li>
    
    <li>
        <a href="https://wushaoqiang.github.io/posts/linux/linux-how-to-identify-command/" title="Linux How to Identify Command">Linux How to Identify Command</a>
    </li>
    
    <li>
        <a href="https://wushaoqiang.github.io/posts/linux/linux-windows-file/" title="Linux Windows File">Linux Windows File</a>
    </li>
    
    <li>
        <a href="https://wushaoqiang.github.io/posts/linux/linux-vim-basic/" title="Linux Vim Basic">Linux Vim Basic</a>
    </li>
    
</ul>
    </section>

    

    <section class="widget">
        <h3 class="widget-title">分类</h3>
<ul class="widget-list">
    
    <li>
        <a href="https://wushaoqiang.github.io/categories/Algorithm/">Algorithm(2)</a>
    </li>
    
    <li>
        <a href="https://wushaoqiang.github.io/categories/Definition/">Definition(1)</a>
    </li>
    
    <li>
        <a href="https://wushaoqiang.github.io/categories/Favorite/">Favorite(1)</a>
    </li>
    
    <li>
        <a href="https://wushaoqiang.github.io/categories/Front-end/">Front-end(13)</a>
    </li>
    
    <li>
        <a href="https://wushaoqiang.github.io/categories/Git/">Git(2)</a>
    </li>
    
    <li>
        <a href="https://wushaoqiang.github.io/categories/Golang/">Golang(46)</a>
    </li>
    
    <li>
        <a href="https://wushaoqiang.github.io/categories/Hugo/">Hugo(1)</a>
    </li>
    
    <li>
        <a href="https://wushaoqiang.github.io/categories/Leetcode/">Leetcode(161)</a>
    </li>
    
    <li>
        <a href="https://wushaoqiang.github.io/categories/Linux/">Linux(20)</a>
    </li>
    
    <li>
        <a href="https://wushaoqiang.github.io/categories/Opinion/">Opinion(1)</a>
    </li>
    
    <li>
        <a href="https://wushaoqiang.github.io/categories/Vscode/">Vscode(1)</a>
    </li>
    
    <li>
        <a href="https://wushaoqiang.github.io/categories/protocal/">protocal(1)</a>
    </li>
    
    <li>
        <a href="https://wushaoqiang.github.io/categories/questions/">questions(1)</a>
    </li>
    
    <li>
        <a href="https://wushaoqiang.github.io/categories/%E5%AF%86%E7%A0%81%E5%AD%A6/">密码学(1)</a>
    </li>
    
    <li>
        <a href="https://wushaoqiang.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库(10)</a>
    </li>
    
    <li>
        <a href="https://wushaoqiang.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构(2)</a>
    </li>
    
    <li>
        <a href="https://wushaoqiang.github.io/categories/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/">网络基础(9)</a>
    </li>
    
    <li>
        <a href="https://wushaoqiang.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/">计算机基础(1)</a>
    </li>
    
    <li>
        <a href="https://wushaoqiang.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式(2)</a>
    </li>
    
    <li>
        <a href="https://wushaoqiang.github.io/categories/%E8%B5%84%E6%BA%90/">资源(1)</a>
    </li>
    
</ul>
    </section>

    <section class="widget">
        <h3 class="widget-title">标签</h3>
<div class="tagcloud">
    
    <a href="https://wushaoqiang.github.io/tags/Algorithm/">Algorithm</a>
    
    <a href="https://wushaoqiang.github.io/tags/Array/">Array</a>
    
    <a href="https://wushaoqiang.github.io/tags/Bash/">Bash</a>
    
    <a href="https://wushaoqiang.github.io/tags/Basic/">Basic</a>
    
    <a href="https://wushaoqiang.github.io/tags/Beego/">Beego</a>
    
    <a href="https://wushaoqiang.github.io/tags/Blog/">Blog</a>
    
    <a href="https://wushaoqiang.github.io/tags/CSS/">CSS</a>
    
    <a href="https://wushaoqiang.github.io/tags/CSS3/">CSS3</a>
    
    <a href="https://wushaoqiang.github.io/tags/Channel/">Channel</a>
    
    <a href="https://wushaoqiang.github.io/tags/Command/">Command</a>
    
    <a href="https://wushaoqiang.github.io/tags/Context/">Context</a>
    
    <a href="https://wushaoqiang.github.io/tags/Crawler/">Crawler</a>
    
    <a href="https://wushaoqiang.github.io/tags/DHCP/">DHCP</a>
    
    <a href="https://wushaoqiang.github.io/tags/Definition/">Definition</a>
    
    <a href="https://wushaoqiang.github.io/tags/Easy/">Easy</a>
    
    <a href="https://wushaoqiang.github.io/tags/Effective/">Effective</a>
    
    <a href="https://wushaoqiang.github.io/tags/Exercism/">Exercism</a>
    
    <a href="https://wushaoqiang.github.io/tags/Favorite/">Favorite</a>
    
    <a href="https://wushaoqiang.github.io/tags/Front-end/">Front-end</a>
    
    <a href="https://wushaoqiang.github.io/tags/GC/">GC</a>
    
    <a href="https://wushaoqiang.github.io/tags/Generic/">Generic</a>
    
    <a href="https://wushaoqiang.github.io/tags/Gin/">Gin</a>
    
    <a href="https://wushaoqiang.github.io/tags/Git/">Git</a>
    
    <a href="https://wushaoqiang.github.io/tags/Golang/">Golang</a>
    
    <a href="https://wushaoqiang.github.io/tags/Gopher/">Gopher</a>
    
    <a href="https://wushaoqiang.github.io/tags/HTML/">HTML</a>
    
    <a href="https://wushaoqiang.github.io/tags/HTTP/">HTTP</a>
    
    <a href="https://wushaoqiang.github.io/tags/Hugo/">Hugo</a>
    
    <a href="https://wushaoqiang.github.io/tags/IP/">IP</a>
    
    <a href="https://wushaoqiang.github.io/tags/Interface/">Interface</a>
    
    <a href="https://wushaoqiang.github.io/tags/Internet/">Internet</a>
    
    <a href="https://wushaoqiang.github.io/tags/JS/">JS</a>
    
    <a href="https://wushaoqiang.github.io/tags/LeetCode/">LeetCode</a>
    
    <a href="https://wushaoqiang.github.io/tags/Leetcode/">Leetcode</a>
    
    <a href="https://wushaoqiang.github.io/tags/Linux/">Linux</a>
    
    <a href="https://wushaoqiang.github.io/tags/Log/">Log</a>
    
    <a href="https://wushaoqiang.github.io/tags/Map/">Map</a>
    
    <a href="https://wushaoqiang.github.io/tags/Module/">Module</a>
    
    <a href="https://wushaoqiang.github.io/tags/Mongodb/">Mongodb</a>
    
    <a href="https://wushaoqiang.github.io/tags/NAT/">NAT</a>
    
    <a href="https://wushaoqiang.github.io/tags/NoSQL/">NoSQL</a>
    
    <a href="https://wushaoqiang.github.io/tags/Path/">Path</a>
    
    <a href="https://wushaoqiang.github.io/tags/Pipeline/">Pipeline</a>
    
    <a href="https://wushaoqiang.github.io/tags/SQL/">SQL</a>
    
    <a href="https://wushaoqiang.github.io/tags/Search/">Search</a>
    
    <a href="https://wushaoqiang.github.io/tags/Sentences/">Sentences</a>
    
    <a href="https://wushaoqiang.github.io/tags/Slice/">Slice</a>
    
    <a href="https://wushaoqiang.github.io/tags/Sort/">Sort</a>
    
    <a href="https://wushaoqiang.github.io/tags/Strings/">Strings</a>
    
    <a href="https://wushaoqiang.github.io/tags/TCP/">TCP</a>
    
    <a href="https://wushaoqiang.github.io/tags/TS/">TS</a>
    
    <a href="https://wushaoqiang.github.io/tags/UDP/">UDP</a>
    
    <a href="https://wushaoqiang.github.io/tags/Ubuntu/">Ubuntu</a>
    
    <a href="https://wushaoqiang.github.io/tags/Validation/">Validation</a>
    
    <a href="https://wushaoqiang.github.io/tags/Vscode/">Vscode</a>
    
    <a href="https://wushaoqiang.github.io/tags/Web/">Web</a>
    
    <a href="https://wushaoqiang.github.io/tags/easy/">easy</a>
    
    <a href="https://wushaoqiang.github.io/tags/gocode/">gocode</a>
    
    <a href="https://wushaoqiang.github.io/tags/goquery/">goquery</a>
    
    <a href="https://wushaoqiang.github.io/tags/gorm/">gorm</a>
    
    <a href="https://wushaoqiang.github.io/tags/handler/">handler</a>
    
    <a href="https://wushaoqiang.github.io/tags/make/">make</a>
    
    <a href="https://wushaoqiang.github.io/tags/mega/">mega</a>
    
    <a href="https://wushaoqiang.github.io/tags/network/">network</a>
    
    <a href="https://wushaoqiang.github.io/tags/new/">new</a>
    
    <a href="https://wushaoqiang.github.io/tags/protocal/">protocal</a>
    
    <a href="https://wushaoqiang.github.io/tags/questions/">questions</a>
    
    <a href="https://wushaoqiang.github.io/tags/viper/">viper</a>
    
    <a href="https://wushaoqiang.github.io/tags/%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5/">依赖注入</a>
    
    <a href="https://wushaoqiang.github.io/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/">内存管理</a>
    
    <a href="https://wushaoqiang.github.io/tags/%E5%8A%A0%E5%AF%86/">加密</a>
    
    <a href="https://wushaoqiang.github.io/tags/%E5%9F%BA%E7%A1%80/">基础</a>
    
    <a href="https://wushaoqiang.github.io/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/">密码学</a>
    
    <a href="https://wushaoqiang.github.io/tags/%E5%B0%8F%E6%8A%80%E5%B7%A7/">小技巧</a>
    
    <a href="https://wushaoqiang.github.io/tags/%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/">异常处理</a>
    
    <a href="https://wushaoqiang.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a>
    
    <a href="https://wushaoqiang.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a>
    
    <a href="https://wushaoqiang.github.io/tags/%E6%A0%87%E5%87%86%E5%BA%93/">标准库</a>
    
    <a href="https://wushaoqiang.github.io/tags/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%8C%85/">第三方包</a>
    
    <a href="https://wushaoqiang.github.io/tags/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/">网络协议</a>
    
    <a href="https://wushaoqiang.github.io/tags/%E7%BD%91%E7%BB%9C%E7%AE%A1%E7%90%86/">网络管理</a>
    
    <a href="https://wushaoqiang.github.io/tags/%E8%A7%82%E7%82%B9/">观点</a>
    
    <a href="https://wushaoqiang.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/">计算机基础</a>
    
    <a href="https://wushaoqiang.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/">计算机系统</a>
    
    <a href="https://wushaoqiang.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a>
    
    <a href="https://wushaoqiang.github.io/tags/%E8%B5%84%E6%BA%90/">资源</a>
    
    <a href="https://wushaoqiang.github.io/tags/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/">进程管理</a>
    
    <a href="https://wushaoqiang.github.io/tags/%E9%85%8D%E7%BD%AE%E9%97%AE%E9%A2%98/">配置问题</a>
    
    <a href="https://wushaoqiang.github.io/tags/%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/">错误处理</a>
    
    <a href="https://wushaoqiang.github.io/tags/%E9%9D%A2%E8%AF%95/">面试</a>
    
</div>
    </section>

    

    <section class="widget">
        <h3 class="widget-title">其它</h3>
        <ul class="widget-list">
            <li><a href="https://wushaoqiang.github.io/index.xml">文章 RSS</a></li>
        </ul>
    </section>
</div>
        </div>
    </div>
</div>
<footer id="footer">
    <div class="container">
        &copy; 2019 <a href="https://wushaoqiang.github.io">Gavin&#39;s Blog By Gavin</a>.
        Powered by <a rel="nofollow noreferer noopener" href="https://gohugo.io" target="_blank">Hugo</a>.
        <a href="https://www.flysnow.org/" target="_blank">Theme</a> based on <a href="https://github.com/rujews/maupassant-hugo" target="_blank">maupassant</a>.
        
    </div>
</footer>


    <script type="text/javascript">
    
    (function(){
        $("pre code").parent().addClass("line-numbers")
    }())

    window.MathJax = {
        tex2jax: {
            inlineMath: [ ['$','$'] ],
            processEscapes: true
        }
    };
    </script>
    <script type="text/javascript" src="/js/prism.js" async="true"></script>
    <script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML' async></script>

<a id="rocket" href="#top"></a>
<script type="text/javascript" src="/js/totop.js?v=0.0.0" async=""></script>



<script type="text/javascript" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script>




</body>
</html>
