<!doctype html>
<html lang="en-us">
<head>

    <meta charset="utf-8">
    <meta name="generator" content="Hugo 0.40.1" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <title>Go琐碎笔记 | Gavin&#39;s Blog</title>
    <meta property="og:title" content="Go琐碎笔记 - Gavin&#39;s Blog">
    <meta property="og:type" content="article">
        
    <meta property="article:published_time" content="2019-03-14T16:10:59&#43;08:00">
        
        
    <meta property="article:modified_time" content="2019-03-14T16:10:59&#43;08:00">
        
    <meta name="Keywords" content="Golang,Gavin,Blog">
    <meta name="description" content="Go琐碎笔记">
        
    <meta name="author" content="Gavin">
    <meta property="og:url" content="https://wushaoqiang.github.io/posts/learningGo/">
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">

    <link rel="stylesheet" href="/css/normalize.css">
    
        <link rel="stylesheet" href="/css/prism.css">
    
    <link rel="stylesheet" href="/css/style.css">
    <script type="text/javascript" src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script>

    


    
    
</head>

<body>
<header id="header" class="clearfix">
    <div class="container">
        <div class="col-group">
            <div class="site-name ">
                
                    <a id="logo" href="https://wushaoqiang.github.io">
                        Gavin&#39;s Blog
                    </a>
                
                <p class="description">Gopher，后端开发，网络基础，WEB协议、架构、存储、缓冲、安全，学习笔记</p>
            </div>
            <div>
                <nav id="nav-menu" class="clearfix">
                    <a class="" href="https://wushaoqiang.github.io">首页</a>
                    
                    <a  href="https://wushaoqiang.github.io/archives/" title="归档">归档</a>
                    
                    <a  href="https://wushaoqiang.github.io/about/" title="关于">关于</a>
                    
                </nav>
            </div>
        </div>
    </div>
</header>


<div id="body">
    <div class="container">
        <div class="col-group">

            <div class="col-8" id="main">
                <div class="res-cons">
                    <article class="post">
                        <header>
                            <h1 class="post-title">Go琐碎笔记</h1>
                        </header>
                        <date class="post-meta meta-date">
                            2019年3月14日
                        </date>
                        
                        <div class="post-meta">
                            <span>|</span>
                            
                                <span class="meta-category"><a href="https://wushaoqiang.github.io/categories/Golang">Golang</a></span>
                            
                        </div>
                        
                        
                        <div class="post-meta">
                            <span id="busuanzi_container_page_pv">|<span id="busuanzi_value_page_pv"></span><span> 阅读</span></span>
                        </div>
                        
                        <div class="post-content">
                            

<p>在test文件要是以_test.go结尾，或者是在文件开头加上<code>// +build (tag)</code> 其中tag是自己定的，然后测试的时候在Terminal输入</p>

<h1 id="2019-2-16">2019.2.16</h1>

<p><code>go test -tags tagname</code></p>

<p>构造数组可以先  <code>make([]int,0)</code></p>

<p>然后  再使用函数：<code>func append(slice []Type, elems ...Type) []Type</code></p>

<p><code>unicode.IsLetter(r rune) bool</code>是判断是否为字母，而不是ASCII</p>

<p><code>res, ok := map[...]</code> 中的ok变量可以用来判断key是否存在</p>

<p><code>[]rune</code>可以直接转换为字符串<code>string([]rune)</code></p>

<h1 id="2019-2-17">2019.2.17</h1>

<p><strong>谨记！</strong> ： <strong>切片和Map在函数传递都是指针传递(引用)</strong></p>

<pre><code class="language-go">
func normalize(cleartext string) string {
	var b strings.Builder

	for _, r := range cleartext {
		if unicode.IsLetter(r) || unicode.IsDigit(r) {
			b.WriteRune(unicode.ToLower(r))
		}
	}

	return b.String()
}

</code></pre>

<p><code>b.WriteRune(unicode.ToLower(r))</code> :可以用这种方式代替append()</p>

<p><code>norm = fmt.Sprintf(&quot;%-[1]*s&quot;, c*r, norm)</code>: 其实就是将出c*r代入到[1]*形成的在右侧填充空格</p>

<pre><code>|类型   |默认值  |
|int   | 0      |
|string|“”      |
| bool | false  |
</code></pre>

<p>定义一个常量：<code>const name type = value</code> value是必须要有的
枚举：Go没有枚举，用const构造，有两种方法(<a href="https://www.jianshu.com/p/cce89a76f6b9">参考这里的</a>)</p>

<pre><code class="language-go">func enums() {
	// 使用 const 块来实现枚举
	const (
		java = 0
		cpp  = 1
		c    = 2
	)
	fmt.Println(java, cpp, c) // 0 1 2
	// 使用 iota 块来实现自增枚举
	const (
		java1 = iota
		cpp1
		c1
	)
	fmt.Println(java1, cpp1, c1) // 0 1 2
}
</code></pre>

<p><code>if contents, err := ioutil.ReadFile(filename); err != nil</code>:可以将要判断的变量在if块里定义并且赋值，但是这样就只能在if块里面用了</p>

<p>switch的case里面自带break，如果不需要break，用fallthrough可以继续下面的case里面的内容(不同判断，直接执行)</p>

<pre><code class="language-go">switch java {
	case 0:
		fmt.Println(&quot;yes&quot;)
		fallthrough
	case 1:
		fmt.Println(&quot;no&quot;)
	}
</code></pre>

<pre><code class="language-go">输出：
yes
no
</code></pre>

<p><strong>Go没有while，只有for循环</strong></p>

<pre><code class="language-go">//可以没有三大组件(用法像while)
for scanner.Scan() {
        fmt.Println(scanner.Text())
    }
</code></pre>

<p><strong>Go可以用函数作为参数(函数式编程)</strong></p>

<pre><code class="language-go">func main() {
	a := 10
	b := 2
	method(add, a, b)
	method(sub, a, b)
}

func method(f func(int, int) int, a, b int) {
	fmt.Println(f(a, b))
}

func add(a, b int) int {
	return a + b
}

func sub(a, b int) int {
	return a - b
}

//output:
//12
//8
</code></pre>

<p><strong>当参数为函数的时候，只要传函数的名字即可</strong></p>

<p><strong>Go只有值传递(引用是传递了指针的值)</strong>
取指针用<code>&amp;</code>
<code>func Name (a,b *int)</code>指参数是int类型 **指针 **
传参的时候<code>(&amp;a,&amp;b)</code></p>

<p>**指针传递更适用在数组的传递 **
因为直接拷贝整个数组内容会造成非常大的开销，需要避免。</p>

<p><strong>数组是定长的，切片是不定长的</strong></p>

<h2 id="数组">数组</h2>

<p>数组类型包括<strong>type</strong>和<strong>length</strong>,要使得数组类型相同，就得两个都相同才是相同</p>

<pre><code class="language-go">func main() {
	arr1 := [3]int{}
	arr2 := [3]int{}
	fmt.Printf(&quot;%T,%T\n&quot;, arr1, arr2)
	fmt.Println(reflect.TypeOf(arr1) == reflect.TypeOf(arr2))
}
</code></pre>

<pre><code>[3]int,[3]int
true
</code></pre>

<p>类型相同，长度不同：</p>

<pre><code class="language-go">func main() {
	arr1 := [3]int{}
	arr2 := [5]int{}
	fmt.Printf(&quot;%T,%T\n&quot;, arr1, arr2)
	fmt.Println(reflect.TypeOf(arr1) == reflect.TypeOf(arr2))
}
</code></pre>

<pre><code>[3]int,[5]int
false
</code></pre>

<p><strong>所以数组类型是严格相等的</strong>
定义数组的方法  <strong>!!!!一定要带长度，或者&hellip;然后在{}输入数据让编译器自动获取长度</strong>
<code>var arr [3]int</code> or <code>arr := [3]int{}</code> or <code>arr := [...]int{1,2,3}</code>
 <strong>数组一旦定义下来就不能修改长度</strong></p>

<h2 id="切片">切片</h2>

<p>切片有3个部分：</p>

<ul>
<li>指针</li>
<li>长度</li>
<li>容量</li>
</ul>

<p><strong>创建切片的方法</strong>：</p>

<ul>
<li><p><code>make([]int,3)</code>:容量和长度都是3</p></li>

<li><p><code>make([]int,3,4)</code>:长度是3 容量是5</p></li>

<li><p><code>slice := []int{1,2,3}</code>:长度是3 容量是5  **[]无长度 **</p></li>

<li><p><code>slice := arr[2:4]</code>:包括了左边，不包括右边，即<code>[2,4)</code></p></li>
</ul>

<p><strong>!!!注意底层数组分离细节</strong>
若切片指向的底层一样，则一个修改后，另一个指向同样底层的切片也会发生改变，like：</p>

<pre><code class="language-go"> slice2 := slice1[1:3] // [2, 3]
    slice2[1] = 300
    fmt.Println(slice2) // [2, 300]
    fmt.Println(slice1) // [1, 2, 300, 400, 5] slice1也发生了变化
</code></pre>

<blockquote>
<p>只修改了slice2，但是因为和slice1指向同样的底层，所以slice1也变化了</p>
</blockquote>

<p><strong>删除slice中元素</strong></p>

<pre><code class="language-go">slice := []int{1, 2, 3, 4}
slice = append(slice5[:2], slice5[3:]...)
</code></pre>

<p><strong>留意底层切片</strong></p>

<pre><code class="language-go">    // 1、创建原始切片，长度是5，容量是5
    slice := []int{10, 20, 30, 40, 50}
    // 2、reslice 新切片，长度是2，容量是4
    newSlice := slice[1:3] // [20, 30]
    // 由于底层数组还有容量，可以直接追加元素而容量不变
    newSlice = append(newSlice, 60) // [20, 30 ,60] 长度是3，容量是4
    fmt.Println(newSlice)           // [20, 30 ,60]
    fmt.Println(slice)              // [10, 20, 30 ,60, 50]

</code></pre>

<p>**但是当newSlice的长度大约原来容量时，它们就不会共享同一个底层切片，而是不同的底层切片 **</p>

<p><strong>slice 扩容机制</strong>：在切片的容量小于 1000 个元素时，总是会成倍地增加容量。一旦元素个数超过 1000，容量的增长因子会设为 1.25，也就是会每次增加 25% 的容量</p>

<p><strong>!!!注意 切片在函数间传递是以指针的形式的</strong></p>

<p>所以可能会造成不经意的修改</p>

<blockquote>
<h2 id="map">Map</h2>
</blockquote>

<p>-Map是无序的，所以迭代出来的map每次都可能不一样</p>

<p>-slice,function,map,包含切片的结构体都不能作为Key</p>

<p>-map在函数传递时也是引用的</p>

<p><code>make</code> or <code>:=</code>
for example:</p>

<pre><code class="language-go">    map1 := make(map[string]int)
    map2 := map[string][]string{&quot;hi&quot;: {&quot;go&quot;, &quot;c&quot;}, &quot;hello&quot;: []string{&quot;java&quot;}}
    map3 := map[string]string{} // map3 := map[string]string nil映射
</code></pre>

<p>add to a map:<code>map[...] = ...</code></p>

<p>determine whether the element is in the map: <code>value,ok := map[...]</code>
and if the key we put in is not exist: <code>ok = false</code>,otherwise <code>ok = true</code>
we can code like that:</p>

<pre><code class="language-go">if ok {
 //exist
}else{
 //not exist
}
</code></pre>

<p>delete a element from a map:<code>delete(mapName,element)</code>
 <strong>remember!!!</strong>
if you change a map in a subfunction,the map will be changed in other function. so passing a map is not a copy, it is a reference</p>

<h2 id="class">class</h2>

<p>define a class, you can ues:</p>

<pre><code class="language-go">type className struct{
	...
}
</code></pre>

<p>instantiate the class, you can do<code>var name className</code> just like the other(<code>int string...</code>).Also, you can instantiate with values like:</p>

<pre><code class="language-go">name := className{
	element1: ....
	element2: ....
	...
}
</code></pre>

<p><strong>function of class</strong></p>

<p>function also can be called method, method of class will be different with normal function like <code>func funcName(...) ...{}</code>. A function of class add one more parameter than normal function : <code>func(reciver) funcName(...) ... {}</code></p>

<ul>
<li><p><code>func(u class) funcName(...)...{}</code>: copy the parameter of class you input</p></li>

<li><p><code>func(u *class) funcName(...)...{}</code>: use the inference of class instantiation you input
in a word, the first function will not change anything outside the function.
But the second will.</p></li>
</ul>

<h2 id="interface">interface</h2>

<p>接口可以实现多态</p>

<pre><code class="language-go">package main
import &quot;fmt&quot;
type Teacher struct {
	Name string
}
type Student struct {
	Name string
}
type notifier interface {
	notice()
}
func (t Teacher) notice() {
	fmt.Println(t.Name, &quot;noticing&quot;)
}
func (s Student) notice() {
	fmt.Println(s.Name, &quot;informing&quot;)
}
//sendMsg接收一个实现了notifier接口的struct
func sendMsg(n notifier) {
	n.notice()
}
func main() {
	t := Teacher{&quot;abx&quot;}
	s := Student{&quot;xyz&quot;}
	sendMsg(t)		//abx noticing
	sendMsg(s)		//xyz informing
}
</code></pre>

<p><code>snedMsg()</code>即可传入<code>Student</code>类型又可以传入<code>Teacher</code>类型，因为他们都实现了接口<code>notifier</code>的函数。这就实现了多态函数。
<strong>许多Go内置函数的参数都有interface类型的参数，可以传不同类型的参数，这就实现了多态(可以一个参数解析不同类型)</strong></p>

<p>在面对对象编程时，如果有多个对象实现同样的函数时，可以使用接口来定义函数，然后用多态的性质建造一个函数可以为多个对象使用</p>

<h2 id="资源和错误管理">资源和错误管理</h2>

<p><code>defer</code>:</p>

<ul>
<li><p>在函数调用结束的时候才调用的</p></li>

<li><p>先进后出的形式(栈)</p></li>
</ul>

<p><em>注：结束包括了非正常结束</em></p>

<ul>
<li>defer 函数定义时，对外部变量的引用是有两种方式的</li>
</ul>

<ol>
<li><p>通过传入参数(传入是时候就已经确定了)</p></li>

<li><p>通过闭包引用(在真正调用defer函数的时候才去决定这个值是多少)</p></li>
</ol>

<p><code>error</code>:</p>

<ul>
<li>是一个接口，<code>errors</code>是它的一个实现 <code>err := errors.New(string)</code></li>
</ul>

<h2 id="goroutine">Goroutine</h2>

<p><strong>竞争状态</strong>：如果两个或者多个 goroutine 在没有互相同步的情况下，访问某个共享的资源，并试图 <strong>同时读和写</strong>这个资源，就处于相互竞争的状态</p>

<p>简单实例代码：</p>

<pre><code class="language-go">import (
    &quot;runtime&quot;
    &quot;sync&quot;
    &quot;fmt&quot;
)

func main() {
    // 1. 分配一个逻辑处理器给调度器使用
    runtime.GOMAXPROCS(1)

    // 2. 设定等待器，类比 Java CountDownLatch
    var waitGroup sync.WaitGroup
    waitGroup.Add(2)

    fmt.Println(&quot;=== start ===&quot;)
    // 3. 创建第一个 goroutine
    go func() {
        defer waitGroup.Done() // CountDownLatch#countDown()

        // 打印3遍字母表
        for count := 0; count &lt; 3; count++ {
            for char := 'a'; char &lt; 'a'+26; char++ {
                fmt.Printf(&quot;%c&quot;, char)
            }
        }
    }()

    // 4. 创建第二个 goroutine
    go func() {
        defer waitGroup.Done() // CountDownLatch#countDown()

        // 打印3遍字母表
        for count := 0; count &lt; 3; count++ {
            for char := 'A'; char &lt; 'A'+26; char++ {
                fmt.Printf(&quot;%c&quot;, char)
            }
        }
    }()

    // 5. 阻塞 main goroutine
    waitGroup.Wait() // CountDownLatch#await()
    fmt.Println(&quot;=== end ===&quot;)
}
</code></pre>

<p>创建goroutine：</p>

<ul>
<li><p>匿名函数实现方式 go func() {xxx}()</p></li>

<li><p>普通函数 funcA 实现方式 go funcA()</p></li>
</ul>

<p>当一个goroutine长时间占用逻辑处理器时，会被调度器停止，并给其他可运行的goroutine运行的机会</p>

<p><code>runtime.GOMAXPROCS(1)</code>:GOMAXPROCS设置可以同时执行的最大cpu数量</p>

<p><code>defer waitGroup.Done()</code>:当goroutine被执行完后，将WaitGroup counter减一</p>

<p><code>waitGroup.Add(2)</code>: WaitGroup counter 加2</p>

<p><code>waitGroup.Wait()</code>: 阻塞-直到WaitGroup counter = 0</p>

<p><code>runtime.Gosched()</code>:让处理器先处理别的goroutine</p>

<pre><code class="language-go">var (
	shutdown  int64
	waitGroup sync.WaitGroup
)

func doWork(name string) {
	defer waitGroup.Done()
	for {
		time.Sleep(250 * time.Millisecond)
		// 记载关机标志
		if atomic.LoadInt64(&amp;shutdown) == 1 {
			fmt.Println(&quot;shutDown, &quot;, name)
			break
		}
	}
}

func main() {
	waitGroup.Add(2)

	go doWork(&quot;A&quot;)
	go doWork(&quot;B&quot;)

	// 给定goroutine执行的时间
	time.Sleep(1000 * time.Millisecond)

	// 设定关机标志
	atomic.StoreInt64(&amp;shutdown, 1)

	waitGroup.Wait()
}
</code></pre>

<p>因为一开始shutdown = 0，所以两个goroutine一直在死循环，无法输出，过了<code>time.Sleep(1000 * time.Millisecond)</code>后，<code>atomic.StoreInt64(&amp;shutdown, 1)</code>将shutdown = 1，<code>atomic.LoadInt64(&amp;shutdown) == 1</code> 才成立，goroutine才能输出结果。程序想体现出来的是goroutine一直在读取shutdown，而main在写shutdown，用<code>atomic.LoadInt64(&amp;shutdown)</code>和<code>atomic.StoreInt64(&amp;shutdown, 1)</code>可以进行安全读写，不会产生竞争</p>

<p>处理竟态资源的三种方法：atomic、mutex、channel</p>

<h2 id="channel">Channel</h2>

<p>Channel分两种</p>

<ul>
<li><p>无缓冲的Channel：这种类型要求发生goroutine和接受goroutine同时准备好才能完成发送和接收操作。如果两个 goroutine 没有同时准备好，通道会导致先执行发送或接收操作的 goroutine  **阻塞等待 **。这种对通道进行发送和接收的交互行为本身就是 **同步 **的。</p></li>

<li><p>有缓冲的 Channel：这种类型的通道并不强制要求 goroutine 之间必须同时完成发送和接收。<code>只有在通道中没有要接收的值时，接收动作才会阻塞。只有在通道没有可用缓冲区容纳被发送的值时，发送动作才会阻塞</code>。</p></li>
</ul>

<p>无缓冲示例：</p>

<pre><code class="language-go">import (
	&quot;fmt&quot;
	&quot;math/rand&quot;
	&quot;sync&quot;
)

var wg sync.WaitGroup

// Channel 完整的类型是 &quot;chan 数据类型&quot;
func player(name string, court chan int) {
	defer wg.Done()

	for {
		// 1. 阻塞等待接球，如果通道关闭，ok返回false
		ball, ok := &lt;-court
		if !ok {
			fmt.Printf(&quot;channel already closed! Player %s won\n&quot;, name)
			return
		}

		random := rand.Intn(100)
		if random%13 == 0 {
			fmt.Printf(&quot;Player %s Lose\n&quot;, name)
			// 关闭通道
			close(court)
			return
		}

		fmt.Printf(&quot;Player %s Hit %d\n&quot;, name, ball)
		ball++
		// 2. 发球，阻塞等待对方接球
		court &lt;- ball
	}
}

// 两个 player 打网球，即生产者和消费者模式（互为生产者和消费者）
func main() {
	wg.Add(2)

	// 1. 创建一个无缓冲的通道
	// Channel 完整的类型是 &quot;chan 数据类型&quot;
	court := make(chan int)

	// 2. 创建两个 goroutine
	go player(&quot;zhangsan&quot;, court)
	go player(&quot;lisi&quot;, court)

	// 3. 发球：向通道发送数据，阻塞等待通道对端接收
	court &lt;- 1

	// 4. 等待输家出现
	wg.Wait()
}
</code></pre>

<p><code>将WaitGroup = 2</code> -&gt; <code>创建一个无缓冲通道</code> -&gt; <code>利用go funcA()结构创建两个goroutine</code> -&gt;<code>两个goroutine都阻塞在 ball, ok := &lt;- court</code> -&gt; <code>直到 court &lt;- 1才把数据传入通道</code> -&gt; <code>这个时候才开始两个goroutine之间数据的传递</code></p>

<p>有缓冲的Channel使用示例：</p>

<pre><code class="language-go">import (
	&quot;fmt&quot;
	&quot;sync&quot;
	&quot;time&quot;
)

// 使用4个goroutine来完成10个任务
const (
	taskNum      = 10
	goroutineNum = 4
)

var countDownLatch sync.WaitGroup

func worker(name string, taskChannel chan string) {
	defer countDownLatch.Done()
	for {
		// 1. 不断的阻塞等待分配工作
		task, ok := &lt;-taskChannel
		if !ok {
			fmt.Printf(&quot;channel closed and channel is empty\n&quot;)
			return
		}

		//fmt.Printf(&quot;worker %s start %s\n&quot;, name, task)
		time.Sleep(100 * time.Millisecond)
		fmt.Printf(&quot;worker %s complete %s\n&quot;, name, task)
	}
}

func main() {
	countDownLatch.Add(goroutineNum)
	// 1. 创建有缓冲区的string channel
	taskChannel := make(chan string, taskNum)

	// 2. 创建 4 个goroutine去干活
	for i := 0; i &lt; goroutineNum; i++ {
		go worker(fmt.Sprintf(&quot;worker %d&quot;, i), taskChannel)
	}

	// 3. 向通道加入task
	for i := 0; i &lt; taskNum; i++ {
		taskChannel &lt;- fmt.Sprintf(&quot;task %d&quot;, i)
	}

	// 4. 关闭通道：
	// 当通道关闭后，goroutine 依旧可以从通道接收数据，但是不能再向通道里发送数据。
	// 能够从已经关闭的通道接收数据这一点非常重要，因为这允许通道关闭后依旧能取出其中缓冲的全部值，而不会有数据丢失。
	// 从一个已经关闭且没有数据的通道里获取数据，总会立刻返回，并返回一个通道类型的零值
	close(taskChannel)

	// 5. 等待
	countDownLatch.Wait()
}
</code></pre>

<p>创建有缓冲区的Channel:<code>make(chan int, num)</code>
 <strong>通道关闭 -&gt; 不能传入数据，但可以读取之前传入缓冲区的数据</strong>
并且只有通道关闭了才能够让<code>task, ok := &lt;-taskChannel</code>的ok收到<code>false</code></p>

<h2 id="exercism">Exercism</h2>

<p><code>^</code>在Go语言里面不是乘方，乘方可以用<code>math.Pow()</code></p>

<p><code>%02d</code>:向左补充0填满两位指数，例如9，输出是09。相反的<code>%-02d</code>向右补充0到两位数字</p>

<p><code>exported func New returns unexported type clock.hm, which can be annoying to use</code>：把hm改成Hm(首字母大写)。
在 Go 中，当变量或函数的首字母大写的时候，函数(变量)会被从包中导出（在包外部可见，或者说 <strong>公有</strong>的）</p>

<pre><code class="language-go">func ConcurrentFrequency(input []string) FreqMap {
	freq := FreqMap{}
	lineChan := make(chan FreqMap, 3)
	for _, piece := range input {
		go channeler(piece, lineChan)
	}

	for i := 0; i &lt; 3; i++ {
		data := &lt;-lineChan
		for key, value := range data {
			if curr, ok := freq[key]; ok {
				freq[key] = value + curr
			} else {
				freq[key] = value
			}
		}
	}

	return freq
}

func channeler(piece string, mapChan chan&lt;- FreqMap) {
	mapChan &lt;- Frequency(piece)
}
</code></pre>

<p>带缓冲的channel 里面的数据要一个个拿出来。</p>

<ul>
<li>Channel Direction</li>
</ul>

<ol>
<li><p><code>func pinger(c chan&lt;- string)</code>:只能往通道发送数据</p></li>

<li><p><code>func printer(c &lt;-chan string)</code>:只能接收通道数据</p></li>
</ol>

<ul>
<li>Select</li>
</ul>

<p>像switch，但是只能用于channel</p>

<ol>
<li><p>如果通道无法从通道取出数据又无<code>default</code>，则会造成阻塞</p></li>

<li><p>如果有<code>default</code>，在case上的通道都取不到数据的时候，会调用<code>default</code>语句</p></li>
</ol>

<pre><code class="language-go">select {
      case msg1 := &lt;- c1:
        fmt.Println(msg1)
      case msg2 := &lt;- c2:
        fmt.Println(msg2)
      }
</code></pre>

<h2 id="慕课网beego和gin对比">慕课网Beego和Gin对比</h2>

<p><strong>Beego</strong>:</p>

<pre><code class="language-go">import (
	&quot;fmt&quot;

	&quot;github.com/astaxie/beego&quot;
)

type RESTfulController struct {
	beego.Controller
}

func (this *RESTfulController) Get() {
	this.Ctx.WriteString(&quot;Hello GET!&quot;)
}

func (this *RESTfulController) Post() {
	this.Ctx.WriteString(&quot;Hello Post&quot;)
}

type RegExpController struct {
	beego.Controller
}

func (this *RegExpController) Get() {
	this.Ctx.WriteString(&quot;Hello In Reg GET!\n&quot;)

	id := this.Ctx.Input.Param(&quot;:id&quot;)
	this.Ctx.WriteString(fmt.Sprintf(&quot;id is: %s\n&quot;, id))

	splat := this.Ctx.Input.Param(&quot;:splat&quot;)
	this.Ctx.WriteString(fmt.Sprintf(&quot;splat is: %s\n&quot;, splat))

	path := this.Ctx.Input.Param(&quot;:path&quot;)
	this.Ctx.WriteString(fmt.Sprintf(&quot;path is: %s\n&quot;, path))

	ext := this.Ctx.Input.Param(&quot;:ext&quot;)
	this.Ctx.WriteString(fmt.Sprintf(&quot;ext is: %s\n&quot;, ext))
}

func main() {
	beego.Router(&quot;/RESTful&quot;, &amp;RESTfulController{})
	beego.Router(&quot;/RegExp1/?:id&quot;, &amp;RegExpController{})
	beego.Router(&quot;/RegExp2/([0-9]+):id&quot;, &amp;RegExpController{})
	beego.Router(&quot;/RegExp3/([\\w]+):id&quot;, &amp;RegExpController{})
	beego.Router(&quot;/RegExp4/abc:id([0-9]+)de&quot;, &amp;RegExpController{})
	beego.Router(&quot;/RegExp5/*&quot;, &amp;RegExpController{})
	beego.Router(&quot;/RegExp6/*.*&quot;, &amp;RegExpController{})
	beego.Run(&quot;127.0.0.1:8081&quot;)
}
</code></pre>

<p>在web开发中，“route”(路由)是指根据url， 分配到对应的处理程序。</p>

<p><strong>Gin</strong>:
不能像Beego那样支持正则路由</p>

<h2 id="2019-2-20">2019.2.20</h2>

<p><code>_ &quot;github.com/go-sql-driver/mysql&quot;</code> 一个程序里引进了一个package但是前面有下划线是表明
 <strong>包的init函数被调用但不想在代码的其他地方引用它</strong></p>

<p><code>CRUD</code>:Create Read Update Delete</p>

<h3 id="go-mysql">Go-Mysql</h3>

<p>用于学习的示例程序：</p>

<pre><code class="language-go">package main

import (
	&quot;database/sql&quot;
	&quot;fmt&quot;

	_ &quot;github.com/go-sql-driver/mysql&quot;
)

func main() {
	//打开数据库
	//DSN数据源字符串：用户名:密码@协议(地址:端口)/数据库?参数=参数值
	db, err := sql.Open(&quot;mysql&quot;, &quot;root:123456@tcp(127.0.0.1:3306)/test?charset=utf8&quot;)
	if err != nil {
		fmt.Println(err)
	}

	//关闭数据库，db会被多个goroutine共享，可以不调用
	defer db.Close()

	db.Exec(&quot;CREATE TABLE test(id SMALLINT, name VARCHAR(20),price SMALLINT)&quot;)
	db.Exec(&quot;INSERT test(id,name,price) VALUES(1,'W',1000)&quot;)
	db.Exec(&quot;INSERT test(id,name,price) VALUES(2,'S',2000)&quot;)
	db.Exec(&quot;INSERT test(id,name,price) VALUES(3,'Q',3000)&quot;)

	//查询数据，指定字段名，返回sql.Rows结果集
	rows, _ := db.Query(&quot;select id,name from test&quot;)
	id := 0
	name := &quot;&quot;
	for rows.Next() {
		rows.Scan(&amp;id, &amp;name)
		fmt.Println(id, name)
	}

	//查询数据，取所有字段
	rows2, _ := db.Query(&quot;select * from test&quot;)
	//返回所有列
	cols, _ := rows2.Columns()
	//这里表示一行所有列的值，用[]byte表示
	vals := make([][]byte, len(cols))
	//这里表示一行填充数据
	scans := make([]interface{}, len(cols))
	//这里scans引用vals，把数据填充到[]byte里
	for k, _ := range vals {
		scans[k] = &amp;vals[k]
	}

	i := 0
	result := make(map[int]map[string]string)
	for rows2.Next() {
		//填充数据
		rows2.Scan(scans...)
		//每行数据
		row := make(map[string]string)
		//把vals中的数据复制到row中
		for k, v := range vals {
			key := cols[k]
			//这里把[]byte数据转成string
			row[key] = string(v)
		}
		//放入结果集
		result[i] = row
		i++
	}
	fmt.Println(result)

	//查询一行数据
	rows3 := db.QueryRow(&quot;select id,name from test where id = ?&quot;, 1)
	rows3.Scan(&amp;id, &amp;name)
	fmt.Println(id, name)

	//插入一行数据
	ret, _ := db.Exec(&quot;insert into test(id,name) values(null, '444')&quot;)
	//获取插入ID
	ins_id, _ := ret.LastInsertId()
	fmt.Println(ins_id)

	//更新数据
	ret2, _ := db.Exec(&quot;update test set name = '000' where id &gt; ?&quot;, 2)
	//获取影响行数
	aff_nums, _ := ret2.RowsAffected()
	fmt.Println(aff_nums)

	//删除数据
	ret3, _ := db.Exec(&quot;delete from test where id = ?&quot;, 3)
	//获取影响行数
	del_nums, _ := ret3.RowsAffected()
	fmt.Println(del_nums)

	//预处理语句
	stmt, _ := db.Prepare(&quot;select id,name from test where id = ?&quot;)
	rows4, _ := stmt.Query(3)
	//注意这里需要Next()下，不然下面取不到值
	rows4.Next()
	rows4.Scan(&amp;id, &amp;name)
	fmt.Println(id, name)

	stmt2, _ := db.Prepare(&quot;insert into test values(null, ?, ?)&quot;)
	rows5, _ := stmt2.Exec(&quot;666&quot;, 66)
	fmt.Println(rows5.RowsAffected())

	//事务处理
	tx, _ := db.Begin()

	ret4, _ := tx.Exec(&quot;update test set price = price + 100 where id = ?&quot;, 1)
	ret5, _ := tx.Exec(&quot;update test set price = price - 100 where id = ?&quot;, 2)
	upd_nums1, _ := ret4.RowsAffected()
	upd_nums2, _ := ret5.RowsAffected()

	if upd_nums1 &gt; 0 &amp;&amp; upd_nums2 &gt; 0 {
		//只有两条更新同时成功，那么才提交
		tx.Commit()
	} else {
		//否则回滚
		tx.Rollback()
	}
}
</code></pre>

<p>结果：</p>

<pre><code>1 W
2 S
3 Q
map[0:map[id:1 name:W price:1000] 1:map[id:2 name:S price:2000] 2:map[id:3 name:Q price:3000]]
1 W
0
1
1
1 W
1 &lt;nil&gt;
</code></pre>

<p>首先Go是没有Mysql的库的，需要引用第三方库<code>github.com/go-sql-driver/mysql</code></p>

<p>和数据库交涉首先要打开数据库，用
<code>db, err := sql.Open(&quot;mysql&quot;, &quot;root:123456@tcp(127.0.0.1:3306)/test?charset=utf8&quot;)</code>
这里会返回一个数据库的实例对象<code>db</code>，所有相关操作都会由这个对象对数据库操作。</p>

<p><code>defer db.Close()</code> : 这个是在函数执行完毕后，关闭数据库(这里的函数又刚好是主函数，所以也就是程序跑完了就自动关闭数据库)</p>

<p><code>db.Exec()</code> : 这是Execution(执行)的意思，也就是说我们在命令行里操作数据库的命令，可以在Go文件里面用这个函数去代替终端。</p>

<pre><code class="language-go">	db.Exec(&quot;CREATE TABLE test(id SMALLINT, name VARCHAR(20),price SMALLINT)&quot;)
	db.Exec(&quot;INSERT test(id,name,price) VALUES(1,'W',1000)&quot;)
	db.Exec(&quot;INSERT test(id,name,price) VALUES(2,'S',2000)&quot;)
	db.Exec(&quot;INSERT test(id,name,price) VALUES(3,'Q',3000)&quot;)
</code></pre>

<p>把字符串里的语句单独在登录数据库的终端执行得到的效果是一样的。但是这里会返回一个<code>Result</code>对象(程序没有体现)</p>

<p><code>db.Query</code> : Query(查询)，会返回<code>rows</code>对象，这个对象包含了符合查询内容的所有行</p>

<pre><code class="language-go">rows, _ := db.Query(&quot;select id,name from test&quot;)
	id := 0
	name := &quot;&quot;
	for rows.Next() {
		rows.Scan(&amp;id, &amp;name)
		fmt.Println(id, name)
	}
</code></pre>

<p>用和命令行一样的命令来执行查询，返回的对象可以用<code>.Next()</code>来查询是否还有下一行(用来提供遍历)，<code>.Scan()</code>可以用来读取数据。<code>.Colums()</code>可以返回table里面的列元素[]string(上面程序就是id,name,price)</p>

<pre><code class="language-go">	vals := make([][]byte, len(cols))
	//这里表示一行填充数据
	scans := make([]interface{}, len(cols))
	//这里scans引用vals，把数据填充到[]byte里
	for k := range vals {
		scans[k] = &amp;vals[k]
	}
</code></pre>

<p>在这里打算用vals来存取数据库的值(不同类型)，将vals中每个[]byte的地址传给scans。</p>

<pre><code class="language-go">i := 0
	result := make(map[int]map[string]string)
	for rows2.Next() {
		//填充数据
		rows2.Scan(scans...)
		//每行数据
		row := make(map[string]string)
		//把vals中的数据复制到row中
		for k, v := range vals {
			key := cols[k]
			//这里把[]byte数据转成string
			row[key] = string(v)
		}
		//放入结果集
		result[i] = row
		i++
	}
</code></pre>

<p>可以看出还是用<code>.Next()</code>来遍历每一行数据，但是<code>.Scan()</code>传入的是scans，也就是vals中三个[]byte的地址，Scan会把每一行数据写入到vals里，然后再通过遍历vals拿出里面的数据(都转换为string)</p>

<p><code>QueryRow()</code> : 返回第一个符合查询条件的行</p>

<p>Result对象的方法:</p>

<ul>
<li><p><code>LastInsertId()</code> : 一般搭配AUTO_INCREMENT使用，获得最近插入表的ID</p></li>

<li><p><code>RowsAffected()</code> : RowsAffected returns the number of rows affected by an update, insert, or delete(是被影响的数目，而不是第几行)</p></li>
</ul>

<pre><code class="language-go">	stmt, _ := db.Prepare(&quot;select id,name from test where id = ?&quot;)
	rows4, _ := stmt.Query(3)
</code></pre>

<p>预处理句子，只是方便加入参数，加入了<code>Stmt</code>对象，但是到最后面还是返回了<code>Row</code>对象，句子就是将<code>?</code>替换成了<code>3</code>变成了一个完整的句子</p>

<pre><code class="language-go">	stmt2, _ := db.Prepare(&quot;insert into test values(null, ?, ?)&quot;)
	rows5, _ := stmt2.Exec(&quot;666&quot;, 66)
</code></pre>

<p>这里是用<code>Exec()</code>是因为INSERT语句就是用Exec的</p>

<h2 id="一些知识点">一些知识点</h2>

<ul>
<li><p><code>var c, python, java = true, false, &quot;no!&quot;</code> 这样赋值也是可以的</p></li>

<li><p><code>:=</code> 结构不能使用在函数外。</p></li>

<li><p>定义常量<code>const</code> 代替 <code>var</code>  所以是<code>const Pi = 3.14</code> or <code>const Pi float64 = 3.14</code></p></li>

<li><p><code>%v会打印实际类型的值</code>也就是会根据程序给的数据来觉得是输出什么类型</p></li>

<li><p>小数的默认类型是<code>float64</code>，不是<code>float32</code></p></li>
</ul>

<pre><code class="language-go">
	const World = &quot;世界&quot;
	fmt.Println(&quot;Hello&quot;, World)
	fmt.Println(&quot;Happy&quot;, Pi, &quot;Day&quot;)

	const Truth = true
	fmt.Println(&quot;Go rules?&quot;, Truth)
</code></pre>

<ul>
<li><code>Println()</code>还能这样用</li>
<li><code>&lt;&lt;</code> <code>&gt;&gt;</code> <code>^</code> <code>&amp;</code> <code>|</code>和C语言一样</li>
</ul>

<pre><code class="language-go">type Vertex struct {
	X int
	Y int
}

func main() {
	v := Vertex{1, 2}
	p := &amp;v
	p.X = 1e9
	fmt.Println(p)
}
</code></pre>

<p><code>&amp;{1000000000 2}</code></p>

<ul>
<li>不像平常一样输出一个地址</li>
</ul>

<pre><code class="language-go">func main() {
	s := []int{2, 3, 5, 7, 11, 13}

	s = s[1:4]
	fmt.Println(s)

	s = s[:5]
	fmt.Println(s)

	s = s[1:]
	fmt.Println(s)
}
</code></pre>

<pre><code>[3 5 7]
[3 5 7 11 13]
[5 7 11 13]
</code></pre>

<ul>
<li>要对切片的长度和容量又清晰的认识，长度是切片数据的个数，容量是指切片在底层开始的索引到切片底层最后面的索引，举个例子。</li>
</ul>

<pre><code class="language-go">func main() {
	s := []int{2, 3, 5, 7, 11, 13}
	printSlice(s)

	// Slice the slice to give it zero length.
	s = s[:0]
	printSlice(s)

	// Extend its length.
	s = s[:4]
	printSlice(s)

	// Drop its first two values.
	s = s[2:]
	printSlice(s)
}

func printSlice(s []int) {
	fmt.Printf(&quot;len=%d cap=%d %v\n&quot;, len(s), cap(s), s)
}
</code></pre>

<pre><code>len=6 cap=6 [2 3 5 7 11 13]
len=0 cap=6 []
len=4 cap=6 [2 3 5 7]
len=2 cap=4 [5 7]
</code></pre>

<ul>
<li><p>Go也可以做二维数组,或者说是二维slice</p></li>

<li><p>如果让slice自动增加容量，将会变成之前的两倍</p></li>
</ul>

<pre><code class="language-go">func adder() func(int) int {
	sum := 0
	return func(x int) int {
		sum += x
		return sum
	}
}

func main() {
	pos, neg := adder(), adder()
	for i := 0; i &lt; 10; i++ {
		fmt.Println(
			pos(i),
			neg(-2*i),
		)
	}
}
</code></pre>

<pre><code>0 0
1 -2
3 -6
6 -12
10 -20
15 -30
21 -42
28 -56
36 -72
45 -90
</code></pre>

<ul>
<li><p>Go 函数可以是闭包的。闭包是一个函数值，它来自函数体的外部的变量引用。 函数可以对这个引用值进行访问和赋值；换句话说这个函数被“绑定”在这个变量上。  例如，函数 adder 返回一个闭包。每个闭包都被绑定到其各自的 sum 变量上。</p></li>

<li><p>有两个原因需要使用指针接收者。首先避免在每个方法调用中拷贝值（如果值类型是大的结构体的话会更有效率）。其次，方法可以修改接收者指向的值</p></li>
</ul>

<pre><code class="language-go">func main() {
	var i interface{} = &quot;hello&quot;

	s := i.(string)
	fmt.Println(s)

	s, ok := i.(string)
	fmt.Println(s, ok)

	f, ok := i.(float64)
	fmt.Println(f, ok)

	f = i.(float64) // panic
	fmt.Println(f)
}
</code></pre>

<ul>
<li><p>接口可以存储任何类型的值，如果不知道接口是哪种类型的值，可以用上面的方法。</p></li>

<li><p><code>i.(type)</code>可以返回接口里面的数据，而不是类型</p></li>

<li><p><code>%T</code> 可以输出数据类型</p></li>
</ul>

<pre><code class="language-go">type Person struct {
	Name string
	Age  int
}

func (p Person) String() string {
	return fmt.Sprintf(&quot;%v (%v years)&quot;, p.Name, p.Age)
}

func main() {
	a := Person{&quot;Arthur Dent&quot;, 42}
	z := Person{&quot;Zaphod Beeblebrox&quot;, 9001}
	fmt.Println(a, z)
}
</code></pre>

<p><code>fmt.Println()</code> ： 这里会自动调用了Person实现的String()，因为fmt包里面定义了这样的一个接口，同样的error结构体也定义了Error()。</p>

<ul>
<li><p>Go是编译型语言：
使用专门的编译器，针对特定的平台，将高级语言源代码一次性的编译成可被该平台硬件执行的机器码，并包装成该平台所能识别的可执行性程序的格式。</p></li>

<li><p>组成程序的函数、变量、常量、类型的声明语句(分别由关键字 <code>func</code> , <code>var</code> , <code>const</code> , <code>type</code> 定义)</p></li>

<li><p><code>_</code> ：空标识符</p></li>
</ul>

<pre><code>%d 				十进制整数
%x, %o, %b 	十六进制,八进制,二进制整数。
%f, %g, %e 	浮点数: 3.141593 3.141592653589793 3.141593e+00
%t 					布尔:true或false
%c 					字符(rune) (Unicode码点)
%s 					字符串
%q 					带双引号的字符串&quot;abc&quot;或带单引号的字符'c'
%v 					变量的自然形式(natural format)
%T 					变量的类型
%% 				字面上的百分号标志(无操作数)
</code></pre>

<ul>
<li><p><code>os.Args</code>是读取命令行参数<code>go run main.go arg1 arg2...</code>，用<code>os.Args[i]</code>来读取，它是一个字符串切片</p></li>

<li><p><code>func countLines(f *os.File, counts map[string]int)</code>传入一个map，其实是传入引用，也就是在函数里改变，在主函数也有相应改变。</p></li>

<li><p>Go语言程序员推荐使用 驼峰式 命名</p></li>
</ul>

<h2 id="命名导入">命名导入</h2>

<p>如果我们导入的包名正好有重复，可以这样来命名</p>

<pre><code class="language-go">package main

import (
	&quot;fmt&quot;
	myfmt &quot;mylib/fmt&quot;
)

func main() {
	fmt.Println()
	myfmt.Println()
}
</code></pre>

<h2 id="导入不用的包">导入不用的包</h2>

<p>因为Go导入不用的包是会报错的，为此，Go语言给我们提供了一个空白标志符<code>_</code> ，这样就不会报错了，但是以这种方式导入的包会调用包内的<code>init()</code>函数</p>

<pre><code class="language-go">package main

import (
	_ &quot;fmt&quot;
)
</code></pre>

<p><code>go get</code> 后面跟<code>github.com/.../...</code> 并不是<code>github.com/.../... .git</code>  它会直接下载到<code>GOPATH/src</code> 参数<code>-v</code>看到下载进度和调试信息  <code>-u</code>更新</p>

<p><code>go build</code> 直接在当前目录生产二进制文件    <code>go install</code> 在<code>GOPATH/bin</code>目录生成</p>

<p><code>go doc</code>可以在终端快速查看文档，不接参数默认是当前文件夹 <code>go doc json</code> 查看json包</p>

<p><code>array:=[5]int{1:1,3:4}</code> 只对数组的相应位置初始化</p>

<pre><code class="language-go">func main() {
	array := [5]int{1: 2, 3:4}
	modify(&amp;array)
	fmt.Println(array)
}

func modify(a *[5]int){
	a[1] =3
	fmt.Println(*a)
}
</code></pre>

<p>这里的<code>modify</code>函数是传入数组的指针，但是函数里面是用<code>a[1] = 3</code>来改变数组内部的值，而要输出数组则需要用<code>*a</code></p>

<ul>
<li>一般我们在创建新切片的时候，最好要让新切片的长度和容量一样，这样我们在追加操作的时候就会生成新的底层数组，和原有数组分离，就不会因为共用底层数组而引起奇怪问题,因为共用数组的时候修改内容，会影响多个切片。</li>
</ul>

<pre><code class="language-go">package main

import &quot;fmt&quot;

func main() {
	slice := []int{1, 2, 3, 4, 5}
	newSlice := slice[1:2:3]

	newSlice = append(newSlice, slice...)
	fmt.Println(newSlice)
	fmt.Println(slice)
}
</code></pre>

<p>因为<code>slice</code>切片的长度加上原来<code>newSlice</code>的长度以及超过了<code>slice</code>的长度，因此新的<code>newSlice</code>的底层数组不再和<code>slice</code>的底层数组一样。</p>

<p><strong>切片是3个字段构成的结构类型</strong></p>

<ul>
<li><p>切片在函数间传递是复制的。而我们修改一个索引的值后，发现原切片的值也被修改了，说明它们共用一个底层数组。如果在函数里面用append()方法使得容量增加，则不再共用底层数组</p></li>

<li><p>在函数间传递切片非常高效，而且不需要传递指针和处理复杂的语法，只需要复制切片，然后根据自己的业务修改，最后传递回一个新的切片副本即可，这也是为什么函数间传递参数，使用切片，而不是数组的原因。</p></li>

<li><p>引用类型有<code>切片</code>、<code>map</code>、<code>接口</code>、<code>函数</code>类型以及<code>chan</code></p></li>

<li><p>如果结构体里有引用类型的值，则即使传递的是结构体的副本，相应引用类型的值被改变时，原结构的也会被改变。</p></li>

<li><p>传入指针作为函数参数时<code>a[x] 是 (*a)[x] 的简写</code> 在Go语言里可以有这样的替换</p></li>

<li><p>方法的调用，既可以使用值，也可以使用指针，我们不必要严格的遵守这些，Go语言编译器会帮我们进行自动转义的，不过在返回<code>return</code>上要注意是返回一个值的副本，还是返回这个值本身的指针。</p></li>
</ul>

<h2 id="可变参数">可变参数</h2>

<pre><code class="language-go">func main() {
	print(&quot;132&quot;, &quot;2&quot;, &quot;3&quot;, 1)
}

func print(a ...string) {
	for _, v := range a {
		fmt.Print(v)
	}
	fmt.Println()
	for _, v := range a {
		fmt.Print(v)
	}
}
</code></pre>

<p><code>...</code>代表<code>a</code>这个变量是根据传入的参数(string)的个数来决定的，是个整体，上面的程序输出是</p>

<pre><code>13223
13223
</code></pre>

<ul>
<li>接口的值是一个两个字长度的数据结构，第一个字包含一个指向内部表结构的指针，这个内部表里存储的有实体类型的信息以及相关联的方法集；第二个字包含的是一个指向存储的实体类型值的指针。所以接口的值结构其实是两个指针，这也可以说明接口其实一个引用类型。</li>
</ul>

<pre><code>概念            |说明                                           
进程 	        |一个程序对应一个独立程序空间                       
线程 	        |一个执行空间，一个进程可以有多个线程                 
逻辑处理器       |执行创建的goroutine，绑定一个线程                 
调度器          |Go运行时中的，分配goroutine给不同的逻辑处理器    
全局运行队列     |所有刚创建的goroutine都会放到这里               
本地运行队列     |逻辑处理器的goroutine队列                       
</code></pre>

<ul>
<li><p>Pool用于存储那些被分配了但是没有被使用，而未来可能会使用的值，以减小垃圾回收的压力</p></li>

<li><p>数组是值传递</p></li>

<li><p>切片是指针传递</p></li>

<li><p>map是指针传递</p></li>

<li><p>通道是指针传递</p></li>

<li><p>方法、函数是指针传递</p></li>
</ul>

                        </div>

                        


                        

<div class="post-archive">
    <h2>See Also</h2>
    <ul class="listing">
        
        <li><a href="/archives/">归档</a></li>
        
    </ul>
</div>


                        <div class="post-meta meta-tags">
                            
                            <ul class="clearfix">
                                
                                <li><a href="https://wushaoqiang.github.io/tags/Beego">Beego</a></li>
                                
                                <li><a href="https://wushaoqiang.github.io/tags/Golang">Golang</a></li>
                                
                                <li><a href="https://wushaoqiang.github.io/tags/Gin">Gin</a></li>
                                
                            </ul>
                            
                        </div>
                    </article>
                    
    

    
    
    <div class="post bg-white">
      <script src="https://utteranc.es/client.js"
            repo= "wushaoqiang/blogcomment"
            issue-term="pathname"
            theme="github-light"
            crossorigin="anonymous"
            async>
      </script>
    </div>
    
                </div>
            </div>
            <div id="secondary">
    <section class="widget">
        <form id="search" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank" _lpchecked="1">
      
      <input type="text" name="q" maxlength="20" placeholder="Search">
      <input type="hidden" name="sitesearch" value="https://wushaoqiang.github.io">
      <button type="submit" class="submit icon-search"></button>
</form>
    </section>
    
    <section class="widget">
        <h3 class="widget-title">最近文章</h3>
<ul class="widget-list">
    
    <li>
        <a href="https://wushaoqiang.github.io/posts/golang-exercism/" title="Golang Exercism">Golang Exercism</a>
    </li>
    
    <li>
        <a href="https://wushaoqiang.github.io/posts/mysql-basic/" title="Mysql学习笔记">Mysql学习笔记</a>
    </li>
    
    <li>
        <a href="https://wushaoqiang.github.io/posts/golang-bible/" title="Go圣经读书笔记">Go圣经读书笔记</a>
    </li>
    
    <li>
        <a href="https://wushaoqiang.github.io/posts/golang-inaction/" title="Go语言实战">Go语言实战</a>
    </li>
    
    <li>
        <a href="https://wushaoqiang.github.io/posts/golang-highlevel/" title="Go语言高级编程">Go语言高级编程</a>
    </li>
    
    <li>
        <a href="https://wushaoqiang.github.io/posts/golang-leetcode/" title="Golang--Leetcode">Golang--Leetcode</a>
    </li>
    
    <li>
        <a href="https://wushaoqiang.github.io/posts/golangstd-unicode/" title="Golang标准库--Unicode">Golang标准库--Unicode</a>
    </li>
    
    <li>
        <a href="https://wushaoqiang.github.io/posts/golangstd-string/" title="Golang标准库--String">Golang标准库--String</a>
    </li>
    
    <li>
        <a href="https://wushaoqiang.github.io/posts/golangstd-bytes/" title="Golang标准库--Bytes">Golang标准库--Bytes</a>
    </li>
    
    <li>
        <a href="https://wushaoqiang.github.io/posts/golangstd-bufio/" title="Golang标准库--Bufio">Golang标准库--Bufio</a>
    </li>
    
</ul>
    </section>

    

    <section class="widget">
        <h3 class="widget-title">分类</h3>
<ul class="widget-list">
    
    <li>
        <a href="https://wushaoqiang.github.io/categories/Git/">Git(1)</a>
    </li>
    
    <li>
        <a href="https://wushaoqiang.github.io/categories/Golang/">Golang(11)</a>
    </li>
    
    <li>
        <a href="https://wushaoqiang.github.io/categories/Hugo/">Hugo(1)</a>
    </li>
    
    <li>
        <a href="https://wushaoqiang.github.io/categories/Linux/">Linux(1)</a>
    </li>
    
    <li>
        <a href="https://wushaoqiang.github.io/categories/Mysql/">Mysql(1)</a>
    </li>
    
    <li>
        <a href="https://wushaoqiang.github.io/categories/protocal/">protocal(1)</a>
    </li>
    
</ul>
    </section>

    <section class="widget">
        <h3 class="widget-title">标签</h3>
<div class="tagcloud">
    
    <a href="https://wushaoqiang.github.io/tags/Beego/">Beego</a>
    
    <a href="https://wushaoqiang.github.io/tags/Exercism/">Exercism</a>
    
    <a href="https://wushaoqiang.github.io/tags/Gin/">Gin</a>
    
    <a href="https://wushaoqiang.github.io/tags/Git/">Git</a>
    
    <a href="https://wushaoqiang.github.io/tags/Golang/">Golang</a>
    
    <a href="https://wushaoqiang.github.io/tags/Hugo/">Hugo</a>
    
    <a href="https://wushaoqiang.github.io/tags/LeetCode/">LeetCode</a>
    
    <a href="https://wushaoqiang.github.io/tags/Linux/">Linux</a>
    
    <a href="https://wushaoqiang.github.io/tags/Mysql/">Mysql</a>
    
    <a href="https://wushaoqiang.github.io/tags/Web/">Web</a>
    
    <a href="https://wushaoqiang.github.io/tags/protocal/">protocal</a>
    
    <a href="https://wushaoqiang.github.io/tags/%E5%9F%BA%E7%A1%80/">基础</a>
    
    <a href="https://wushaoqiang.github.io/tags/%E6%A0%87%E5%87%86%E5%BA%93/">标准库</a>
    
</div>
    </section>

    

    <section class="widget">
        <h3 class="widget-title">其它</h3>
        <ul class="widget-list">
            <li><a href="https://wushaoqiang.github.io/index.xml">文章 RSS</a></li>
        </ul>
    </section>
</div>
        </div>
    </div>
</div>
<footer id="footer">
    <div class="container">
        &copy; 2019 <a href="https://wushaoqiang.github.io">Gavin&#39;s Blog By Gavin</a>.
        Powered by <a rel="nofollow noreferer noopener" href="https://gohugo.io" target="_blank">Hugo</a>.
        <a href="https://www.flysnow.org/" target="_blank">Theme</a> based on <a href="https://github.com/rujews/maupassant-hugo" target="_blank">maupassant</a>.
        
    </div>
</footer>


    <script type="text/javascript">
    
    (function(){
        $("pre code").parent().addClass("line-numbers")
    }())

    window.MathJax = {
        tex2jax: {
            inlineMath: [ ['$','$'] ],
            processEscapes: true
        }
    };
    </script>
    <script type="text/javascript" src="/js/prism.js" async="true"></script>
    <script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML' async></script>

<a id="rocket" href="#top"></a>
<script type="text/javascript" src="/js/totop.js?v=0.0.0" async=""></script>



<script type="text/javascript" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script>




</body>
</html>
