<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Golang on Gavin&#39;s Blog</title>
    <link>https://wushaoqiang.github.io/tags/Golang/</link>
    <description>Recent content in Golang on Gavin&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 01 Apr 2019 15:12:46 +0800</lastBuildDate>
    
	<atom:link href="https://wushaoqiang.github.io/tags/Golang/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Golang Mega</title>
      <link>https://wushaoqiang.github.io/posts/golang-mega/</link>
      <pubDate>Mon, 01 Apr 2019 15:12:46 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/golang-mega/</guid>
      <description>不积跬步无以至千里，不积小流无以成江海
 本文是博主在学习基础记录的笔记
2019-04-01到2019-04-04，后面会自己DIY一些内容上去(想做成一个小小的技术论坛)
先来总体看一下整个项目的目录吧
. ├── cmd │ └── db_init │ └── main.go ├── config │ └── g.go ├── config.yml ├── controller │ ├── g.go │ ├── home.go │ ├── middle.go │ └── utils.go ├── main.go ├── model │ ├── g.go │ ├── post.go │ ├── user.go │ └── utils.go ├── templates │ ├── 404.html │ ├── _base.html │ ├── content │ │ ├── explore.html │ │ ├── index.</description>
    </item>
    
    <item>
      <title>Golang标准库--http</title>
      <link>https://wushaoqiang.github.io/posts/golangstd-net-http/</link>
      <pubDate>Tue, 19 Mar 2019 20:52:05 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/golangstd-net-http/</guid>
      <description>这篇文章是为了探索Golang中net/http包的实现，笔者暂时只会把主要脉络摸清，具体某些实现逻辑暂不考究，是一篇比较基础的源码阅读文章。
Package http doc.go 先来看看官方对这个包的一个解释
这里说到，这个包是为HTTP提供客户端和服务器端的实现的。
这里还举了一些方法的例子
// Copyright 2011 The Go Authors. All rights reserved. // Use of this source code is governed by a BSD-style // license that can be found in the LICENSE file. /* Package http provides HTTP client and server implementations. Get, Head, Post, and PostForm make HTTP (or HTTPS) requests: resp, err := http.Get(&amp;quot;http://example.com/&amp;quot;) ... resp, err := http.Post(&amp;quot;http://example.com/upload&amp;quot;, &amp;quot;image/jpeg&amp;quot;, &amp;amp;buf) ... resp, err := http.</description>
    </item>
    
    <item>
      <title>Golang Exercism</title>
      <link>https://wushaoqiang.github.io/posts/golang-exercism/</link>
      <pubDate>Sun, 17 Mar 2019 02:15:05 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/golang-exercism/</guid>
      <description>Exercism &amp;ndash; Bob 我的方法：(总之非常愚蠢就是了)
func Hey(remark string) string { // Write some code here to pass the test suite. // Then remove all the stock comments. // They&#39;re here to help you get started but they only clutter a finished solution. // If you leave them in, reviewers may protest! if strings.EqualFold(remark, &amp;quot;&amp;quot;) { return &amp;quot;Fine. Be that way!&amp;quot; } whitespace := true for _, item := range []byte(remark) { if !</description>
    </item>
    
    <item>
      <title>Go圣经读书笔记</title>
      <link>https://wushaoqiang.github.io/posts/golang-bible/</link>
      <pubDate>Sun, 17 Mar 2019 02:13:08 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/golang-bible/</guid>
      <description>第一章 入门 命令行参数 os.Args变量是一个字符串的切片，并且它的第一个元素是命令本身的名字
func main() { var s, sep string for i := 0; i &amp;lt; len(os.Args); i++ { s += sep + os.Args[i] sep = &amp;quot; &amp;quot; } fmt.Println(s) }  运行go run main.go 123
输出/tmp/go-build115927302/b001/exe/main 123
查找重复的行  input := bufio.NewScanner(os.stdin) ~ func NewScanner(r io.Reader) *Scanner  返回一个从r读取的Scanner
 func (s *Scanner) Scan() bool  逐行扫描，当scan停止的时候，或者是到了读取的终点，又或者是发生了错误，这里都会返回false
 func (s *Scanner) Text() string  返回scanner所在行的文本
counts := make(map[string]int) input := bufio.</description>
    </item>
    
    <item>
      <title>Go语言实战</title>
      <link>https://wushaoqiang.github.io/posts/golang-inaction/</link>
      <pubDate>Sun, 17 Mar 2019 02:11:56 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/golang-inaction/</guid>
      <description>Go语言优点：
 Go语言可以说是夹在C/C++和Python这两类语言之间，即提供了较高的性能，又使得开发更加迅速了。
 Go语言内置并发机制，对并发有着更好的性能
 Go语言自带垃圾回收器
 goroutine使用的内存比线程要少，所以常常能够成千上万个goroutine并发
  第六章 并发 概念  进程：当运行一个应用程序时，操作系统会为这个应用程序启动一个进程，可以将这个进程看作一个包含了应用程序在运行中需要用到和维护的各种资源 线程：一个线程是一个空间，这个空间会被操作系统调度来运行函数中所写的代码，线程会被调度到CPU上运行。 每个逻辑处理器绑定在一个线程上 逻辑处理器可以调度goroutine 并发：某一个事情的停止，另一个事情就开始(单线程) 并行：同时开始做(多线程)  goroutine 一个创建goroutine的示例 package main import ( &amp;quot;fmt&amp;quot; &amp;quot;runtime&amp;quot; &amp;quot;sync&amp;quot; ) // main is the entry point for all Go programs. func main() { // Allocate 1 logical processor for the scheduler to use. runtime.GOMAXPROCS(1) // wg is used to wait for the program to finish. // Add a count of two, one for each goroutine.</description>
    </item>
    
    <item>
      <title>Go语言高级编程</title>
      <link>https://wushaoqiang.github.io/posts/golang-highlevel/</link>
      <pubDate>Sun, 17 Mar 2019 02:09:45 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/golang-highlevel/</guid>
      <description>感谢 在文章开头感谢两位作者:柴树杉和曹春晖
这篇文章是开源的，欢迎大家去阅读
本篇博客是笔者对这篇文章的理解，引用的图片也是来自原文，如有侵权请告知！
第一章 基础 1.3 数组、字符串和切片  Go语言的数组是一种值类型，虽然数组的元素可以被修改，但是数组本身的赋值和函数传参都是以整体复制的方式处理的
 Go语言字符串底层数据也是对应的字节数组，但是字符串的只读属性禁止了在程序中对底层字节数组的元素的修改字符串赋值只是复制了数据地址和对应的长度，而不会导致底层数据的复制
 切片头含有底层数据的指针，所以它的赋值也不会导致底层数据的复制
  字符串  字符串的元素不可修改，是一个只读的字节数组
 字符串虽然不是切片，但是支持切片操作
type StringHeader struct { Data uintptr Len int }  字符串结构由两个信息组成：第一个是字符串指向的底层字节数组，第二个是字符串的字节的长度。
  切片 type SliceHeader struct { Data uintptr Len int Cap int }  a = append(a, 0) // 切片扩展1个空间 copy(a[i+1:], a[i:]) // a[i:]向后移动1个位置 a[i] = x // 设置新添加的元素  copy将a[i:]直接搬到了a[i+1:]这个时候就可以在a[i]插入
这种做法可以减少中间创建的临时切片
copy append可以完成切片的添加 删除 插入操作</description>
    </item>
    
    <item>
      <title>Golang--Leetcode</title>
      <link>https://wushaoqiang.github.io/posts/golang-leetcode/</link>
      <pubDate>Sun, 17 Mar 2019 02:07:37 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/golang-leetcode/</guid>
      <description>此文章为做题时发现的不足
 Go语言中的结构体直接赋值是==值传递==，如果要用引用传递，需要这样struct1 := &amp;amp;struct2，也就是要使用取地址符号。但是如果本来struct2就是一个指针，那么就可以直接赋值了。 go func addTwoNumbers(l1 *ListNode, l2 *ListNode) *ListNode { Head := ListNode{} curr := &amp;amp;Head  &amp;mdash;-  给定一个字符串，找出其中不含有重复字符的最长子串的长度方法 - 穷举法：
func lengthOfLongestSubstring(s string) int { var max = 0 for i := 0; i &amp;lt; len(s); i++ { m := make(map[string]bool) for j := i; j &amp;lt; len(s); j++ { if _, ok := m[s[j:j+1]]; !ok { m[s[j:j+1]] = true if j == len(s)-1 { if max &amp;lt; j-i+1 { max = j - i + 1 } } } else { if max &amp;lt; j-i { max = j - i } break } } } return max }   另一个方法： ```go func lengthOfLongestSubstring(s string) int { var max = 0 i := 0 m := make(map[string]int) for j := 0; j &amp;lt; len(s); j++ {  	if _, ok := m[s[j:j+1]]; ok {</description>
    </item>
    
    <item>
      <title>Golang标准库--Unicode</title>
      <link>https://wushaoqiang.github.io/posts/golangstd-unicode/</link>
      <pubDate>Sun, 17 Mar 2019 02:06:01 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/golangstd-unicode/</guid>
      <description>unicode package utf8 utf8.go 这里就不详细分析源码了，只说函数的作用
&amp;mdash; FullRune(p []byte) bool  FullRune报告p中的字节是否以一个rune的完整UTF-8编码开始。
 无效的编码被认为是完整的rune，因为它将转换为宽度为1的错误符文rune。
&amp;mdash; FullRuneInString(s string) bool 和FullRune一样，只是传入了字符串
&amp;mdash; DecodeRune(p []byte) (r rune, size int) 这个函数将切片p中第一个rune返回，并且返回这个rune的大小。
如果p是空的，那么会返回RuneError,0
如果切片中的编码是无效的，那么会返回RuneError,1,对应上一个函数，当编码无效时依然返回true
&amp;mdash; DecodeRuneInString(s string) (r rune, size int) 同上，只是参数变成了字符串
&amp;mdash; func DecodeLastRune(p []byte) (r rune, size int) 只是从后面开始了，功能一样。
&amp;mdash; DecodeLastRuneInString(s string) (r rune, size int) 如上，参数换了字符串
&amp;mdash; RuneLen(r rune) int 返回一个rune的长度，也就是其大小
&amp;mdash; EncodeRune(p []byte, r rune) int 这个就是将rune写入到byte切片上
&amp;mdash; RuneCount(p []byte) int 返回整个切片里面rune的个数</description>
    </item>
    
    <item>
      <title>Golang标准库--String</title>
      <link>https://wushaoqiang.github.io/posts/golangstd-string/</link>
      <pubDate>Sun, 17 Mar 2019 02:04:07 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/golangstd-string/</guid>
      <description>目录 strings builder.go Builder 结构体 noescape(p unsafe.Pointer) unsafe.Pointer &amp;amp; copyCheck() (b *Builder) String() string &amp;amp; (b *Builder) Len() int &amp;amp; (b *Builder) Reset() (b *Builder) Grow(n int) 关于Write的方法 reader.go Reader 结构体 (r *Reader) Len() int &amp;amp; (r *Reader) Size() int64 关于读的方法 (r *Reader) UnreadRune() error (r *Reader) Seek(offset int64, whence int) (int64, error) strings.go  strings builder.go Builder 相当于bytes里面的buffer，并且方法也差不多。但是buffer更加全面
&amp;mdash; 结构体 // A Builder is used to efficiently build a string using Write methods.</description>
    </item>
    
    <item>
      <title>Golang标准库--Bytes</title>
      <link>https://wushaoqiang.github.io/posts/golangstd-bytes/</link>
      <pubDate>Sun, 17 Mar 2019 02:03:03 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/golangstd-bytes/</guid>
      <description>目录 bytes buffer.go Buffer 结构体 const of readOp (b *Buffer) Bytes() []byte (b *Buffer) String() string (b *Buffer) empty() bool (b *Buffer) Len() int (b *Buffer) Cap() int (b *Buffer) Truncate(n int) (b *Buffer) Reset() (b *Buffer) tryGrowByReslice(n int) (int, bool) (b *Buffer) grow(n int) int (b *Buffer) Grow(n int) (b *Buffer) Write(p []byte) (n int, err error) (b *Buffer) WriteString(s string) (n int, err error) makeSlice(n int) []byte (b *Buffer) WriteTo(w io.</description>
    </item>
    
    <item>
      <title>Golang标准库--Bufio</title>
      <link>https://wushaoqiang.github.io/posts/golangstd-bufio/</link>
      <pubDate>Sun, 17 Mar 2019 01:59:52 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/golangstd-bufio/</guid>
      <description>目录 bufio bufio.go 常量 Reader 结构体 常量 NewReaderSize(rd io.Reader, size int) *Reader NewReader(rd io.Reader) *Reader (r *Reader) Size() int (b *Reader) Reset(r io.Reader) &amp;amp; (b *Reader) reset(buf []byte, r io.Reader) (b *Reader) fill() (b *Reader) Peek(n int) ([]byte, error) (b *Reader) Discard(n int) (discarded int, err error) (b *Reader) Read(p []byte) (n int, err error) (b *Reader) ReadByte() (byte, error) (b *Reader) UnreadByte() (b *Reader) ReadRune() (r rune, size int, err error) (b *Reader) UnreadRune() error (b *Reader) Buffered() int (b *Reader) ReadSlice(delim byte) (line []byte, err error) (b *Reader) ReadLine() (line []byte, isPrefix bool, err error) (b *Reader) ReadBytes(delim byte) ([]byte, error) (b *Reader) ReadString(delim byte) (string, error) (b *Reader) WriteTo(w io.</description>
    </item>
    
    <item>
      <title>Web框架</title>
      <link>https://wushaoqiang.github.io/posts/web-strcuture/</link>
      <pubDate>Sun, 17 Mar 2019 01:53:57 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/web-strcuture/</guid>
      <description>这篇文章是参考人世间博主写的一篇文章，这里哪里作为自己了解Gin框架的例子，笔者想在这做初步了解后再去深入了解源码，到时候再写一篇博客来说说Gin源码。
Gin 路由常用方法 func (group *RouterGroup) POST(relativePath string, handlers ...HandlerFunc) IRoutes func (group *RouterGroup) GET(relativePath string, handlers ...HandlerFunc) IRoutes type HandlerFunc func(*Context)  可以看出路由需要的参数是
 相对路径
 处理函数
  这里面是Gin自己定义的一个HandlerFunc，和标准库里面的有所不同，这里的gin.*Context包含了标准库里的ResponseWriter和*http.Request还有一些其它
介绍一些函数 // Query()	是匹配url上的参数，匹配不到就返回空字符串 // DefaultQuery() 也是匹配，如果匹配不到就用默认值 // 127.0.0.1:8000/post?id=111&amp;amp;page=222 // 如果用curl，则需要在&amp;amp;前面加\ id := c.Query(&amp;quot;id&amp;quot;) page := c.DefaultQuery(&amp;quot;page&amp;quot;, &amp;quot;0&amp;quot;) //这个是在表单上获取信息，通过POST方法发送过来的数据 name := c.PostForm(&amp;quot;name&amp;quot;) message := c.PostForm(&amp;quot;message&amp;quot;)  一个完整的路由 router.GET(&amp;quot;/welcome&amp;quot;, func(c *gin.Context) { firstname := c.DefaultQuery(&amp;quot;firstname&amp;quot;, &amp;quot;Guest&amp;quot;) lastname := c.Query(&amp;quot;lastname&amp;quot;) c.</description>
    </item>
    
    <item>
      <title>Hugo建博客</title>
      <link>https://wushaoqiang.github.io/posts/learn-hugo/</link>
      <pubDate>Sat, 16 Mar 2019 22:33:20 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/learn-hugo/</guid>
      <description>笔者用的是Hugo来搭建个人博客，表示Hugo实在太强，而且可扩展性很高，这也代表文档也很长。。。
所以笔者收录一些比较常用的作为笔记，也希望能够帮到别人
以下命令都是以我自己建博客的为例
创建一个网站 hugo new site blog 这个命令会在目录里创建一个新的blog目录
这个blog目录包含以下：
 archetypes/ content/ data/ layouts/ static/ themes/ config.toml  archetypes/ 这里一开始会有一个default文件，后面再讲有什么用，先看看文件
--- title: &amp;quot;{{ replace .Name &amp;quot;-&amp;quot; &amp;quot; &amp;quot; | title }}&amp;quot; date: {{ .Date }} draft: true ---  content/ 这里就是博客的主要内容的根目录，我们创建的博客文章就应该放在这个文件夹里(不是直接)
创建一个博客文章hugo new posts/learn-hugo.md，创建完后会发现文件在content/posts/learn-hugo.md
打开文件看一下，可以发现创建的新文件里面是有内容的
--- title: &amp;quot;Learn Hugo&amp;quot; date: 2019-03-16T22:33:20+08:00 draft: true ---  这就和我们上面说到的archetypes/default.md有关，这里可以自动填充一些信息，方便我们写博客
theme/ 这里是放置博客主题的文件夹，Hugo有很多开源的主题，可以去官网找找看，笔者用的是飞雪无情这位博主开源出来的Maupassant，笔者刚开始也按照这位博主的配置方法来配置博客，等后面对Hugo的配置了解更加深入时，再尝试配置。Maupassant的仓库地址，大家还可以顺手点个星，表示支持
具体如何安装也很简单，可以参照github的使用方法
config.toml 这个文件是配置我们的一些博客信息以及Hugo的配置
## 这个是我们主页的地址 baseURL = &amp;quot;https://wushaoqiang.github.io&amp;quot; languageCode = &amp;quot;en-us&amp;quot; ## 博客的标题(不是某篇文章，是整个博客) title = &amp;quot;Gavin&#39;s Blog&amp;quot; ## 这里就是设定你要的主题，而且主题必须要下载到theme/目录 theme = &amp;quot;maupassant&amp;quot; ## 保持分类的原始名字（false会做转小写处理） preserveTaxonomyNames = true ## 是否禁止URL Path转小写 disablePathToLower = true ## 这个会配置每一篇文章最后面的Copyright的作者名字 ## © 2019 Gavin&#39;s Blog By Gavin [author] name = &amp;quot;Gavin&amp;quot; [params] author = &amp;quot;Gavin&amp;quot; ## 这是一个副标题，在主标题的下方 subtitle = &amp;quot;Gopher，后端开发，网络基础，WEB协议、架构、存储、缓冲、安全，学习笔记&amp;quot; keywords = &amp;quot;Golang,Gavin,Blog&amp;quot; ## 这个是对阅读量的计数 busuanzi = true ## 这个是为了开评论区 [params.</description>
    </item>
    
    <item>
      <title>Go琐碎笔记</title>
      <link>https://wushaoqiang.github.io/posts/learningGo/</link>
      <pubDate>Thu, 14 Mar 2019 16:10:59 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/learningGo/</guid>
      <description>在test文件要是以_test.go结尾，或者是在文件开头加上// +build (tag) 其中tag是自己定的，然后测试的时候在Terminal输入
2019.2.16 go test -tags tagname
构造数组可以先 make([]int,0)
然后 再使用函数：func append(slice []Type, elems ...Type) []Type
unicode.IsLetter(r rune) bool是判断是否为字母，而不是ASCII
res, ok := map[...] 中的ok变量可以用来判断key是否存在
[]rune可以直接转换为字符串string([]rune)
2019.2.17 谨记！ ： 切片和Map在函数传递都是指针传递(引用)
func normalize(cleartext string) string { var b strings.Builder for _, r := range cleartext { if unicode.IsLetter(r) || unicode.IsDigit(r) { b.WriteRune(unicode.ToLower(r)) } } return b.String() }  b.WriteRune(unicode.ToLower(r)) :可以用这种方式代替append()
norm = fmt.Sprintf(&amp;quot;%-[1]*s&amp;quot;, c*r, norm): 其实就是将出c*r代入到[1]*形成的在右侧填充空格
|类型 |默认值 | |int | 0 | |string|“” | | bool | false |  定义一个常量：const name type = value value是必须要有的 枚举：Go没有枚举，用const构造，有两种方法(参考这里的)</description>
    </item>
    
  </channel>
</rss>