<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Leetcode on Gavin&#39;s Blog</title>
    <link>https://wushaoqiang.github.io/tags/Leetcode/</link>
    <description>Recent content in Leetcode on Gavin&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sat, 27 Apr 2019 23:13:54 +0800</lastBuildDate>
    
	<atom:link href="https://wushaoqiang.github.io/tags/Leetcode/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Leetcode 108</title>
      <link>https://wushaoqiang.github.io/posts/leetcode-108/</link>
      <pubDate>Sat, 27 Apr 2019 23:13:54 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/leetcode-108/</guid>
      <description>题目 Given an array where elements are sorted in ascending order, convert it to a height balanced BST. For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1. Example: Given the sorted array: [-10,-3,0,5,9], One possible answer is: [0,-3,9,-10,null,5], which represents the following height balanced BST: 0 / \ -3 9 / / -10 5  我的解答 func sortedArrayToBST(nums []int) *TreeNode { if len(nums) == 0 { return nil } mid := (len(nums) - 1) / 2 head := &amp;amp;TreeNode{Val: nums[mid]} heightHalancedTree(head, nums, 0, mid-1) heightHalancedTree(head, nums, mid+1, len(nums)-1) return head } func heightHalancedTree(t *TreeNode, nums []int, left, right int) { if left &amp;lt;= right { mid := (left + right) / 2 // fmt.</description>
    </item>
    
    <item>
      <title>Leetcode 107</title>
      <link>https://wushaoqiang.github.io/posts/leetcode-107/</link>
      <pubDate>Sat, 27 Apr 2019 21:36:47 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/leetcode-107/</guid>
      <description>题目 Given a binary tree, return the bottom-up level order traversal of its nodes&#39; values. (ie, from left to right, level by level from leaf to root). For example: Given binary tree [3,9,20,null,null,15,7], 3 / \ 9 20 / \ 15 7 return its bottom-up level order traversal as: [ [15,7], [9,20], [3] ]  我的解答 没做出来
最优解答 func levelOrderBottom(root *TreeNode) [][]int { var ret [][]int if root == nil { return nil } que := []*TreeNode{root} for len(que) &amp;gt; 0 { len := len(que) var level []int for i := 0; i &amp;lt; len; i++ { node := que[0] que = que[1:] level = append(level, node.</description>
    </item>
    
    <item>
      <title>Leetcode 104</title>
      <link>https://wushaoqiang.github.io/posts/leetcode-104/</link>
      <pubDate>Sat, 27 Apr 2019 21:36:42 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/leetcode-104/</guid>
      <description>题目 Given a binary tree, find its maximum depth. The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node. Note: A leaf is a node with no children. Example: Given binary tree [3,9,20,null,null,15,7], 3 / \ 9 20 / \ 15 7 return its depth = 3.  我的解答 func maxDepth(root *TreeNode) int { if root == nil { return 0 } if root.</description>
    </item>
    
    <item>
      <title>Leetcode 101</title>
      <link>https://wushaoqiang.github.io/posts/leetcode-101/</link>
      <pubDate>Sat, 27 Apr 2019 21:36:39 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/leetcode-101/</guid>
      <description>题目 Given a binary tree, check whether it is a mirror of itself (ie, symmetric around its center). For example, this binary tree [1,2,2,3,4,4,3] is symmetric: 1 / \ 2 2 / \ / \ 3 4 4 3 But the following [1,2,2,null,3,null,3] is not: 1 / \ 2 2 \ \ 3 3 Note: Bonus points if you could solve it both recursively and iteratively.  我的解答 这题做的比较蠢，没有任何参考价值，就不放了</description>
    </item>
    
    <item>
      <title>Leetcode 100</title>
      <link>https://wushaoqiang.github.io/posts/leetcode-100/</link>
      <pubDate>Sat, 27 Apr 2019 21:36:35 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/leetcode-100/</guid>
      <description>题目 Given two binary trees, write a function to check if they are the same or not. Two binary trees are considered the same if they are structurally identical and the nodes have the same value. Example 1: Input: 1 1 / \ / \ 2 3 2 3 [1,2,3], [1,2,3] Output: true Example 2: Input: 1 1 / \ 2 2 [1,2], [1,null,2] Output: false Example 3: Input: 1 1 / \ / \ 2 1 1 2 [1,2,1], [1,1,2] Output: false  我的解答 /** * Definition for a binary tree node.</description>
    </item>
    
    <item>
      <title>Leetcode 88</title>
      <link>https://wushaoqiang.github.io/posts/leetcode-88/</link>
      <pubDate>Sat, 27 Apr 2019 21:33:45 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/leetcode-88/</guid>
      <description>题目 Given two sorted integer arrays nums1 and nums2, merge nums2 into nums1 as one sorted array. Note: The number of elements initialized in nums1 and nums2 are m and n respectively. You may assume that nums1 has enough space (size that is greater or equal to m + n) to hold additional elements from nums2. Example: Input: nums1 = [1,2,3,0,0,0], m = 3 nums2 = [2,5,6], n = 3 Output: [1,2,2,3,5,6]  我的解答 func merge(nums1 []int, m int, nums2 []int, n int) { for m &amp;gt; 0 &amp;amp;&amp;amp; n &amp;gt; 0 { if nums1[m-1] &amp;gt;= nums2[n-1] { nums1[n+m-1] = nums1[m-1] m-- } else { nums1[n+m-1] = nums2[n-1] n-- } } if m == 0 { for n &amp;gt; 0 { nums1[n-1] = nums2[n-1] n-- } return } }  解法思路是归并排序，这相当于归并排序的最后一步了</description>
    </item>
    
    <item>
      <title>Leetcode 83</title>
      <link>https://wushaoqiang.github.io/posts/leetcode-83/</link>
      <pubDate>Tue, 23 Apr 2019 22:21:39 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/leetcode-83/</guid>
      <description>题目 给定一个排序链表，删除所有重复的元素，使得每个元素只出现一次。 示例 1: 输入: 1-&amp;gt;1-&amp;gt;2 输出: 1-&amp;gt;2 示例 2: 输入: 1-&amp;gt;1-&amp;gt;2-&amp;gt;3-&amp;gt;3 输出: 1-&amp;gt;2-&amp;gt;3  我的解答 type ListNode struct { Val int Next *ListNode } func deleteDuplicates(head *ListNode) *ListNode { c := head for c != nil { if c.Next == nil { return head } if c.Val == c.Next.Val { c.Next = c.Next.Next } else { c = c.Next } } return head }  因为是个排序的链表，因此只要前后对比，再根据指针的指向来改变链表
最优解答 /** * Definition for singly-linked list.</description>
    </item>
    
    <item>
      <title>Leetcode 70</title>
      <link>https://wushaoqiang.github.io/posts/leetcode-70/</link>
      <pubDate>Tue, 23 Apr 2019 22:21:35 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/leetcode-70/</guid>
      <description>题目 假设你正在爬楼梯。需要 n 阶你才能到达楼顶。 每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？ 注意：给定 n 是一个正整数。 示例 1： 输入： 2 输出： 2 解释： 有两种方法可以爬到楼顶。 1. 1 阶 + 1 阶 2. 2 阶 示例 2： 输入： 3 输出： 3 解释： 有三种方法可以爬到楼顶。 1. 1 阶 + 1 阶 + 1 阶 2. 1 阶 + 2 阶 3. 2 阶 + 1 阶  我的解答 func climbStairs(n int) int { if n == 1 || n == 2 { return n } count2 := n / 2 result := 0 for ; count2 &amp;gt;= 0; count2-- { result += calc(n-count2, count2) } return result } //注意float的运算可能会出现一些.</description>
    </item>
    
    <item>
      <title>Leetcode 69</title>
      <link>https://wushaoqiang.github.io/posts/leetcode-69/</link>
      <pubDate>Tue, 23 Apr 2019 22:21:31 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/leetcode-69/</guid>
      <description>题目 实现 int sqrt(int x) 函数。 计算并返回 x 的平方根，其中 x 是非负整数。 由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。 示例 1: 输入: 4 输出: 2 示例 2: 输入: 8 输出: 2 说明: 8 的平方根是 2.82842..., 由于返回类型是整数，小数部分将被舍去。  我的解答 func mySqrt(x int) int { return int(math.Floor(math.Sqrt(float64(x)))) }  向下取整
最优解答 func mySqrt(x int) int { if x == 0 || x == 1 { return x } i := x / 2.0 for i*i &amp;gt; x { i = (i + x/i) / 2 } return i }  数学公式</description>
    </item>
    
    <item>
      <title>Leetcode 67</title>
      <link>https://wushaoqiang.github.io/posts/leetcode-67/</link>
      <pubDate>Tue, 23 Apr 2019 22:21:26 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/leetcode-67/</guid>
      <description>题目 给定两个二进制字符串，返回他们的和（用二进制表示）。 输入为非空字符串且只包含数字 1 和 0。 示例 1: 输入: a = &amp;quot;11&amp;quot;, b = &amp;quot;1&amp;quot; 输出: &amp;quot;100&amp;quot; 示例 2: 输入: a = &amp;quot;1010&amp;quot;, b = &amp;quot;1011&amp;quot; 输出: &amp;quot;10101&amp;quot;  我的解答 func addBinary(a string, b string) string { lengthLonger, lengthShorter := 0, 0 tmp := &amp;quot;&amp;quot; if len(a) &amp;gt; len(b) { lengthLonger = len(a) lengthShorter = len(b) } else { lengthLonger = len(b) lengthShorter = len(a) tmp = b b = a a = tmp } resultArray := make([]int, lengthLonger+1) carry := 0 for i := lengthLonger; i &amp;gt;= 0; i-- { if i &amp;gt; (lengthLonger - lengthShorter) { currentA, _ := strconv.</description>
    </item>
    
    <item>
      <title>Leetcode 66</title>
      <link>https://wushaoqiang.github.io/posts/leetcode-66/</link>
      <pubDate>Tue, 23 Apr 2019 22:21:23 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/leetcode-66/</guid>
      <description>题目 给定一个由整数组成的非空数组所表示的非负整数，在该数的基础上加一。 最高位数字存放在数组的首位， 数组中每个元素只存储一个数字。 你可以假设除了整数 0 之外，这个整数不会以零开头。 示例 1: 输入: [1,2,3] 输出: [1,2,4] 解释: 输入数组表示数字 123。 示例 2: 输入: [4,3,2,1] 输出: [4,3,2,2] 解释: 输入数组表示数字 4321。  我的解答 func plusOne(digits []int) []int { for i := len(digits) - 1; i &amp;gt;= 0; i-- { if digits[i] != 9 { digits[i]++ return digits } digits[i] = 0 } digits = append([]int{1}, digits...) return digits }  比较简单
最优解答 无
难疑点&amp;amp;核心 无</description>
    </item>
    
    <item>
      <title>Leetcode 58</title>
      <link>https://wushaoqiang.github.io/posts/leetcode-58/</link>
      <pubDate>Tue, 23 Apr 2019 22:21:19 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/leetcode-58/</guid>
      <description> 题目 给定一个仅包含大小写字母和空格 &#39; &#39; 的字符串，返回其最后一个单词的长度。 如果不存在最后一个单词，请返回 0 。 说明：一个单词是指由字母组成，但不包含任何空格的字符串。 示例: 输入: &amp;quot;Hello World&amp;quot; 输出: 5  我的解答 func lengthOfLastWord(s string) int { if s == &amp;quot;&amp;quot; { return 0 } if !strings.Contains(s, &amp;quot; &amp;quot;) { return len(s) } s = strings.TrimSpace(s) lastSpaceIndex := strings.LastIndex(s, &amp;quot; &amp;quot;) return len(s) - lastSpaceIndex - 1 }  前面两个判断是为了能够快速判断简单情况
要注意去掉头尾的空格，不然索引查找会出错
这里也调用了标准库，可能在算法上不算合规
最优解答 无
难疑点&amp;amp;核心  容易把头尾的空格忽略掉  </description>
    </item>
    
    <item>
      <title>Leetcode 53</title>
      <link>https://wushaoqiang.github.io/posts/leetcode-53/</link>
      <pubDate>Tue, 23 Apr 2019 22:21:16 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/leetcode-53/</guid>
      <description>题目 给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。 示例: 输入: [-2,1,-3,4,-1,2,1,-5,4], 输出: 6 解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。 进阶: 如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的分治法求解。  我的解答 func maxSubArray(nums []int) int { if len(nums) == 0 { return 0 } if len(nums) == 1 { return nums[0] } total := nums[0] max := nums[0] for i := 1; i &amp;lt; len(nums); i++ { if total &amp;lt; 0 { total = 0 } total += nums[i] if max &amp;lt; total { max = total } } return max }  暴力法的话，时间复杂度是O(N^2)，这里使用的方法时间复杂度O(N)</description>
    </item>
    
    <item>
      <title>Leetcode 35</title>
      <link>https://wushaoqiang.github.io/posts/leetcode-35/</link>
      <pubDate>Tue, 23 Apr 2019 22:21:07 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/leetcode-35/</guid>
      <description>题目 给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。 你可以假设数组中无重复元素。 示例 1: 输入: [1,3,5,6], 5 输出: 2 示例 2: 输入: [1,3,5,6], 2 输出: 1 示例 3: 输入: [1,3,5,6], 7 输出: 4 示例 4: 输入: [1,3,5,6], 0 输出: 0  我的解答 func searchInsert(nums []int, target int) int { isFound, idx := binarySearch(nums, 0, len(nums)-1, target) if isFound { return idx } if nums[idx] &amp;gt; target { return idx } else { return idx + 1 } } func binarySearch(nums []int, left, right, target int) (found bool, idx int) { if left &amp;lt; right { mid := (left + right) / 2 if nums[mid] == target { return true, mid } else if nums[mid] &amp;gt; target { return binarySearch(nums, left, mid-1, target) } else { return binarySearch(nums, mid+1, right, target) } } else if nums[left] == target { return true, left } else { return false, left } }  因为是个有序的数组，因此可以不用暴力搜索，这里使用比较简单的二分法，找到索引(就算没有相等的，也找到最后一个查找的索引)</description>
    </item>
    
    <item>
      <title>Leetcode 28</title>
      <link>https://wushaoqiang.github.io/posts/leetcode-28/</link>
      <pubDate>Tue, 23 Apr 2019 22:21:04 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/leetcode-28/</guid>
      <description>题目 实现 strStr() 函数。 给定一个 haystack 字符串和一个 needle 字符串，在 haystack 字符串中找出 needle 字符串出现的第一个位置 (从0开始)。如果不存在，则返回 -1。 示例 1: 输入: haystack = &amp;quot;hello&amp;quot;, needle = &amp;quot;ll&amp;quot; 输出: 2 示例 2: 输入: haystack = &amp;quot;aaaaa&amp;quot;, needle = &amp;quot;bba&amp;quot; 输出: -1 说明: 当 needle 是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。 对于本题而言，当 needle 是空字符串时我们应当返回 0 。这与C语言的 strstr() 以及 Java的 indexOf() 定义相符。  我的解答 func strStr(haystack string, needle string) int { return strings.Index(haystack, needle) }  这里可能有点赖皮，直接调用了标准库，看网上说还有一种KMP的算法，比较难，按笔者现在的进度，先刷60简单题吧，后面再考虑实现。
当然还有暴力算法，但是我宁愿使用标准库吧
最优解答 无</description>
    </item>
    
    <item>
      <title>Leetcode 27</title>
      <link>https://wushaoqiang.github.io/posts/leetcode-27/</link>
      <pubDate>Tue, 23 Apr 2019 22:21:01 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/leetcode-27/</guid>
      <description>题目 给定一个数组 nums 和一个值 val，你需要原地移除所有数值等于 val 的元素，返回移除后数组的新长度。 不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。 元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。 示例 1: 给定 nums = [3,2,2,3], val = 3, 函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。 你不需要考虑数组中超出新长度后面的元素。 示例 2: 给定 nums = [0,1,2,2,3,0,4,2], val = 2, 函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。 注意这五个元素可为任意顺序。 你不需要考虑数组中超出新长度后面的元素。 说明: 为什么返回数值是整数，但输出的答案是数组呢? 请注意，输入数组是以“引用”方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。 你可以想象内部操作如下: // nums 是以“引用”方式传递的。也就是说，不对实参作任何拷贝 int len = removeElement(nums, val); // 在函数里修改输入数组对于调用者是可见的。 // 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。 for (int i = 0; i &amp;lt; len; i++) { print(nums[i]); }  我的解答 func removeElement(nums []int, val int) int { if len(nums) == 0 { return 0 } i := 0 j := len(nums) - 1 for i &amp;lt; j { if nums[i] == val { nums[i] = nums[j] j-- } else { i++ } } if nums[i] == val { return j } return j+1 }  因为题目说只需要给索引就可以了，因此不需要创建新的内存存放，只需要用一个索引将符合要求的值和不符合要求的值划分开(所以要交换它们位置)</description>
    </item>
    
    <item>
      <title>Leetcode 26</title>
      <link>https://wushaoqiang.github.io/posts/leetcode-26/</link>
      <pubDate>Tue, 23 Apr 2019 22:20:55 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/leetcode-26/</guid>
      <description>题目 给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。 不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。 示例 1: 给定数组 nums = [1,1,2], 函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 你不需要考虑数组中超出新长度后面的元素。 示例 2: 给定 nums = [0,0,1,1,1,2,2,3,3,4], 函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。 你不需要考虑数组中超出新长度后面的元素。 说明: 为什么返回数值是整数，但输出的答案是数组呢? 请注意，输入数组是以“引用”方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。 你可以想象内部操作如下: // nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝 int len = removeDuplicates(nums); // 在函数里修改输入数组对于调用者是可见的。 // 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。 for (int i = 0; i &amp;lt; len; i++) { print(nums[i]); }  我的解答 func removeDuplicates(nums []int) int { if len(nums) == 0 || len(nums) == 1 { return len(nums) } count := 0 existMap := make(map[int]bool) for _, num := range nums { if _, exist := existMap[num]; !</description>
    </item>
    
    <item>
      <title>Leetcode 21</title>
      <link>https://wushaoqiang.github.io/posts/leetcode-21/</link>
      <pubDate>Tue, 23 Apr 2019 22:20:50 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/leetcode-21/</guid>
      <description>题目 将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 示例： 输入：1-&amp;gt;2-&amp;gt;4, 1-&amp;gt;3-&amp;gt;4 输出：1-&amp;gt;1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;4  我的解答 /** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode { l4 := &amp;amp;ListNode{} l3 := &amp;amp;ListNode{} l4.Next = l3 for l1 != nil || l2 != nil { if l1 == nil { return l2 } if l2 == nil { return l1 } if l1.</description>
    </item>
    
    <item>
      <title>Leetcode 20</title>
      <link>https://wushaoqiang.github.io/posts/leetcode-20/</link>
      <pubDate>Mon, 22 Apr 2019 00:46:01 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/leetcode-20/</guid>
      <description>题目 给定一个只包括 &#39;(&#39;，&#39;)&#39;，&#39;{&#39;，&#39;}&#39;，&#39;[&#39;，&#39;]&#39; 的字符串，判断字符串是否有效。 有效字符串需满足： 左括号必须用相同类型的右括号闭合。 左括号必须以正确的顺序闭合。 注意空字符串可被认为是有效字符串。 示例 1: 输入: &amp;quot;()&amp;quot; 输出: true 示例 2: 输入: &amp;quot;()[]{}&amp;quot; 输出: true 示例 3: 输入: &amp;quot;(]&amp;quot; 输出: false 示例 4: 输入: &amp;quot;([)]&amp;quot; 输出: false 示例 5: 输入: &amp;quot;{[]}&amp;quot; 输出: true  我的解答 笔者在做这道题的时候想的稍微复杂了点，用了递归的方法做，但速度什么的非常慢，所以不值得参考，只能说一路摸坑吧
var ( relation = map[string]string{&amp;quot;(&amp;quot;: &amp;quot;)&amp;quot;, &amp;quot;[&amp;quot;: &amp;quot;]&amp;quot;, &amp;quot;{&amp;quot;: &amp;quot;}&amp;quot;} ) func isValid(s string) bool { if len(s) == 0 { return true } if (len(s)+2)%2 != 0 { return false } if len(s) == 2 { return string(s[1]) == relation[string(s[0])] } // l := len(s) for { idx := getLastIndex(s) if idx == -1 { return false } if !</description>
    </item>
    
    <item>
      <title>Leetcode 14</title>
      <link>https://wushaoqiang.github.io/posts/leetcode-14/</link>
      <pubDate>Mon, 22 Apr 2019 00:45:56 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/leetcode-14/</guid>
      <description>题目 编写一个函数来查找字符串数组中的最长公共前缀。 如果不存在公共前缀，返回空字符串 &amp;quot;&amp;quot;。 示例 1: 输入: [&amp;quot;flower&amp;quot;,&amp;quot;flow&amp;quot;,&amp;quot;flight&amp;quot;] 输出: &amp;quot;fl&amp;quot; 示例 2: 输入: [&amp;quot;dog&amp;quot;,&amp;quot;racecar&amp;quot;,&amp;quot;car&amp;quot;] 输出: &amp;quot;&amp;quot; 解释: 输入不存在公共前缀。 说明: 所有输入只包含小写字母 a-z 。  我的解答 func longestCommonPrefix(strs []string) string { if len(strs) == 0 { return &amp;quot;&amp;quot; } if len(strs) == 1 { return strs[0] } shortestLen := len(strs[0]) for _, str := range strs { if len(str) &amp;lt; shortestLen { shortestLen = len(str) } } var finalStr string for i := 0; i &amp;lt; shortestLen; i++ { tmp := strs[0][i] for j := 1; j &amp;lt; len(strs); j++ { if tmp !</description>
    </item>
    
    <item>
      <title>Leetcode 13</title>
      <link>https://wushaoqiang.github.io/posts/leetcode-13/</link>
      <pubDate>Mon, 22 Apr 2019 00:45:53 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/leetcode-13/</guid>
      <description>题目 罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。 字符 数值 I 1 V 5 X 10 L 50 C 100 D 500 M 1000 例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做 XXVII, 即为 XX + V + II 。 通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况： I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。 X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。 给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。 示例 1: 输入: &amp;quot;III&amp;quot; 输出: 3 示例 2: 输入: &amp;quot;IV&amp;quot; 输出: 4 示例 3: 输入: &amp;quot;IX&amp;quot; 输出: 9 示例 4: 输入: &amp;quot;LVIII&amp;quot; 输出: 58 解释: L = 50, V= 5, III = 3.</description>
    </item>
    
    <item>
      <title>Leetcode 9</title>
      <link>https://wushaoqiang.github.io/posts/leetcode-9/</link>
      <pubDate>Mon, 22 Apr 2019 00:45:41 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/leetcode-9/</guid>
      <description>题目 判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。 示例 1: 输入: 121 输出: true 示例 2: 输入: -121 输出: false 解释: 从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。 示例 3: 输入: 10 输出: false 解释: 从右向左读, 为 01 。因此它不是一个回文数。 进阶: 你能不将整数转为字符串来解决这个问题吗？  我的解答 func isPalindrome(x int) bool { str := strconv.Itoa(x) for i := 0; i &amp;lt; len(str)/2; i++ { if str[i] != str[len(str)-1-i] { return false } } return true }  转换为字符串进行比较就简单很多了,直接头尾比较，时间复杂度为O(N/2),N为字符串长度</description>
    </item>
    
    <item>
      <title>Leetcode 1</title>
      <link>https://wushaoqiang.github.io/posts/leetcode-1/</link>
      <pubDate>Mon, 22 Apr 2019 00:19:11 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/leetcode-1/</guid>
      <description>题目 给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。
你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。
示例:
给定 nums = [2, 7, 11, 15], target = 9 因为 nums[0] + nums[1] = 2 + 7 = 9 所以返回 [0, 1]  我的解答 func twoSum(nums []int, target int) []int { myMap := make(map[int]int) for idx,num := range nums{ myMap[num] = idx } for idx,num := range nums{ tmp := target - num if pos,exist := myMap[tmp]; exist{ if idx &amp;gt; pos{ return []int{pos,idx} } else if idx &amp;lt; pos{ return []int{idx,pos} }else{ continue } } } return nil }  方法是通过map来达到快速查找，而不像暴力法需要每次都遍历整个数组</description>
    </item>
    
    <item>
      <title>Leetcode 7</title>
      <link>https://wushaoqiang.github.io/posts/leetcode-7/</link>
      <pubDate>Mon, 22 Apr 2019 00:19:11 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/leetcode-7/</guid>
      <description>题目 给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。 示例 1: 输入: 123 输出: 321 示例 2: 输入: -123 输出: -321 示例 3: 输入: 120 输出: 21 注意: 假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为 [−2^31, 2^31 − 1]。请根据这个假设，如果反转后整数溢出那么就返回 0。  我的解答 func reverse(x int) int { var rev int for x != 0 { lastNum := x % 10 x = x / 10 if rev &amp;gt; math.MaxInt32/10 || rev == math.MaxInt32/10 &amp;amp;&amp;amp; lastNum &amp;gt; 7 { return 0 } if rev &amp;lt; math.</description>
    </item>
    
    <item>
      <title>Leetcode 开篇</title>
      <link>https://wushaoqiang.github.io/posts/leetcode-before-start/</link>
      <pubDate>Mon, 22 Apr 2019 00:00:37 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/leetcode-before-start/</guid>
      <description> 不积跬步无以至千里，不积小流无以成江海
 作为Leetcode的开篇作，在这里希望自己能够坚持每天code一两道题(视难度而定)
以后博客应该是以这样的方式呈现
### 题目 ### 我的解答 ### 最优解答 ### 难疑点&amp;amp;核心  </description>
    </item>
    
  </channel>
</rss>