<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Array on Gavin&#39;s Blog</title>
    <link>https://wushaoqiang.github.io/tags/Array/</link>
    <description>Recent content in Array on Gavin&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 27 May 2019 21:44:51 +0800</lastBuildDate>
    
	<atom:link href="https://wushaoqiang.github.io/tags/Array/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Leetcode 561</title>
      <link>https://wushaoqiang.github.io/posts/leetcode/leetcode-561/</link>
      <pubDate>Mon, 27 May 2019 21:44:51 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/leetcode/leetcode-561/</guid>
      <description>题目  Given an array of 2n integers, your task is to group these integers into n pairs of integer, say (a1, b1), (a2, b2), ..., (an, bn) which makes sum of min(ai, bi) for all i from 1 to n as large as possible. Example 1: Input: [1,4,3,2] Output: 4 Explanation: n is 2, and the maximum sum of pairs is 4 = min(1, 2) + min(3, 4). Note: n is a positive integer, which is in the range of [1, 10000].</description>
    </item>
    
    <item>
      <title>Leetcode 532</title>
      <link>https://wushaoqiang.github.io/posts/leetcode/leetcode-532/</link>
      <pubDate>Mon, 27 May 2019 21:07:29 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/leetcode/leetcode-532/</guid>
      <description>题目  Given an array of integers and an integer k, you need to find the number of unique k-diff pairs in the array. Here a k-diff pair is defined as an integer pair (i, j), where i and j are both numbers in the array and their absolute difference is k. Example 1: Input: [3, 1, 4, 1, 5], k = 2 Output: 2 Explanation: There are two 2-diff pairs in the array, (1, 3) and (3, 5).</description>
    </item>
    
    <item>
      <title>Leetcode 509</title>
      <link>https://wushaoqiang.github.io/posts/leetcode/leetcode-509/</link>
      <pubDate>Mon, 27 May 2019 20:52:42 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/leetcode/leetcode-509/</guid>
      <description>题目 The Fibonacci numbers, commonly denoted F(n) form a sequence, called the Fibonacci sequence, such that each number is the sum of the two preceding ones, starting from 0 and 1. That is, F(0) = 0, F(1) = 1 F(N) = F(N - 1) + F(N - 2), for N &amp;gt; 1. Given N, calculate F(N). Example 1: Input: 2 Output: 1 Explanation: F(2) = F(1) + F(0) = 1 + 0 = 1.</description>
    </item>
    
    <item>
      <title>Leetcode 485</title>
      <link>https://wushaoqiang.github.io/posts/leetcode/leetcode-485/</link>
      <pubDate>Mon, 27 May 2019 20:21:40 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/leetcode/leetcode-485/</guid>
      <description>题目 Given a binary array, find the maximum number of consecutive 1s in this array. Example 1: Input: [1,1,0,1,1,1] Output: 3 Explanation: The first two digits or the last three digits are consecutive 1s. The maximum number of consecutive 1s is 3. Note: The input array will only contain 0 and 1. The length of input array is a positive integer and will not exceed 10,000  我的解答 // Runtime: 36 ms, faster than 96.</description>
    </item>
    
    <item>
      <title>Leetcode 448</title>
      <link>https://wushaoqiang.github.io/posts/leetcode/leetcode-448/</link>
      <pubDate>Mon, 27 May 2019 20:17:08 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/leetcode/leetcode-448/</guid>
      <description>题目 Given an array of integers where 1 ≤ a[i] ≤ n (n = size of array), some elements appear twice and others appear once. Find all the elements of [1, n] inclusive that do not appear in this array. Could you do it without extra space and in O(n) runtime? You may assume the returned list does not count as extra space. Example: Input: [4,3,2,7,8,2,3,1] Output: [5,6]  我的解答 func findDisappearedNumbers(nums []int) []int { for i := 0; i &amp;lt; len(nums); i++ { if nums[abs(nums[i])-1] &amp;gt; 0 { nums[abs(nums[i])-1] *= -1 } } res := make([]int, 0) for i := 0; i &amp;lt; len(nums); i++ { if nums[i] &amp;gt; 0 { res = append(res, i+1) } } return res } func abs(x int) int { if x &amp;lt; 0 { return -x } return x }  因为数的范围不会超过长度，因此可以用数来表示索引，如果数存在，那么相对应大小的索引置-1(因为数组里面不会有负数，所以可以用来区分)</description>
    </item>
    
  </channel>
</rss>