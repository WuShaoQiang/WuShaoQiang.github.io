<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Array on Gavin&#39;s Blog</title>
    <link>https://wushaoqiang.github.io/tags/Array/</link>
    <description>Recent content in Array on Gavin&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 29 May 2019 23:03:57 +0800</lastBuildDate>
    
	<atom:link href="https://wushaoqiang.github.io/tags/Array/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Leetcode 628</title>
      <link>https://wushaoqiang.github.io/posts/leetcode/leetcode-628/</link>
      <pubDate>Wed, 29 May 2019 23:03:57 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/leetcode/leetcode-628/</guid>
      <description>题目 Given an integer array, find three numbers whose product is maximum and output the maximum product. Example 1: Input: [1,2,3] Output: 6 Example 2: Input: [1,2,3,4] Output: 24 Note: The length of the given array will be in range [3,104] and all elements are in the range [-1000, 1000]. Multiplication of any three numbers in the input won&#39;t exceed the range of 32-bit signed integer.  我的解答 // Runtime: 36 ms, faster than 99.</description>
    </item>
    
    <item>
      <title>Leetcode 605</title>
      <link>https://wushaoqiang.github.io/posts/leetcode/leetcode-605/</link>
      <pubDate>Wed, 29 May 2019 22:03:37 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/leetcode/leetcode-605/</guid>
      <description>题目 Suppose you have a long flowerbed in which some of the plots are planted and some are not. However, flowers cannot be planted in adjacent plots - they would compete for water and both would die. Given a flowerbed (represented as an array containing 0 and 1, where 0 means empty and 1 means not empty), and a number n, return if n new flowers can be planted in it without violating the no-adjacent-flowers rule.</description>
    </item>
    
    <item>
      <title>Leetcode 581</title>
      <link>https://wushaoqiang.github.io/posts/leetcode/leetcode-581/</link>
      <pubDate>Wed, 29 May 2019 20:33:58 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/leetcode/leetcode-581/</guid>
      <description>题目 Given an integer array, you need to find one continuous subarray that if you only sort this subarray in ascending order, then the whole array will be sorted in ascending order, too. You need to find the shortest such subarray and output its length. Example 1: Input: [2, 6, 4, 8, 10, 9, 15] Output: 5 Explanation: You need to sort [6, 4, 8, 10, 9] in ascending order to make the whole array sorted in ascending order.</description>
    </item>
    
    <item>
      <title>Leetcode 566</title>
      <link>https://wushaoqiang.github.io/posts/leetcode/leetcode-566/</link>
      <pubDate>Wed, 29 May 2019 20:28:21 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/leetcode/leetcode-566/</guid>
      <description>题目 In MATLAB, there is a very useful function called &#39;reshape&#39;, which can reshape a matrix into a new one with different size but keep its original data. You&#39;re given a matrix represented by a two-dimensional array, and two positive integers r and c representing the row number and column number of the wanted reshaped matrix, respectively. The reshaped matrix need to be filled with all the elements of the original matrix in the same row-traversing order as they were.</description>
    </item>
    
    <item>
      <title>Leetcode 561</title>
      <link>https://wushaoqiang.github.io/posts/leetcode/leetcode-561/</link>
      <pubDate>Mon, 27 May 2019 21:44:51 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/leetcode/leetcode-561/</guid>
      <description>题目  Given an array of 2n integers, your task is to group these integers into n pairs of integer, say (a1, b1), (a2, b2), ..., (an, bn) which makes sum of min(ai, bi) for all i from 1 to n as large as possible. Example 1: Input: [1,4,3,2] Output: 4 Explanation: n is 2, and the maximum sum of pairs is 4 = min(1, 2) + min(3, 4). Note: n is a positive integer, which is in the range of [1, 10000].</description>
    </item>
    
    <item>
      <title>Leetcode 532</title>
      <link>https://wushaoqiang.github.io/posts/leetcode/leetcode-532/</link>
      <pubDate>Mon, 27 May 2019 21:07:29 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/leetcode/leetcode-532/</guid>
      <description>题目  Given an array of integers and an integer k, you need to find the number of unique k-diff pairs in the array. Here a k-diff pair is defined as an integer pair (i, j), where i and j are both numbers in the array and their absolute difference is k. Example 1: Input: [3, 1, 4, 1, 5], k = 2 Output: 2 Explanation: There are two 2-diff pairs in the array, (1, 3) and (3, 5).</description>
    </item>
    
    <item>
      <title>Leetcode 509</title>
      <link>https://wushaoqiang.github.io/posts/leetcode/leetcode-509/</link>
      <pubDate>Mon, 27 May 2019 20:52:42 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/leetcode/leetcode-509/</guid>
      <description>题目 The Fibonacci numbers, commonly denoted F(n) form a sequence, called the Fibonacci sequence, such that each number is the sum of the two preceding ones, starting from 0 and 1. That is, F(0) = 0, F(1) = 1 F(N) = F(N - 1) + F(N - 2), for N &amp;gt; 1. Given N, calculate F(N). Example 1: Input: 2 Output: 1 Explanation: F(2) = F(1) + F(0) = 1 + 0 = 1.</description>
    </item>
    
    <item>
      <title>Leetcode 485</title>
      <link>https://wushaoqiang.github.io/posts/leetcode/leetcode-485/</link>
      <pubDate>Mon, 27 May 2019 20:21:40 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/leetcode/leetcode-485/</guid>
      <description>题目 Given a binary array, find the maximum number of consecutive 1s in this array. Example 1: Input: [1,1,0,1,1,1] Output: 3 Explanation: The first two digits or the last three digits are consecutive 1s. The maximum number of consecutive 1s is 3. Note: The input array will only contain 0 and 1. The length of input array is a positive integer and will not exceed 10,000  我的解答 // Runtime: 36 ms, faster than 96.</description>
    </item>
    
    <item>
      <title>Leetcode 448</title>
      <link>https://wushaoqiang.github.io/posts/leetcode/leetcode-448/</link>
      <pubDate>Mon, 27 May 2019 20:17:08 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/leetcode/leetcode-448/</guid>
      <description>题目 Given an array of integers where 1 ≤ a[i] ≤ n (n = size of array), some elements appear twice and others appear once. Find all the elements of [1, n] inclusive that do not appear in this array. Could you do it without extra space and in O(n) runtime? You may assume the returned list does not count as extra space. Example: Input: [4,3,2,7,8,2,3,1] Output: [5,6]  我的解答 func findDisappearedNumbers(nums []int) []int { for i := 0; i &amp;lt; len(nums); i++ { if nums[abs(nums[i])-1] &amp;gt; 0 { nums[abs(nums[i])-1] *= -1 } } res := make([]int, 0) for i := 0; i &amp;lt; len(nums); i++ { if nums[i] &amp;gt; 0 { res = append(res, i+1) } } return res } func abs(x int) int { if x &amp;lt; 0 { return -x } return x }  因为数的范围不会超过长度，因此可以用数来表示索引，如果数存在，那么相对应大小的索引置-1(因为数组里面不会有负数，所以可以用来区分)</description>
    </item>
    
  </channel>
</rss>