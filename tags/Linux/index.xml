<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Linux on Gavin&#39;s Blog</title>
    <link>https://wushaoqiang.github.io/tags/Linux/</link>
    <description>Recent content in Linux on Gavin&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sat, 20 Jul 2019 21:12:36 +0800</lastBuildDate>
    
	<atom:link href="https://wushaoqiang.github.io/tags/Linux/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Linux Link</title>
      <link>https://wushaoqiang.github.io/posts/linux/linux-link/</link>
      <pubDate>Sat, 20 Jul 2019 21:12:36 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/linux/linux-link/</guid>
      <description>We have already talked about disk management, now we have a pretty simple topic&amp;ndash;link
Link is one of the file types in linux including hard link and symbol link
Let&amp;rsquo;s get into them
hard link Remember inode?
when we type ls -l, the second field is the inode number which means how many file(s) is using the same inode.
Right, hard link file is using the same inode, and inode including the file information like permission, block number.</description>
    </item>
    
    <item>
      <title>Linux Disk Manage</title>
      <link>https://wushaoqiang.github.io/posts/linux/linux-disk-manage/</link>
      <pubDate>Sat, 20 Jul 2019 16:20:50 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/linux/linux-disk-manage/</guid>
      <description>Now, let&amp;rsquo;s get into the disk management of linux
Concept There are some concepts you should know about linux file system
Why we need to operate format before OS can use it?
Because different Operate System may use different file system, like FAT, NTFS, Ext2 etc.
After we know there are so many different file system, let&amp;rsquo;s talk about linux file system.
Here are some concepts:
 superblock: superblock will store file system information(like inode number, block number, etc.</description>
    </item>
    
    <item>
      <title>Linux Search File</title>
      <link>https://wushaoqiang.github.io/posts/linux/linux-search-file/</link>
      <pubDate>Sat, 20 Jul 2019 15:14:46 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/linux/linux-search-file/</guid>
      <description>Last time, I shared about how to read file content, and the most useful command
Today, I will make a little cover about searching file
which I do use a lot which to find binary file
which ls //output /bin/ls  It is a simple command to help us searching the binary file
locate locate is a powerful search command which is using database searching
locate filename //search included filename locate -i filename //ignore case locate -r regexp //use regular expression to search  As we can see the commands above there, we can also do any search with it</description>
    </item>
    
    <item>
      <title>Linux Read File</title>
      <link>https://wushaoqiang.github.io/posts/linux/linux-read-file/</link>
      <pubDate>Sat, 20 Jul 2019 14:31:21 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/linux/linux-read-file/</guid>
      <description>Last time, I talked about how to operate file like copy, move or remove
Today, let&amp;rsquo;s see how many ways do we have to read file content, I will introduce some basic and useful commands
cat cat filename will print all the content at once, so it is helpful when you just simply want to print the file content
cat -n filename // show the line number  but if the file is large(like 100M+), you may not want to use this.</description>
    </item>
    
    <item>
      <title>Linux File System Basic Command</title>
      <link>https://wushaoqiang.github.io/posts/linux/linux-file-system-basic-command/</link>
      <pubDate>Sat, 20 Jul 2019 11:39:18 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/linux/linux-file-system-basic-command/</guid>
      <description>Basic Command Last time, I shared about permission
Today the topic is Basic Command of File System
I am gonna give you some simple command you can use in your daily working situation
cd //enter a directory pwd //show the work directory(Print Working Directory)  mkdir
mkdir -m // set directory permission when create mkdir -p // If parent directory doesn&#39;t exist, it will help you create when you add -p flag  rmdir</description>
    </item>
    
    <item>
      <title>Linux Permission</title>
      <link>https://wushaoqiang.github.io/posts/linux/linux-permission/</link>
      <pubDate>Sat, 20 Jul 2019 10:31:23 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/linux/linux-permission/</guid>
      <description>Today, I am gonna talk about linux permission which is very basic for linux user.
Basically, we have three different role in linux
Owner Group Other  It is easy to understand what they mean.
ls -al In your home directory, type ls -al command and click Enter, you will see the output like:
-rw------- 1 user group 254 Oct 22 2018 .xsession-errors.old  Fields meaning As we can see, this line include several field separated by white space</description>
    </item>
    
    <item>
      <title>Linux Ps</title>
      <link>https://wushaoqiang.github.io/posts/linux/linux-ps/</link>
      <pubDate>Sun, 14 Jul 2019 22:11:55 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/linux/linux-ps/</guid>
      <description> ps命令有几种标准，这里只用UNIX版本的
Background 首先了解一些概念
 PID 进程ID
 PPID 父进程ID
 PGID 进程所在GroupID
 SID 进程所在会话(Session)ID
  一般来说，SID就是我们的shell
一个SID管理多个PGID
一个PGID管理很多PID
既然是管理，那就会有leader角色，那么如何知道谁是leader
PID == PGID的就是group leader
PID == SID的就是session leader
Flag Selection
-A -e 全部进程 -a 全部进程处理session leader -C 命令名字 -g group -u user -p pid -t tty  Format
-o pid,ppid,tty,time 选择输出某些字段 -F 全部字段(带字段名字 -f不带字段名字) --forest 树状形式输出  </description>
    </item>
    
    <item>
      <title>Linux Bash Awk</title>
      <link>https://wushaoqiang.github.io/posts/linux/linux-bash-awk/</link>
      <pubDate>Sun, 09 Jun 2019 22:44:43 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/linux/linux-bash-awk/</guid>
      <description>awk的一些用法
常见模式 awk &#39;/reg/&#39; &#39;BEGIN{} condition {condition action} END{}&#39; filename  其中
 /reg/ 是一个正则的匹配
 condition 是判断条件
 action 就是要执行的操作
 BEGIN 开始前的操作
 END 结束后的操作
  对文件 awk &#39;{print $1}&#39; test.txt  对管道 df -h | awk &#39;{print $1}&#39;  这里面的$1是指第一部分，默认分隔符是空格(制表符)
echo &amp;quot;This is a test&amp;quot; | awk &#39;{print $1}&#39;  输出的是This
如果想要的分隔符不是默认的，可以使用-F
例如
echo &amp;quot;This,is,a,test&amp;quot; | awk &#39;{print $1}&#39; #输出 This,is,a,test echo &amp;quot;This,is,a,test&amp;quot; | awk -F &#39;,&#39; &#39;{print $1}&#39; #输出 This  更多高级的用法 先说说内置的变量</description>
    </item>
    
    <item>
      <title>Linux Bash Test</title>
      <link>https://wushaoqiang.github.io/posts/linux/linux-bash-test/</link>
      <pubDate>Sun, 09 Jun 2019 21:51:11 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/linux/linux-bash-test/</guid>
      <description> test命令是bash中一个重要的判断命令
虽然我们在其它编程语言上习惯使用if判断语句去实施判断，但也有必要了解一下这一种的判断手段
if + test if test -e ./test.txt; then echo &amp;quot;exist&amp;quot;; fi  [ ] 因为上面那种结合if条件判断的和原有的差不多，所以我们一般常用的是[]
例子
[ -e ./test.txt ] &amp;amp;&amp;amp; echo &amp;quot;exist&amp;quot; || echo &amp;quot;doesn&#39;t exist&amp;quot;  这里就是存在就会输出exist，不存在就会输出后面的那个
而且这还适用于
 文件类型判断
 文件权限
 两文件之间
 整数之间
 字符串之间
 多重条件(也就是AND和OR还有NOT)
  </description>
    </item>
    
    <item>
      <title>Linux Bash Basic Note</title>
      <link>https://wushaoqiang.github.io/posts/linux/linux-bash-basic-note/</link>
      <pubDate>Sun, 09 Jun 2019 18:55:28 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/linux/linux-bash-basic-note/</guid>
      <description>记录一些笔记
参考 https://www.jianshu.com/p/e1c8e5bfa45e
变量 注意变量赋值别加空格
变量命名只能用字母、数字和下划线，且数字不能在开头
 readonly 只读变量，用法和read类似
 unset 可以删除变量，但不可删除只读变量
  本质上来说，bash里面都是字符串，只有当变量是纯数字的时候才是所谓的数字类型
局部和全局 这里要特别注意，普通变量默认是全局变量
所以要想在函数中定义局部变量，需要加local声明
local var1  环境变量 这个就和linux上的一些环境是一样的
特殊变量 $0 当前脚本的文件名 $1,$2... 传递给脚本或函数的参数,按顺序的 $# 传递给脚本或函数的参数个数 $* 传递给脚本或函数的所有参数 $? 上个命令的退出状态，或函数的返回值 $$ 当前Shell进程ID  转义字符 echo默认是不转移字符的，但printf是会转义的
转义字符的含义和其它编程语言基本一样
命令替换 我们可以将命令的输出存储起来
比如存储一个日期
date=`date`  注意，这个是反引号
运算符 shell脚本的运算符好像和其它编程语言有很大的差异，它主要是用flag形式
关于数字的 -eq -ne -gt -lt -ge -le  关于布尔值 ! not -o or -a and  所以像其它编程语言可能会用 &amp;amp;&amp;amp; || 这些符号
关于字符串 == !</description>
    </item>
    
    <item>
      <title>Linux Bash</title>
      <link>https://wushaoqiang.github.io/posts/linux/linux-bash/</link>
      <pubDate>Sun, 09 Jun 2019 15:56:26 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/linux/linux-bash/</guid>
      <description>给自己定的一些规范 因为shell的语法太灵活，有许多语法是不唯一的，导致我很纠结，下面结合他人的实战经历，规定自己一套规范，以后写shell尽量按照这样的规范来
用printf函数，在format-string上加引号 给所有变量加上花括号 ${VAR} 运算符尽量使用flag形式(字符串不能用这个形式) 判断只用[]  需要特别注意的一些点 关于字符串 单引号‘’会原样输出字符串，对里面的变量引用都是没用的，转义字符也没用 双引号可以引用变量和转义字符  初学例子
开头指定解释器
#!/bin/bash  这里记一些用过的语法
取奇数
for i in {1.99..2} do echo $i done  读取stdin
read name echo &amp;quot;Welcome $name&amp;quot;  读取并输出运算后结果
read x read y echo $((x+y)) echo $((x-y)) echo $((x*y)) echo $((x/y))  读取并比较
read X read Y if (($X&amp;gt;$Y)); then echo &amp;quot;X is greater than Y&amp;quot;; elif (($X&amp;lt;$Y)); then echo &amp;quot;X is less than Y&amp;quot;; else echo &amp;quot;X is equal to Y&amp;quot;; fi  字符串的比较</description>
    </item>
    
    <item>
      <title>Ubuntu apt</title>
      <link>https://wushaoqiang.github.io/posts/linux/linux-apt/</link>
      <pubDate>Tue, 07 May 2019 11:00:18 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/linux/linux-apt/</guid>
      <description> 这个总结一下我经常用到的关于apt的命令
apt vs apt-get 这个问题其实也在一开始困扰了我很久，网上有人使用apt，有人使用apt-get，那到底用哪个？
其实apt的后来推出的版本，越来越多人已经被它对人阅读的友好给征服了，apt-get输出的信息给人看起来比较不友好
因此对于新入门的来说，建议使用apt
当然，apt-get并没有被遗弃，也有很多人在用
常用命令 更新仓库 sudo apt update 更新本地可更新的 sudo apt upgrade 一键更新 sudo apt update &amp;amp;&amp;amp; sudo apt upgrade -y 安装，如果pkg本身就已经安装，这个就是更新操作了 sudo apt install &amp;lt;pkg&amp;gt; 如果安装的包存在，不要更新，如果不存在，就安装 sudo apt install &amp;lt;pkg&amp;gt; --no-upgrade 如果包存在就更新，不存在也不安装 sudo apt install &amp;lt;pkg&amp;gt; --only-upgrade 指定版本安装 sudo apt install &amp;lt;pkg&amp;gt;=&amp;lt;version&amp;gt; 删除(不包括配置文件) sudo apt remove &amp;lt;pkg&amp;gt; 彻底删除(包括配置文件) sudo apt purge &amp;lt;pkg&amp;gt; 显示出这个term所有的package apt search &amp;lt;term&amp;gt; 这个可以显示pkg详细信息 apt show &amp;lt;pkg&amp;gt; 显示已安装的pkg apt list --installed 自动清除(清除那些没有用的pkg) sudo apt autoremove  </description>
    </item>
    
    <item>
      <title>Linux 网络管理</title>
      <link>https://wushaoqiang.github.io/posts/linux/linux-network-management/</link>
      <pubDate>Thu, 25 Apr 2019 20:29:02 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/linux/linux-network-management/</guid>
      <description>ping -c 发送一定数量的报文
ifconfig 其中输出信息里
enp0s31f6：以太网(有线)
lo：回传
wlp4s0：无线网
tcpdump 这是一个类似wireshark抓包的命令,需要权限
-c：指定抓取包的数量
-i：指定接口(上面说到有3个接口)
port：指定端口
netstat -r：显示路由
-i：显示接口
-n：显示IP
-t：tcp
-u：udp</description>
    </item>
    
    <item>
      <title>Linux 进程管理</title>
      <link>https://wushaoqiang.github.io/posts/linux/linux-process-management/</link>
      <pubDate>Thu, 25 Apr 2019 17:04:19 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/linux/linux-process-management/</guid>
      <description>进程状态  R 正在运行或在运行队列
 D 不可中断，进程不会因为信号被唤醒，只能等待中断发生
 S 中断，等待某个事件完成或者被信号唤醒
 Z 僵死，进程已经终止但其父进程没有用wait()或在waitpid()来释放它
 T 停止，可能是收到控制信号，也可能是被跟踪
  相关命令 ps,pstree,top(htop),jobs,kill，nice，nohup
Crtl+c:终结进程
Ctrl+z:暂停进程
ps(Process Status) ps 只会给当前终端中运行的进程
ps -a Select all processes except both session leaders (see getsid(2)) and processes not associated with a terminal.
ps -u root显示root用户的process，这里root也可以是别的用户名
ps -l 相对ps，会显示父PID等信息
ps aux 显示所有process
ps -ef 详细显示所有process
pstree pstree 进程树
pstree -p 显示PID
pstree (username) 显示用户的进程
jobs jobs 查看后台运行的进程
fg %num 将后台程序转移到前台</description>
    </item>
    
    <item>
      <title>Linux命令笔记</title>
      <link>https://wushaoqiang.github.io/posts/linux/linux-note/</link>
      <pubDate>Sun, 17 Mar 2019 01:52:15 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/linux/linux-note/</guid>
      <description>Command 这里只是笔者对Linux常用命令的笔记，方便自己查询
ifconfig 查看网络连接
lsof -i:8000 查看端口8000占用情况
kill -9 PID 把某个PID的进程结束了，kill还有许多flag，1:挂起， 2:中断 ，3:退出
mkdir -p /1/2/3/4 可以一次创建多层文件夹
pkill -f &amp;lt;name&amp;gt; 可以直接kill掉一个已知名字的进程
把脚本放进/etc/init.d/里面就可以自启动
chown user:group &amp;lt;file&amp;gt; 改变文件持有
磁盘 du -hsc &amp;lt;path&amp;gt; 查看路径占用磁盘大小
ncdu 更友好的查看磁盘占用情况的一个命令，需要安装
df -h查看磁盘占用情况
别名 alias &amp;lt;name&amp;gt;=&amp;quot;&amp;lt;command&amp;gt;&amp;quot; 用别名调用命令(适用于长命令)，如果需要持久化的话，需要写入.bashrc
查找文件 find &amp;lt;path&amp;gt; -name &amp;quot;*.log&amp;quot; 寻找在路径里面结尾为.log的文件，同理，想要查找一类文件可以用这个命令
find &amp;lt;path&amp;gt; ! -name &amp;quot;*.log&amp;quot; 与上面刚好相反
find -mtime &amp;lt;number&amp;gt;这个命令还可以根据修改时间
匹配 grep -r &amp;quot;error&amp;quot; &amp;lt;path or file&amp;gt; 会打印出所有含有error的字段
查看CPU&amp;amp;内存占用情况 top 这个命令对界面不太友好
htop 这个对阅读更加友好
update 能够看到电脑持续开机时间</description>
    </item>
    
  </channel>
</rss>