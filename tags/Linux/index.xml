<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Linux on Gavin&#39;s Blog</title>
    <link>https://wushaoqiang.github.io/tags/Linux/</link>
    <description>Recent content in Linux on Gavin&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 24 Oct 2019 20:08:00 +0800</lastBuildDate>
    
	<atom:link href="https://wushaoqiang.github.io/tags/Linux/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Linux Process do_fork</title>
      <link>https://wushaoqiang.github.io/posts/linux/linux-process-dofork/</link>
      <pubDate>Thu, 24 Oct 2019 20:08:00 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/linux/linux-process-dofork/</guid>
      <description>上一篇说fork、clone的时候，可以看到它们都是调用了do_fork，这也很好的解释了为什么这两个系统调用如此相似了，也解释了很多我们平时听过的结论(不再赘述)
do_fork大致流程 do_fork的大致代码如下
/* * Ok, this is the main fork-routine. * * It copies the process, and if successful kick-starts * it and waits for it to finish using the VM if required. */ long do_fork(unsigned long clone_flags, unsigned long stack_start, struct pt_regs *regs, unsigned long stack_size, int __user *parent_tidptr, int __user *child_tidptr) { struct task_struct *p; int trace = 0; long nr; /* * Do some preliminary argument and permissions checking before we * actually start allocating stuff */ // 这里是一些clone_flag的检查 if (clone_flags &amp;amp; CLONE_NEWUSER) { if (clone_flags &amp;amp; CLONE_THREAD) return -EINVAL; /* hopefully this check will go away when userns support is * complete */ if (!</description>
    </item>
    
    <item>
      <title>Linux Process Fork&amp;Clone</title>
      <link>https://wushaoqiang.github.io/posts/linux/linux-process-fork/</link>
      <pubDate>Thu, 24 Oct 2019 19:24:30 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/linux/linux-process-fork/</guid>
      <description>简单的fork 之前也有大致介绍过fork，简单来说就是&amp;rdquo;复制&amp;rdquo;一个task_struct，其实系统调用的sys_fork比较简单
int sys_fork(struct pt_regs *regs) { return do_fork(SIGCHLD, regs-&amp;gt;sp, regs, 0, NULL, NULL); }  我们可以看到，主要是do_fork的逻辑，在这里传入了SIGCHLD表明子进程终止后发送SIGCHLD信号通知父进程
像sys_vfork和sys_clone其实都是调用了do_fork，区别大多在于传入的标志位(flag)不同
int sys_vfork(struct pt_regs *regs) { return do_fork(CLONE_VFORK | CLONE_VM | SIGCHLD, regs-&amp;gt;sp, regs, 0, NULL, NULL); }  可以看到是多了一些flag在sys_vfork调用的参数上
do_fork /* * Ok, this is the main fork-routine. * * It copies the process, and if successful kick-starts * it and waits for it to finish using the VM if required. */ long do_fork(unsigned long clone_flags, unsigned long stack_start, struct pt_regs *regs, unsigned long stack_size, int __user *parent_tidptr, int __user *child_tidptr)  我们可以简单的理解这些参数的意义</description>
    </item>
    
    <item>
      <title>Linux Process Identifier</title>
      <link>https://wushaoqiang.github.io/posts/linux/linux-process-identifier/</link>
      <pubDate>Wed, 23 Oct 2019 20:11:58 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/linux/linux-process-identifier/</guid>
      <description>接触Linux系统也有一年时间了，大部分接触过Linux系统的人也都清除Linux依靠各种ID来实现区分
这里面包括
 PID
 SID
 PGID(Process Group ID)，值为进程组组长的PID
 TGID(Thread Group ID)，如果是单线程，则与PID一样
  初学者也能知道，PID是进程的唯一标识(Identifier)，再结合之前说的Namespace，我们应该换一种说法PID是某个Namespace下的进程唯一标识
引入了Namespace之后，我们对ID会有两种
 Global ID
 Local ID
  其实它们也类似，只是Global ID是boot的时候的第一个Namespace，因此我们叫它做整个系统的Namespace，Global也因此得名
Local ID就是不同的Namespace下面的ID，也非常好理解
task struct 在task struct里面，有
1278 pid_t pid; 1279 pid_t tgid;  其中pid_t一般是32bit的int，因此可以包含足够的ID
但这里面没有pgid以及sid，这些是存储在了signal字段里面
PID不仅仅是数字 在我们大部分人的认知下，PID就是一个整数，用来标识进程
但是在Linux下，需要维护PID之间的关系，比如所处的Namespace
Linux下的PID Namespace 在Linux下的PID Namespace是有层级关系的，init所处的global PID Namespace是处于第0级，要创建新的PID Namespace就会在其父进程的Namespace的等级里加一
也就是说Namespace level低的能够看到Namespace level高的，反过来则不行。这带来的结果就是，一个进程(Namespace.level &amp;gt; 0)会在不同层级的Namespace上有该层级的唯一PID，所以一个进程有多个PID，分别在不同的Namespace
这也告诉我们一个事情：一个进程的创建需要在每一个Namespace里面新建一个PID，赋值到进程结构体上
struct pid_namespace { struct kref kref; struct task_struct *child_reaper; unsigned int level; struct pid_namespace *parent; .</description>
    </item>
    
    <item>
      <title>Linux Namespace</title>
      <link>https://wushaoqiang.github.io/posts/linux/linux-namespace/</link>
      <pubDate>Tue, 22 Oct 2019 21:35:47 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/linux/linux-namespace/</guid>
      <description>Namespace是我最近一两个月才听到的词，但是它其实在早就已经出现，今天就来记录一下我对它的一些浅显的理解
在一般情况下，我们都是以一个全局的角度来看整个linux系统。Namespace的存在使得我们能够换一个角度来看系统的全局属性
在Linux系统中，许多资源都是全局管理的，如PID，UID等。这也是必须的
在如今虚拟化和容器化的博弈中，容器化依靠自身的一些资源利用的优势，取得了不错的市场。其依赖的技术之中就有Namespace。我们来简单比较一下这两者的区别
 虚拟化就是在一台物理机上布置多个虚拟机，每一个虚拟机就像是一台独立的物理机，它拥有完整的内核，完整的系统。所以即使在Windows上，也能够运行Linux的虚拟机(因为内核在虚拟机上)。但也是因为如此，每一个虚拟机都需要有一个完整的操作系统，占用的资源会比较多
 容器化是一个特殊的进程，因此在资源上，它并不需要和虚拟机一样的资源，因为进程都是执行在当前的内核上的。这个进程特殊在哪里呢，它通过Namespace来使得这个进程所看到的系统视觉不一样。比如这个进程本身是PID为10000，但是因为设置了新的Namespace，那么它自己会认为自己的PID为1(因为这是第一个进程，像init进程一样)。因为容器这个进程也还是运行在同一个内核上的，因此并不能像虚拟机一样，将Linux跑在Windows上
  在这里只是简单的说一下，我们可以通过这个例子来发现Namespace在现在的技术上是很火热的
所有的资源都可以通过Namespace抽象出来，使得进程所看到的系统是不同的
创建方法 因为我们在创建进程的时候，通过fork或者clone，这里是有标志位能够表明创建的进程是否和父进程保持一样的Namespace，还是新建一个Namespace
这些标志位比如有 
#define CLONE_NEWUTS // new uts namespace #define CLONE_NEWIPC // new ipc namespace ...  还有就是通过unshare的系统调用，具体可以看man page
nsproxy 在task_struct里有一个字段
1357 /* namespaces */ 1358 struct nsproxy *nsproxy;  其中
14 * A structure to contain pointers to all per-process 15 * namespaces - fs (mount), uts, network, sysvipc, etc. 16 * 17 * &#39;count&#39; is the number of tasks holding a reference.</description>
    </item>
    
    <item>
      <title>Linux Process Types</title>
      <link>https://wushaoqiang.github.io/posts/linux/linux-process-types/</link>
      <pubDate>Tue, 22 Oct 2019 21:16:30 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/linux/linux-process-types/</guid>
      <description>Linux的进程不仅仅是由代码组成，它还包括分配给进程的资源(如内存，文件等)
在Linux上，一个新的进程简单的创建可以通过fork和exec来实现
就好比如我们在shell上面运行一个sleep命令，那么这个命令其实也是通过两个步骤
 fork当前进程一个相同的副本(当前进程为shell)，我们可以这么认为，这两个相同的副本会具有相同的打开文件、工作目录以及内存数据等等，也会有不同的地方，比如PID这些具有唯一性的属性，还有进程之间的关系等(sleep进程的父进程就是shell本身)。
 exec会从一个可执行文件里加载另外一个应用程序(这里是sleep的二进制文件)，然后代替刚才复制出来的副本进程的程序。也就是说exec不会创建新的进程，只是在fork出来的副本上创建新的程序
  这里还要特别说一下，Linux为了解决fork的效率问题，在资源的复制上做了一些改进，使用(Copy-On-Write)的方式来复制副本：也就是说，副本并不是一次性完完全全的复制一份，而是等到其中一个进程要修改内存中的某一个共有的值的时候，才会去复制。否则按照只读的方式&amp;rdquo;共享&amp;rdquo;，后面详细讲一下
要是能大概理解Linux下这些相关进程的创建方式，平时在写一些命令的时候可以对自己写下的命令后面到底运行了哪些东西有个认知。并且这也是一种非常通用的概念
还有一种系统调用叫做clone，和fork相类似，不过clone不产生新的副本，而是共享资源，所以用于实现线程的创建。
在Linux上，一个线程其实也是进程，只是共享了资源
其实还有一个叫vfork，但是现在应该避免去调用它
上面的解释是非常浅显的，并没有道出多少技术细节，想要知道具体的细节，需要参考其中的一些标志位，例如clone就是通过标志位来实现共享资源的类型的。这些需要查阅相关man page来了解
COW Copy-On-Write
我们前面讲到，使用COW主要是因为
 使用大量内存(以共享的方式减少)
 耗费时间(需要复制的时候再赋值，惰性复制)
  因为我们可能在创建一个新进程的时候，完全不需要它的内存数据(两者数据没有关联)，因此直接的复制会导致做了很多无用功
fork还通过只复制其页表的方式来达到物理内存的共享，也就是两个独立的虚拟内存地址指向同样的物理内存
当然，进程之间不应该互相修改物理内存的数据，因此这个页表是只读的
在很多情况下COW都会为我们节省很多时间</description>
    </item>
    
    <item>
      <title>Linux Process Life Cycle</title>
      <link>https://wushaoqiang.github.io/posts/linux/linux-process-life-cycle/</link>
      <pubDate>Mon, 21 Oct 2019 20:23:27 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/linux/linux-process-life-cycle/</guid>
      <description>我们知道，现在的操作系统，给用户的感觉都是多任务执行的，可能执行的任务(Process)要比CPU还多
这个时候电脑程序看起来还是一起跑的
在Linux的Process Management里面，通过不断的让Scheduler交换执行进程，就可以实现这样的效果
State 这里先来了解一下关于进程生命周期的几个状态
 R(Running or Runnable)是指这个Process正在占用一个CPU，处于执行状态。或者，它处于可被执行的状态
 S(Interruptible Sleep)这种状态表示进程正在等待事件发生，这种情况下是可接收信号的，等到等待的时间发生再次满足Runnable的条件时，会置为R
 D(Uninterruptible Sleep)与上面的区别，这种状态是无法接收信号的
 T(Stopped)这里是暂停或者停止，比如在使用debugger的时候
 Z(Zombie)状态发生在进程被结束，但是数据还有部分残留在Process table里，这个时候在等待父进程调用wait4
  这些状态在linux源码里的linux/sched.h里面有定义
181 #define TASK_RUNNING 0 182 #define TASK_INTERRUPTIBLE 1 183 #define TASK_UNINTERRUPTIBLE 2 184 #define __TASK_STOPPED 4 185 #define __TASK_TRACED 8 186 /* in tsk-&amp;gt;exit_state */ 187 #define EXIT_ZOMBIE 16 188 #define EXIT_DEAD 32 189 /* in tsk-&amp;gt;state again */ 190 #define TASK_DEAD 64 191 #define TASK_WAKEKILL 128 192 #define TASK_WAKING 256 193 #define TASK_STATE_MAX 512  其中TRACED是调用ptrace时用的，主要是为了区分STOPPED</description>
    </item>
    
    <item>
      <title>Linux Account</title>
      <link>https://wushaoqiang.github.io/posts/linux/linux-account/</link>
      <pubDate>Mon, 22 Jul 2019 20:55:48 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/linux/linux-account/</guid>
      <description>Today, I want to login my Ubuntu as root. But, I don&amp;rsquo;t even remember I have set a password for root.
Fortunately, I learned some skills about how to manage accounts in linux, so I figure it out very quickly, I hope this experience can be helpful for you if you have the same(similar) problems
UID and GID When you login in a linux system, you must have a user and its password.</description>
    </item>
    
    <item>
      <title>Linux How to Identify Command</title>
      <link>https://wushaoqiang.github.io/posts/linux/linux-how-to-identify-command/</link>
      <pubDate>Mon, 22 Jul 2019 20:12:30 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/linux/linux-how-to-identify-command/</guid>
      <description>Today, I want to talk about a small topic &amp;ndash; how to identify a command
Specifically, If you want to know where are these commands from, there are three possibilities:
 builtin
 alias
 file(external)
  Let&amp;rsquo;s try it type cd // Of course, cd is a builtin command &amp;gt; cd is a shell builtin type ll &amp;gt; ll is aliased to `ls -alhF&#39; type mongod &amp;gt; mongod is /usr/local/mongodb/bin/mongod  Basically you don&amp;rsquo;t need to add any flags</description>
    </item>
    
    <item>
      <title>Linux Windows File</title>
      <link>https://wushaoqiang.github.io/posts/linux/linux-windows-file/</link>
      <pubDate>Sun, 21 Jul 2019 14:03:46 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/linux/linux-windows-file/</guid>
      <description>In linux, [Enter] =&amp;gt; LF
But in windows, [Enter] =&amp;gt; CRLF
So, if we cp a shell script file from windows to linux, we may not be able to run it because of the line break character is different
we need a tool to transform between windows(DOS) and linux(UNIX)
dos2unix [-kn] file [newfile] unix2dox [-kn] file [newfile] unix2mac [-kn] file [newfile]   k: keep modified date
 n: create new file</description>
    </item>
    
    <item>
      <title>Linux Vim Basic</title>
      <link>https://wushaoqiang.github.io/posts/linux/linux-vim-basic/</link>
      <pubDate>Sun, 21 Jul 2019 12:58:40 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/linux/linux-vim-basic/</guid>
      <description>Last time, we talked about linux compression
This time, I am gonna talk about basic usage about vim
vim is a highly recommended editor in UNIX-Like system, so it is necessary to learn that
To be honest I am not one of the vim-fans. Mostly, I use other editor(like VScode) or IDE to develop software, I use vim only when I just want to edit a config file or just couple lines of code which is not worth opening a editor(or IDE)</description>
    </item>
    
    <item>
      <title>Linux Compression</title>
      <link>https://wushaoqiang.github.io/posts/linux/linux-compression/</link>
      <pubDate>Sun, 21 Jul 2019 10:04:02 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/linux/linux-compression/</guid>
      <description>Last day, we took a quick look on file system, I just want to give you guys some basic understanding about that, If you are a software developer(engineer), may be that&amp;rsquo;s enough for you.
Today, let&amp;rsquo;s talk about a very basic and useful tool in linux &amp;ndash;&amp;gt; compression
Quick talk Basically, we use compression all the time, including surfing the internet, the server will give client(browser mostly) the compressed data instead of raw data which may cause the performance slow.</description>
    </item>
    
    <item>
      <title>Linux Link</title>
      <link>https://wushaoqiang.github.io/posts/linux/linux-link/</link>
      <pubDate>Sat, 20 Jul 2019 21:12:36 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/linux/linux-link/</guid>
      <description>We have already talked about disk management, now we have a pretty simple topic&amp;ndash;link
Link is one of the file types in linux including hard link and symbol link
Let&amp;rsquo;s get into them
hard link Remember inode?
when we type ls -l, the second field is the inode number which means how many file(s) is using the same inode.
Right, hard link file is using the same inode, and inode including the file information like permission, block number.</description>
    </item>
    
    <item>
      <title>Linux Disk Manage</title>
      <link>https://wushaoqiang.github.io/posts/linux/linux-disk-manage/</link>
      <pubDate>Sat, 20 Jul 2019 16:20:50 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/linux/linux-disk-manage/</guid>
      <description>Now, let&amp;rsquo;s get into the disk management of linux
Concept There are some concepts you should know about linux file system
Why we need to operate format before OS can use it?
Because different Operate System may use different file system, like FAT, NTFS, Ext2 etc.
After we know there are so many different file system, let&amp;rsquo;s talk about linux file system.
Here are some concepts:
 superblock: superblock will store file system information(like inode number, block number, etc.</description>
    </item>
    
    <item>
      <title>Linux Search File</title>
      <link>https://wushaoqiang.github.io/posts/linux/linux-search-file/</link>
      <pubDate>Sat, 20 Jul 2019 15:14:46 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/linux/linux-search-file/</guid>
      <description>Last time, I shared about how to read file content, and the most useful command
Today, I will make a little cover about searching file
which I do use a lot which to find binary file
which ls //output /bin/ls  It is a simple command to help us searching the binary file
locate locate is a powerful search command which is using database searching
locate filename //search included filename locate -i filename //ignore case locate -r regexp //use regular expression to search  As we can see the commands above there, we can also do any search with it</description>
    </item>
    
    <item>
      <title>Linux Read File</title>
      <link>https://wushaoqiang.github.io/posts/linux/linux-read-file/</link>
      <pubDate>Sat, 20 Jul 2019 14:31:21 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/linux/linux-read-file/</guid>
      <description>Last time, I talked about how to operate file like copy, move or remove
Today, let&amp;rsquo;s see how many ways do we have to read file content, I will introduce some basic and useful commands
cat cat filename will print all the content at once, so it is helpful when you just simply want to print the file content
cat -n filename // show the line number  but if the file is large(like 100M+), you may not want to use this.</description>
    </item>
    
    <item>
      <title>Linux File System Basic Command</title>
      <link>https://wushaoqiang.github.io/posts/linux/linux-file-system-basic-command/</link>
      <pubDate>Sat, 20 Jul 2019 11:39:18 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/linux/linux-file-system-basic-command/</guid>
      <description>Basic Command Last time, I shared about permission
Today the topic is Basic Command of File System
I am gonna give you some simple command you can use in your daily working situation
cd //enter a directory pwd //show the work directory(Print Working Directory)  mkdir
mkdir -m // set directory permission when create mkdir -p // If parent directory doesn&#39;t exist, it will help you create when you add -p flag  rmdir</description>
    </item>
    
    <item>
      <title>Linux Permission</title>
      <link>https://wushaoqiang.github.io/posts/linux/linux-permission/</link>
      <pubDate>Sat, 20 Jul 2019 10:31:23 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/linux/linux-permission/</guid>
      <description>Today, I am gonna talk about linux permission which is very basic for linux user.
Basically, we have three different role in linux
Owner Group Other  It is easy to understand what they mean.
ls -al In your home directory, type ls -al command and click Enter, you will see the output like:
-rw------- 1 user group 254 Oct 22 2018 .xsession-errors.old  Fields meaning As we can see, this line include several field separated by white space</description>
    </item>
    
    <item>
      <title>Linux Ps</title>
      <link>https://wushaoqiang.github.io/posts/linux/linux-ps/</link>
      <pubDate>Sun, 14 Jul 2019 22:11:55 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/linux/linux-ps/</guid>
      <description> ps命令有几种标准，这里只用UNIX版本的
Background 首先了解一些概念
 PID 进程ID
 PPID 父进程ID
 PGID 进程所在GroupID
 SID 进程所在会话(Session)ID
  一般来说，SID就是我们的shell
一个SID管理多个PGID
一个PGID管理很多PID
既然是管理，那就会有leader角色，那么如何知道谁是leader
PID == PGID的就是group leader
PID == SID的就是session leader
Flag Selection
-A -e 全部进程 -a 全部进程处理session leader -C 命令名字 -g group -u user -p pid -t tty  Format
-o pid,ppid,tty,time 选择输出某些字段 -F 全部字段(带字段名字 -f不带字段名字) --forest 树状形式输出  </description>
    </item>
    
    <item>
      <title>Linux Bash Awk</title>
      <link>https://wushaoqiang.github.io/posts/linux/linux-bash-awk/</link>
      <pubDate>Sun, 09 Jun 2019 22:44:43 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/linux/linux-bash-awk/</guid>
      <description>awk的一些用法
常见模式 awk &#39;/reg/&#39; &#39;BEGIN{} condition {condition action} END{}&#39; filename  其中
 /reg/ 是一个正则的匹配
 condition 是判断条件
 action 就是要执行的操作
 BEGIN 开始前的操作
 END 结束后的操作
  对文件 awk &#39;{print $1}&#39; test.txt  对管道 df -h | awk &#39;{print $1}&#39;  这里面的$1是指第一部分，默认分隔符是空格(制表符)
echo &amp;quot;This is a test&amp;quot; | awk &#39;{print $1}&#39;  输出的是This
如果想要的分隔符不是默认的，可以使用-F
例如
echo &amp;quot;This,is,a,test&amp;quot; | awk &#39;{print $1}&#39; #输出 This,is,a,test echo &amp;quot;This,is,a,test&amp;quot; | awk -F &#39;,&#39; &#39;{print $1}&#39; #输出 This  更多高级的用法 先说说内置的变量</description>
    </item>
    
    <item>
      <title>Linux Bash Test</title>
      <link>https://wushaoqiang.github.io/posts/linux/linux-bash-test/</link>
      <pubDate>Sun, 09 Jun 2019 21:51:11 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/linux/linux-bash-test/</guid>
      <description> test命令是bash中一个重要的判断命令
虽然我们在其它编程语言上习惯使用if判断语句去实施判断，但也有必要了解一下这一种的判断手段
if + test if test -e ./test.txt; then echo &amp;quot;exist&amp;quot;; fi  [ ] 因为上面那种结合if条件判断的和原有的差不多，所以我们一般常用的是[]
例子
[ -e ./test.txt ] &amp;amp;&amp;amp; echo &amp;quot;exist&amp;quot; || echo &amp;quot;doesn&#39;t exist&amp;quot;  这里就是存在就会输出exist，不存在就会输出后面的那个
而且这还适用于
 文件类型判断
 文件权限
 两文件之间
 整数之间
 字符串之间
 多重条件(也就是AND和OR还有NOT)
  </description>
    </item>
    
    <item>
      <title>Linux Bash Basic Note</title>
      <link>https://wushaoqiang.github.io/posts/linux/linux-bash-basic-note/</link>
      <pubDate>Sun, 09 Jun 2019 18:55:28 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/linux/linux-bash-basic-note/</guid>
      <description>记录一些笔记
参考 https://www.jianshu.com/p/e1c8e5bfa45e
变量 注意变量赋值别加空格
变量命名只能用字母、数字和下划线，且数字不能在开头
 readonly 只读变量，用法和read类似
 unset 可以删除变量，但不可删除只读变量
  本质上来说，bash里面都是字符串，只有当变量是纯数字的时候才是所谓的数字类型
局部和全局 这里要特别注意，普通变量默认是全局变量
所以要想在函数中定义局部变量，需要加local声明
local var1  环境变量 这个就和linux上的一些环境是一样的
特殊变量 $0 当前脚本的文件名 $1,$2... 传递给脚本或函数的参数,按顺序的 $# 传递给脚本或函数的参数个数 $* 传递给脚本或函数的所有参数 $? 上个命令的退出状态，或函数的返回值 $$ 当前Shell进程ID  转义字符 echo默认是不转移字符的，但printf是会转义的
转义字符的含义和其它编程语言基本一样
命令替换 我们可以将命令的输出存储起来
比如存储一个日期
date=`date`  注意，这个是反引号
运算符 shell脚本的运算符好像和其它编程语言有很大的差异，它主要是用flag形式
关于数字的 -eq -ne -gt -lt -ge -le  关于布尔值 ! not -o or -a and  所以像其它编程语言可能会用 &amp;amp;&amp;amp; || 这些符号
关于字符串 == !</description>
    </item>
    
    <item>
      <title>Linux Bash</title>
      <link>https://wushaoqiang.github.io/posts/linux/linux-bash/</link>
      <pubDate>Sun, 09 Jun 2019 15:56:26 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/linux/linux-bash/</guid>
      <description>给自己定的一些规范 因为shell的语法太灵活，有许多语法是不唯一的，导致我很纠结，下面结合他人的实战经历，规定自己一套规范，以后写shell尽量按照这样的规范来
用printf函数，在format-string上加引号 给所有变量加上花括号 ${VAR} 运算符尽量使用flag形式(字符串不能用这个形式) 判断只用[]  需要特别注意的一些点 关于字符串 单引号‘’会原样输出字符串，对里面的变量引用都是没用的，转义字符也没用 双引号可以引用变量和转义字符  初学例子
开头指定解释器
#!/bin/bash  这里记一些用过的语法
取奇数
for i in {1.99..2} do echo $i done  读取stdin
read name echo &amp;quot;Welcome $name&amp;quot;  读取并输出运算后结果
read x read y echo $((x+y)) echo $((x-y)) echo $((x*y)) echo $((x/y))  读取并比较
read X read Y if (($X&amp;gt;$Y)); then echo &amp;quot;X is greater than Y&amp;quot;; elif (($X&amp;lt;$Y)); then echo &amp;quot;X is less than Y&amp;quot;; else echo &amp;quot;X is equal to Y&amp;quot;; fi  字符串的比较</description>
    </item>
    
    <item>
      <title>Ubuntu apt</title>
      <link>https://wushaoqiang.github.io/posts/linux/linux-apt/</link>
      <pubDate>Tue, 07 May 2019 11:00:18 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/linux/linux-apt/</guid>
      <description> 这个总结一下我经常用到的关于apt的命令
apt vs apt-get 这个问题其实也在一开始困扰了我很久，网上有人使用apt，有人使用apt-get，那到底用哪个？
其实apt的后来推出的版本，越来越多人已经被它对人阅读的友好给征服了，apt-get输出的信息给人看起来比较不友好
因此对于新入门的来说，建议使用apt
当然，apt-get并没有被遗弃，也有很多人在用
常用命令 更新仓库 sudo apt update 更新本地可更新的 sudo apt upgrade 一键更新 sudo apt update &amp;amp;&amp;amp; sudo apt upgrade -y 安装，如果pkg本身就已经安装，这个就是更新操作了 sudo apt install &amp;lt;pkg&amp;gt; 如果安装的包存在，不要更新，如果不存在，就安装 sudo apt install &amp;lt;pkg&amp;gt; --no-upgrade 如果包存在就更新，不存在也不安装 sudo apt install &amp;lt;pkg&amp;gt; --only-upgrade 指定版本安装 sudo apt install &amp;lt;pkg&amp;gt;=&amp;lt;version&amp;gt; 删除(不包括配置文件) sudo apt remove &amp;lt;pkg&amp;gt; 彻底删除(包括配置文件) sudo apt purge &amp;lt;pkg&amp;gt; 显示出这个term所有的package apt search &amp;lt;term&amp;gt; 这个可以显示pkg详细信息 apt show &amp;lt;pkg&amp;gt; 显示已安装的pkg apt list --installed 自动清除(清除那些没有用的pkg) sudo apt autoremove  </description>
    </item>
    
    <item>
      <title>Linux 网络管理</title>
      <link>https://wushaoqiang.github.io/posts/linux/linux-network-management/</link>
      <pubDate>Thu, 25 Apr 2019 20:29:02 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/linux/linux-network-management/</guid>
      <description>ping -c 发送一定数量的报文
ifconfig 其中输出信息里
enp0s31f6：以太网(有线)
lo：回传
wlp4s0：无线网
tcpdump 这是一个类似wireshark抓包的命令,需要权限
-c：指定抓取包的数量
-i：指定接口(上面说到有3个接口)
port：指定端口
netstat -r：显示路由
-i：显示接口
-n：显示IP
-t：tcp
-u：udp</description>
    </item>
    
    <item>
      <title>Linux 进程管理</title>
      <link>https://wushaoqiang.github.io/posts/linux/linux-process-management/</link>
      <pubDate>Thu, 25 Apr 2019 17:04:19 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/linux/linux-process-management/</guid>
      <description>进程状态  R 正在运行或在运行队列
 D 不可中断，进程不会因为信号被唤醒，只能等待中断发生
 S 中断，等待某个事件完成或者被信号唤醒
 Z 僵死，进程已经终止但其父进程没有用wait()或在waitpid()来释放它
 T 停止，可能是收到控制信号，也可能是被跟踪
  相关命令 ps,pstree,top(htop),jobs,kill，nice，nohup
Crtl+c:终结进程
Ctrl+z:暂停进程
ps(Process Status) ps 只会给当前终端中运行的进程
ps -a Select all processes except both session leaders (see getsid(2)) and processes not associated with a terminal.
ps -u root显示root用户的process，这里root也可以是别的用户名
ps -l 相对ps，会显示父PID等信息
ps aux 显示所有process
ps -ef 详细显示所有process
pstree pstree 进程树
pstree -p 显示PID
pstree (username) 显示用户的进程
jobs jobs 查看后台运行的进程
fg %num 将后台程序转移到前台</description>
    </item>
    
    <item>
      <title>Linux命令笔记</title>
      <link>https://wushaoqiang.github.io/posts/linux/linux-note/</link>
      <pubDate>Sun, 17 Mar 2019 01:52:15 +0800</pubDate>
      
      <guid>https://wushaoqiang.github.io/posts/linux/linux-note/</guid>
      <description>Command 这里只是笔者对Linux常用命令的笔记，方便自己查询
ifconfig 查看网络连接
lsof -i:8000 查看端口8000占用情况
kill -9 PID 把某个PID的进程结束了，kill还有许多flag，1:挂起， 2:中断 ，3:退出
mkdir -p /1/2/3/4 可以一次创建多层文件夹
pkill -f &amp;lt;name&amp;gt; 可以直接kill掉一个已知名字的进程
把脚本放进/etc/init.d/里面就可以自启动
chown user:group &amp;lt;file&amp;gt; 改变文件持有
磁盘 du -hsc &amp;lt;path&amp;gt; 查看路径占用磁盘大小
ncdu 更友好的查看磁盘占用情况的一个命令，需要安装
df -h查看磁盘占用情况
别名 alias &amp;lt;name&amp;gt;=&amp;quot;&amp;lt;command&amp;gt;&amp;quot; 用别名调用命令(适用于长命令)，如果需要持久化的话，需要写入.bashrc
查找文件 find &amp;lt;path&amp;gt; -name &amp;quot;*.log&amp;quot; 寻找在路径里面结尾为.log的文件，同理，想要查找一类文件可以用这个命令
find &amp;lt;path&amp;gt; ! -name &amp;quot;*.log&amp;quot; 与上面刚好相反
find -mtime &amp;lt;number&amp;gt;这个命令还可以根据修改时间
匹配 grep -r &amp;quot;error&amp;quot; &amp;lt;path or file&amp;gt; 会打印出所有含有error的字段
查看CPU&amp;amp;内存占用情况 top 这个命令对界面不太友好
htop 这个对阅读更加友好
update 能够看到电脑持续开机时间</description>
    </item>
    
  </channel>
</rss>